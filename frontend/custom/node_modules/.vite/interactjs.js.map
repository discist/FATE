{
  "version": 3,
  "sources": ["../interactjs/dist/_header.js", "../interactjs/dist/node_modules/browser-pack-flat/_prelude", "../interactjs/dist/packages/@interactjs/utils/isWindow.ts", "../interactjs/dist/packages/@interactjs/utils/window.ts", "../interactjs/dist/packages/@interactjs/utils/is.ts", "../interactjs/dist/packages/@interactjs/actions/drag/plugin.ts", "../interactjs/dist/packages/@interactjs/utils/domObjects.ts", "../interactjs/dist/packages/@interactjs/utils/browser.ts", "../interactjs/dist/packages/@interactjs/utils/domUtils.ts", "../interactjs/dist/packages/@interactjs/utils/extend.ts", "../interactjs/dist/packages/@interactjs/utils/rect.ts", "../interactjs/dist/packages/@interactjs/utils/getOriginXY.ts", "../interactjs/dist/packages/@interactjs/utils/normalizeListeners.ts", "../interactjs/dist/packages/@interactjs/utils/hypot.ts", "../interactjs/dist/packages/@interactjs/utils/pointerExtend.ts", "../interactjs/dist/packages/@interactjs/utils/pointerUtils.ts", "../interactjs/dist/packages/@interactjs/core/BaseEvent.ts", "../interactjs/dist/packages/@interactjs/utils/arr.ts", "../interactjs/dist/packages/@interactjs/actions/drop/DropEvent.ts", "../interactjs/dist/packages/@interactjs/actions/drop/plugin.ts", "../interactjs/dist/packages/@interactjs/actions/gesture/plugin.ts", "../interactjs/dist/packages/@interactjs/actions/resize/plugin.ts", "../interactjs/dist/packages/@interactjs/actions/plugin.ts", "../interactjs/dist/packages/@interactjs/utils/raf.ts", "../interactjs/dist/packages/@interactjs/auto-scroll/plugin.ts", "../interactjs/dist/packages/@interactjs/utils/misc.ts", "../interactjs/dist/packages/@interactjs/auto-start/InteractableMethods.ts", "../interactjs/dist/packages/@interactjs/auto-start/base.ts", "../interactjs/dist/packages/@interactjs/auto-start/dragAxis.ts", "../interactjs/dist/packages/@interactjs/auto-start/hold.ts", "../interactjs/dist/packages/@interactjs/auto-start/plugin.ts", "../interactjs/dist/packages/@interactjs/core/interactablePreventDefault.ts", "../interactjs/dist/packages/@interactjs/dev-tools/visualizer/plugin.ts", "../interactjs/dist/packages/@interactjs/dev-tools/plugin.ts", "../interactjs/dist/packages/@interactjs/utils/clone.ts", "../interactjs/dist/packages/@interactjs/modifiers/Modification.ts", "../interactjs/dist/packages/@interactjs/modifiers/base.ts", "../interactjs/dist/packages/@interactjs/core/options.ts", "../interactjs/dist/packages/@interactjs/core/InteractEvent.ts", "../interactjs/dist/packages/@interactjs/core/PointerInfo.ts", "../interactjs/dist/packages/@interactjs/core/Interaction.ts", "../interactjs/dist/packages/@interactjs/offset/plugin.ts", "../interactjs/dist/packages/@interactjs/inertia/plugin.ts", "../interactjs/dist/packages/@interactjs/core/Eventable.ts", "../interactjs/dist/packages/@interactjs/core/isNonNativeEvent.ts", "../interactjs/dist/packages/@interactjs/core/InteractStatic.ts", "../interactjs/dist/packages/@interactjs/core/Interactable.ts", "../interactjs/dist/packages/@interactjs/core/InteractableSet.ts", "../interactjs/dist/packages/@interactjs/core/events.ts", "../interactjs/dist/packages/@interactjs/core/interactionFinder.ts", "../interactjs/dist/packages/@interactjs/core/interactions.ts", "../interactjs/dist/packages/@interactjs/core/scope.ts", "../interactjs/dist/packages/@interactjs/interact/index.ts", "../interactjs/dist/packages/@interactjs/snappers/edgeTarget.ts", "../interactjs/dist/packages/@interactjs/snappers/elements.ts", "../interactjs/dist/packages/@interactjs/snappers/grid.ts", "../interactjs/dist/packages/@interactjs/snappers/plugin.ts", "../interactjs/dist/packages/@interactjs/modifiers/aspectRatio.ts", "../interactjs/dist/packages/@interactjs/modifiers/noop.ts", "../interactjs/dist/packages/@interactjs/modifiers/restrict/pointer.ts", "../interactjs/dist/packages/@interactjs/modifiers/restrict/edges.ts", "../interactjs/dist/packages/@interactjs/modifiers/restrict/rect.ts", "../interactjs/dist/packages/@interactjs/modifiers/restrict/size.ts", "../interactjs/dist/packages/@interactjs/modifiers/snap/pointer.ts", "../interactjs/dist/packages/@interactjs/modifiers/snap/size.ts", "../interactjs/dist/packages/@interactjs/modifiers/snap/edges.ts", "../interactjs/dist/packages/@interactjs/modifiers/all.ts", "../interactjs/dist/packages/@interactjs/modifiers/plugin.ts", "../interactjs/dist/packages/@interactjs/pointer-events/PointerEvent.ts", "../interactjs/dist/packages/@interactjs/pointer-events/base.ts", "../interactjs/dist/packages/@interactjs/pointer-events/holdRepeat.ts", "../interactjs/dist/packages/@interactjs/pointer-events/interactableTargets.ts", "../interactjs/dist/packages/@interactjs/pointer-events/plugin.ts", "../interactjs/dist/packages/@interactjs/reflow/plugin.ts", "../interactjs/dist/packages/@interactjs/interactjs/index.ts", "../interactjs/dist/packages/interactjs/index.ts", "../interactjs/dist/node_modules/browser-pack-flat/_postlude", "dep:interactjs"],
  "sourcesContent": ["/* interact.js 1.10.11 | https://interactjs.io/license */\n", "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;\n", "export default (thing: any) => !!(thing && thing.Window) && thing instanceof thing.Window\n", "import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n", "import type { Element } from '@interactjs/types/index'\n\nimport isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window => thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment => object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } => !!thing && typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) => any => typeof thing === 'function'\n\nconst number = (thing: any): thing is number => typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean => typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string => typeof thing === 'string'\n\nconst element = (thing: any): thing is Element => {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  // eslint-disable-next-line import/no-named-as-default-member\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof _window.Element)\n    ? thing instanceof _window.Element // DOM2\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) && !!thing.constructor && /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  object(thing) && typeof thing.length !== 'undefined' && func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n", "import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, DraggableOptions, DropzoneOptions } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drag: DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = InteractEvent<'drag'>\n\nexport type DraggableMethod = ActionMethod<DraggableOptions>\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y = 0\n  } else if (axis === 'y') {\n    interaction.coords.cur.page.x = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite] = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (\n  this: Interactable,\n  options?: DraggableOptions | boolean,\n): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag: Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': (arg) => {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions && dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &&\n          /mouse|pointer/.test(interaction.pointerType) &&\n          (buttons & interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis,\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis: 'xy',\n    lockAxis: 'xy',\n  } as DropzoneOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n", "const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n", "import domObjects from './domObjects'\nimport is from './is'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator: Partial<Navigator> = window.navigator || {}\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = ('matches' in Element.prototype\n    ? 'matches'\n    : 'webkitMatchesSelector' in Element.prototype\n      ? 'webkitMatchesSelector'\n      : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n          ? 'oMatchesSelector'\n          : 'msMatchesSelector') as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up: 'MSPointerUp',\n        down: 'MSPointerDown',\n        over: 'mouseover',\n        out: 'mouseout',\n        move: 'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up: 'pointerup',\n        down: 'pointerdown',\n        over: 'pointerover',\n        out: 'pointerout',\n        move: 'pointermove',\n        cancel: 'pointercancel',\n      }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = domObjects.document && 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n", "import type { Rect, Target, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as SVGElement).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n", "export default function extend<T, U extends object> (dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    ;((dest as unknown) as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n", "import type {\n  HasGetRect,\n  RectResolvable,\n  Rect,\n  Element,\n  Point,\n  FullRect,\n  EdgeOptions,\n} from '@interactjs/types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]> (\n  value: RectResolvable<T>,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function rectToXY (rect: Rect | Point) {\n  return (\n    rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr<T extends Partial<Rect & Point>> (rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect & T\n}\n\nexport function tlbrToXywh (rect: Rect & Partial<Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect & Point\n}\n\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n", "import type { PerActionDefaults } from '@interactjs/core/options'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { HasGetRect } from '@interactjs/types/index'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: HasGetRect & { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n", "import type { EventTypes, Listener, ListenersArg } from '@interactjs/types/index'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize (\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>((acc, t) => extend(acc, normalize(t, listeners, result)), result)\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n", "export default (x: number, y: number) => Math.sqrt(x * x + y * y)\n", "function pointerExtend<T> (dest: Partial<T>, source: T) {\n  for (const prop in source) {\n    const prefixedPropREs = pointerExtend.prefixedPropREs\n    let deprecated = false\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true\n        break\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop]\n    }\n  }\n  return dest\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  moz: /(Pressure)$/,\n} as { [prefix: string]: RegExp }\n\nexport default pointerExtend\n", "import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer (pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as keyof PointerType]\n  xy.y = pointer[(type + 'Y') as keyof PointerType]\n\n  return xy\n}\n\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n    // be either a MouseEvent, TouchEvent, or Touch object\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : ((event as unknown) as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords (): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () {\n      return this.coords.page\n    },\n    get client () {\n      return this.coords.client\n    },\n    get timeStamp () {\n      return this.coords.timeStamp\n    },\n    get pageX () {\n      return this.coords.page.x\n    },\n    get pageY () {\n      return this.coords.page.y\n    },\n    get clientX () {\n      return this.coords.client.x\n    },\n    get clientY () {\n      return this.coords.client.y\n    },\n    get pointerId () {\n      return this.coords.pointerId\n    },\n    get target () {\n      return this.coords.target\n    },\n    get type () {\n      return this.coords.type\n    },\n    get pointerType () {\n      return this.coords.pointerType\n    },\n    get buttons () {\n      return this.coords.buttons\n    },\n    preventDefault () {},\n  }\n\n  return event as typeof event & PointerType & PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nexport class BaseEvent<T extends ActionName | null = never> {\n  type: string\n  target: EventTarget\n  currentTarget: Node\n  interactable: Interactable\n  _interaction: Interaction<T>\n  timeStamp: any\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interaction<T>) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends ActionName> {\n  interaction: InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set (this: BaseEvent) {},\n})\n", "type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>) => array[findIndex(array, func)]\n", "import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\n\nimport type { DropState } from './plugin'\n\nexport class DropEvent extends BaseEvent<'drag'> {\n  target: Element\n  dropzone: Interactable\n  dragEvent: InteractEvent<'drag'>\n  relatedTarget: Element\n  draggable: Interactable\n  timeStamp: number\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropState: DropState, dragEvent: InteractEvent<'drag'>, type: string) {\n    super(dragEvent._interaction)\n\n    const { element, dropzone } = type === 'dragleave' ? dropState.prev : dropState.cur\n\n    this.type = type\n    this.target = element\n    this.currentTarget = element\n    this.dropzone = dropzone\n    this.dragEvent = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.draggable = dragEvent.interactable\n    this.timeStamp = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropState } = this._interaction\n\n    if (\n      this.type !== 'dropactivate' &&\n      (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)\n    ) {\n      return\n    }\n\n    dropState.prev.dropzone = this.dropzone\n    dropState.prev.element = this.target\n\n    dropState.rejected = true\n    dropState.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropState.activeDrops\n      const index = arr.findIndex(\n        activeDrops,\n        ({ dropzone, element }) => dropzone === this.dropzone && element === this.target,\n      )\n\n      dropState.activeDrops.splice(index, 1)\n\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    } else {\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n", "import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { DropzoneOptions, Element, PointerEventType, Rect } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { DragEvent } from '../drag/plugin'\nimport drag from '../drag/plugin'\n\nimport { DropEvent } from './DropEvent'\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\n  (): DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any,\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    prevDropzone?: Interactable\n    dropzone?: Interactable\n    dragEnter?: Element\n    dragLeave?: Element\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drop: DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  interface InteractStatic {\n    dynamicDrop: (this: InteractStatic, newValue?: boolean) => boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interaction<'drag'>\n  dragEvent: DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Element\n  rect: Rect\n}\n\nexport interface DropState {\n  cur: {\n    // the dropzone a drag target might be dropped into\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  prev: {\n    // the dropzone that was recently dragged away from\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  // wheather the potential drop was rejected from a listener\n  rejected: boolean\n  // the drop events related to the current drag event\n  events: FiredDropEvents\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable,\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {object | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interactable, options?: DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (\n    this: Interactable,\n    dragEvent,\n    event,\n    draggable,\n    draggableElement,\n    dropElement,\n    rect,\n  ) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }: Scope, draggableElement: Element) {\n  const drops: ActiveDrop[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) {\n      continue\n    }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if (\n      (is.element(accept) && accept !== draggableElement) ||\n      (is.string(accept) && !domUtils.matchesSelector(draggableElement, accept)) ||\n      (is.func(accept) && !accept({ dropzone, draggableElement }))\n    ) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = (is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : is.array(dropzone.target)\n        ? dropzone.target\n        : [dropzone.target]) as Element[]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n          rect: dropzone.getRect(dropzoneElement),\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops: ActiveDrop[], event: DropEvent) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop (\n  { dropState, interactable: draggable, element: dragElement }: Partial<Interaction>,\n  dragEvent,\n  pointerEvent,\n) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(\n      dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n        ? dropzoneElement\n        : null,\n    )\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\ntype FiredDropEvents = Partial<\nRecord<'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent>\n>\n\nfunction fireDropEvents (interaction: Interaction, events: FiredDropEvents) {\n  const { dropState } = interaction\n  const { activeDrops, cur, prev } = dropState\n\n  if (events.leave) {\n    prev.dropzone.fire(events.leave)\n  }\n  if (events.enter) {\n    cur.dropzone.fire(events.enter)\n  }\n  if (events.move) {\n    cur.dropzone.fire(events.move)\n  }\n  if (events.drop) {\n    cur.dropzone.fire(events.drop)\n  }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: DoPhaseArg<'drag', EventPhase>, scope: Scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return\n  }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected =\n    dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\nfunction dropzoneMethod (interactable: Interactable, options?: DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) {\n      interactable.on('drop', options.ondrop)\n    }\n    if (is.func(options.ondropactivate)) {\n      interactable.on('dropactivate', options.ondropactivate)\n    }\n    if (is.func(options.ondropdeactivate)) {\n      interactable.on('dropdeactivate', options.ondropdeactivate)\n    }\n    if (is.func(options.ondragenter)) {\n      interactable.on('dragenter', options.ondragenter)\n    }\n    if (is.func(options.ondragleave)) {\n      interactable.on('dragleave', options.ondragleave)\n    }\n    if (is.func(options.ondropmove)) {\n      interactable.on('dropmove', options.ondropmove)\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    } else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interactable,\n  dragEvent: InteractEvent,\n  event: PointerEventType,\n  draggable: Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return interactable.options.drop.checker\n      ? interactable.options.drop.checker(\n        dragEvent,\n        event,\n        dropped,\n        interactable,\n        dropElement,\n        draggable,\n        draggableElement,\n      )\n      : false\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = page.x > rect.left && page.x < rect.right\n    const vertical = page.y > rect.top && page.y < rect.bottom\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width / 2\n    const cy = dragRect.top + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && is.number(dropOverlap)) {\n    const overlapArea =\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(\n      dragEvent,\n      event,\n      dropped,\n      interactable,\n      dropElement,\n      draggable,\n      draggableElement,\n    )\n  }\n\n  return dropped\n}\n\nconst drop: Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': (\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': (\n      { interaction, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: DoPhaseArg<'drag', EventPhase>, scope) => {\n      if (arg.interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer',\n  } as DropzoneOptions,\n}\n\nexport default drop\n", "import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Options } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, GesturableOptions, Rect, PointerType } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport type GesturableMethod = ActionMethod<GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg<'gesture', EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interaction<'gesture'>\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (\n    this: InstanceType<typeof Interactable>,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': (arg) => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n", "import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type {\n  ActionMethod,\n  ResizableOptions,\n  FullRect,\n  OrBoolean,\n  Point,\n  Rect,\n} from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = ActionMethod<ResizableOptions>\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    resize: ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizeEvent<P extends EventPhase = EventPhase> extends InteractEvent<'resize', P> {\n  deltaRect?: FullRect\n  edges?: ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) {\n    return undefined\n  }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions && resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &&\n      /mouse|pointer/.test(interaction.pointerType) &&\n      (buttons & resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(\n        edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin,\n      )\n    }\n\n    resizeEdges.left = resizeEdges.left && !resizeEdges.right\n    resizeEdges.top = resizeEdges.top && !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  } else {\n    const right = resizeOptions.axis !== 'y' && page.x > rect.right - resize.defaultMargin\n    const bottom = resizeOptions.axis !== 'x' && page.y > rect.bottom - resize.defaultMargin\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interactable, options: OrBoolean<ResizableOptions> | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    } else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    } else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Point,\n  element: Node,\n  interactableElement: Element,\n  rect: Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) {\n    return false\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width = is.number(rect.width) ? rect.width : rect.right - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right'\n      } else if (name === 'right') {\n        name = 'left'\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom'\n      } else if (name === 'bottom') {\n        name = 'top'\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin\n    }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) {\n    return false\n  }\n\n  return is.element(value)\n    ? // the value is an element to use as a resize handle\n    value === element\n    : // otherwise check if element matches value as selector\n    dom.matchesUpTo(element, value, interactableElement)\n}\n\n/* eslint-disable multiline-ternary */\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\n  return browser.isIe9\n    ? {\n      x: 'e-resize',\n      y: 's-resize',\n      xy: 'se-resize',\n\n      top: 'n-resize',\n      left: 'w-resize',\n      bottom: 's-resize',\n      right: 'e-resize',\n      topleft: 'se-resize',\n      bottomright: 'se-resize',\n      topright: 'ne-resize',\n      bottomleft: 'ne-resize',\n    }\n    : {\n      x: 'ew-resize',\n      y: 'ns-resize',\n      xy: 'nwse-resize',\n\n      top: 'ns-resize',\n      left: 'ew-resize',\n      bottom: 'ns-resize',\n      right: 'ew-resize',\n      topleft: 'nwse-resize',\n      bottomright: 'nwse-resize',\n      topright: 'nesw-resize',\n      bottomleft: 'nesw-resize',\n    }\n}\n/* eslint-enable multiline-ternary */\n\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right: 0,\n      width: 0,\n      top: 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top > corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left > corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  } else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left = Math.min(current.left, startRect.right)\n    corrected.right = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width = corrected.right - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any, any>\n  interaction: Interaction\n}) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) return\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    } else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  } else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    } else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': (arg) => {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': (arg) => {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as ResizableOptions,\n\n  cursors: null as ReturnType<typeof initCursors>,\n\n  getCursor ({ edges, axis, name }: ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    } else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n", "import type { Scope } from '@interactjs/core/scope'\n\nimport drag from './drag/plugin'\nimport drop from './drop/plugin'\nimport gesture from './gesture/plugin'\nimport resize from './resize/plugin'\n\nexport default {\n  id: 'actions',\n  install (scope: Scope) {\n    scope.usePlugin(gesture)\n    scope.usePlugin(resize)\n    scope.usePlugin(drag)\n    scope.usePlugin(drop)\n  },\n}\n", "let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (global: Window | typeof globalThis) {\n  request = global.requestAnimationFrame\n  cancel = global.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = global[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        global[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        global[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(global)\n  cancel = cancel && cancel.bind(global)\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = global.setTimeout(() => {\n        // eslint-disable-next-line node/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token as any\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install (scope: Scope) {\n  const { defaults, actions } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled: false,\n    margin: 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed: 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interaction,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction: Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        } else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable: Interactable, actionName: ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll?.enabled\n  },\n  onInteractionMove<T extends ActionName> ({\n    interaction,\n    pointer,\n  }: {\n    interaction: Interaction<T>\n    pointer: PointerType\n  }) {\n    if (\n      !(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))\n    ) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left = pointer.clientX < autoScroll.margin\n      top = pointer.clientY < autoScroll.margin\n      right = pointer.clientX > container.innerWidth - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    } else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left = pointer.clientX < rect.left + autoScroll.margin\n      top = pointer.clientY < rect.top + autoScroll.margin\n      right = pointer.clientX > rect.right - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value: any, interactable: Interactable, element: Element) {\n  return (\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n  )\n}\n\nexport function getScroll (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends ActionName> (\n  {\n    interaction,\n    element,\n  }: {\n    interaction: Partial<Interaction<T>>\n    element: Element\n  },\n  func: any,\n) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n", "import type { ActionProps } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nimport { window } from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction<T extends ActionName> (dest: ActionProps<any>, src: ActionProps<T>) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport const sign = (n: number) => (n >= 0 ? 1 : -1)\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, ActionName, Plugin } from '@interactjs/core/scope'\nimport type { CursorChecker, PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install (scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName> (\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches (interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName> (\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName> (interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope, ActionName } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n", "import type { Scope } from '@interactjs/core/scope'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/types/index'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) => void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault(this: Interactable): PreventDefaultValue\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &&\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &&\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n", "export default {}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport visualizer from '@interactjs/dev-tools/visualizer/plugin'\nimport type { Element, OptionMethod } from '@interactjs/types/index'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as win from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    logger: Logger\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    visializer: typeof visualizer\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    devTools?: DevToolsOptions\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    devTools: OptionMethod<DevToolsOptions>\n  }\n}\n\nexport interface DevToolsOptions {\n  ignore: { [P in keyof typeof CheckName]?: boolean }\n}\n\nexport interface Logger {\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n  log: (...args: any[]) => void\n}\n\nexport interface Check {\n  name: CheckName\n  text: string\n  perform: (interaction: Interaction) => boolean\n  getInfo: (interaction: Interaction) => any[]\n}\n\nenum CheckName {\n  touchAction = 'touchAction',\n  boxSizing = 'boxSizing',\n  noListeners = 'noListeners',\n}\n\nconst prefix = '[interact.js] '\nconst links = {\n  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',\n  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing',\n}\n\n// eslint-disable-next-line no-undef\nconst isProduction = process.env.NODE_ENV === 'production'\n\nfunction install (scope: Scope, { logger }: { logger?: Logger } = {}) {\n  const { Interactable, defaults } = scope\n\n  scope.logger = logger || console\n\n  defaults.base.devTools = {\n    ignore: {},\n  }\n\n  Interactable.prototype.devTools = function (options?: object) {\n    if (options) {\n      extend(this.options.devTools, options)\n      return this\n    }\n\n    return this.options.devTools\n  }\n\n  scope.usePlugin(visualizer)\n}\n\nconst checks: Check[] = [\n  {\n    name: CheckName.touchAction,\n    perform ({ element }) {\n      return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/)\n    },\n    getInfo ({ element }) {\n      return [element, links.touchAction]\n    },\n    text: 'Consider adding CSS \"touch-action: none\" to this element\\n',\n  },\n\n  {\n    name: CheckName.boxSizing,\n    perform (interaction) {\n      const { element } = interaction\n\n      return (\n        interaction.prepared.name === 'resize' &&\n        element instanceof domObjects.HTMLElement &&\n        !hasStyle(element, 'boxSizing', /border-box/)\n      )\n    },\n    text: 'Consider adding CSS \"box-sizing: border-box\" to this resizable element',\n    getInfo ({ element }) {\n      return [element, links.boxSizing]\n    },\n  },\n\n  {\n    name: CheckName.noListeners,\n    perform (interaction) {\n      const actionName = interaction.prepared.name\n      const moveListeners = interaction.interactable.events.types[`${actionName}move`] || []\n\n      return !moveListeners.length\n    },\n    getInfo (interaction) {\n      return [interaction.prepared.name, interaction.interactable]\n    },\n    text: 'There are no listeners set for this action',\n  },\n]\n\nfunction hasStyle (element: HTMLElement, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  const value = element.style[prop] || win.window.getComputedStyle(element)[prop]\n  return styleRe.test((value || '').toString())\n}\n\nfunction parentHasStyle (element: Element, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  let parent = element as HTMLElement\n\n  while (is.element(parent)) {\n    if (hasStyle(parent, prop, styleRe)) {\n      return true\n    }\n\n    parent = parentNode(parent) as HTMLElement\n  }\n\n  return false\n}\n\nconst id = 'dev-tools'\nconst defaultExport: Plugin = isProduction\n  ? { id, install: () => {} }\n  : {\n    id,\n    install,\n    listeners: {\n      'interactions:action-start': ({ interaction }, scope) => {\n        for (const check of checks) {\n          const options = interaction.interactable && interaction.interactable.options\n\n          if (\n            !(options && options.devTools && options.devTools.ignore[check.name]) &&\n              check.perform(interaction)\n          ) {\n            scope.logger.warn(prefix + check.text, ...check.getInfo(interaction))\n          }\n        }\n      },\n    },\n    checks,\n    CheckName,\n    links,\n    prefix,\n  }\n\nexport default defaultExport\n", "import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n", "import type { EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { Modifier, ModifierArg, ModifierState } from './base'\n\nexport interface ModificationResult {\n  delta: Point\n  rectDelta: Rect\n  coords: Point\n  rect: FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: EventPhase\n  pageCoords: Point\n  rect: FullRect\n  coords: Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta!: Point\n  result!: ModificationResult\n  endResult!: Point\n  edges!: EdgeOptions\n  readonly interaction: Readonly<Interaction>\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n  }\n\n  start ({ phase }: { phase: EventPhase }, pageCoords: Point) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.edges = extend({}, interaction.edges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg = this.fillArg({\n      phase,\n      pageCoords,\n      preEnd: false,\n    })\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = (this.result = this.setAll(arg))\n\n    return result\n  }\n\n  fillArg (arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect = arg.rect || interaction.rect\n    arg.edges = this.edges\n    arg.startOffset = this.startOffset\n\n    return arg as ModifierArg\n  }\n\n  startAll (arg: MethodArg & Partial<ModifierArg>) {\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods?.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg<never>)\n\n        rectUtils.addEdges(this.interaction.edges, arg.rect, {\n          x: arg.coords.x - lastModifierCoords.x,\n          y: arg.coords.y - lastModifierCoords.y,\n        })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged =\n        newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed =\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: EventPhase, rect?: Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [\n      [startCoords, startDelta],\n      [curCoords, curDelta],\n    ] as const) {\n      coordsSet.page.x += delta.x\n      coordsSet.page.y += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left += rectDelta.left\n    rect.right += rectDelta.right\n    rect.top += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (\n    arg: Partial<DoAnyPhaseArg> & {\n      phase: EventPhase\n      preEnd?: boolean\n      skipModifiers?: number\n      modifiedCoords?: Point\n    },\n  ): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll(\n      this.fillArg({\n        preEnd,\n        phase,\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n      }),\n    )\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (\n      !result.changed &&\n      (!skipModifiers || skipModifiers < this.states.length) &&\n      interaction.interacting()\n    ) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit<DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd((arg as unknown) as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend(\n      {\n        states: this.states,\n        interactable: interaction.interactable,\n        element: interaction.element,\n        rect: null,\n      },\n      arg,\n    )\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) {\n        state.methods.stop(modifierArg as ModifierArg)\n      }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\n    if (!modification.result) return\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      !options ||\n      options.enabled === false ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.edges = other.edges\n    this.states = other.states.map((s) => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Point, rect?: FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map((type) => {\n      const options = actionOptions[type]\n\n      return (\n        options &&\n        options.enabled && {\n          options,\n          methods: options._methods,\n        }\n      )\n    })\n    .filter((m) => !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left: coords.x - rect.left,\n      top: coords.y - rect.top,\n      right: rect.right - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    }\n}\n", "import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\n\nimport Modification from './Modification'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modification?: Modification\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    modifiers?: Array<{\n      name: string\n      [key: string]: any\n    }>\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    modifiers?: Modifier[]\n  }\n}\n\nexport interface Modifier<\n  Defaults = any,\n  State extends ModifierState = any,\n  Name extends string = any,\n  Result = any\n> {\n  options: Defaults\n  methods: {\n    start?: (arg: ModifierArg<State>) => void\n    set?: (arg: ModifierArg<State>) => Result\n    beforeEnd?: (arg: ModifierArg<State>) => Point | void\n    stop?: (arg: ModifierArg<State>) => void\n  }\n  name?: Name\n  enable: () => Modifier<Defaults, State, Name, Result>\n  disable: () => Modifier<Defaults, State, Name, Result>\n}\n\nexport type ModifierState<Defaults = unknown, StateProps = unknown, Name extends string = any> = {\n  options: Defaults\n  methods?: Modifier<Defaults>['methods']\n  index?: number\n  name?: Name\n} & StateProps\n\nexport interface ModifierArg<State extends ModifierState = ModifierState> {\n  interaction: Interaction\n  interactable: Interactable\n  phase: EventPhase\n  rect: FullRect\n  edges: EdgeOptions\n  state: State\n  element: Element\n  pageCoords: Point\n  prevCoords: Point\n  prevRect?: FullRect\n  coords: Point\n  startOffset: Rect\n  preEnd?: boolean\n}\n\nexport interface ModifierModule<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Result = unknown\n> {\n  defaults?: Defaults\n  start?(arg: ModifierArg<State>): void\n  set?(arg: ModifierArg<State>): Result\n  beforeEnd?(arg: ModifierArg<State>): Point | void\n  stop?(arg: ModifierArg<State>): void\n}\n\nexport interface ModifierFunction<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string\n> {\n  (_options?: Partial<Defaults>): Modifier<Defaults, State, Name>\n  _defaults: Defaults\n  _methods: ModifierModule<Defaults, State>\n}\n\nexport function makeModifier<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string,\n  Result\n> (module: ModifierModule<Defaults, State, Result>, name?: Name) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (_options?: Partial<Defaults>) => {\n    const options = (_options || {}) as Defaults\n\n    options.enabled = options.enabled !== false\n\n    // add missing defaults to options\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        ;(options as any)[prop] = defaults[prop]\n      }\n    }\n\n    const m: Modifier<Defaults, State, Name, Result> = {\n      options,\n      methods,\n      name,\n      enable: () => {\n        options.enabled = true\n        return m\n      },\n      disable: () => {\n        options.enabled = false\n        return m\n      },\n    }\n\n    return m\n  }\n\n  if (name && typeof name === 'string') {\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport function addEventModifiers ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any>\n  interaction: Interaction<any>\n}) {\n  const result = interaction.modification!.result\n\n  if (result) {\n    iEvent.modifiers = result.eventProps\n  }\n}\n\nconst modifiersBase: Plugin = {\n  id: 'modifiers/base',\n  before: ['actions'],\n  install: (scope) => {\n    scope.defaults.perAction.modifiers = []\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.modification = new Modification(interaction)\n    },\n\n    'interactions:before-action-start': (arg) => {\n      const modification = arg.interaction.modification!\n\n      modification.start(arg, arg.interaction.coords.start.page)\n      arg.interaction.edges = modification.edges\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-move': (arg) => arg.interaction.modification.setAndApply(arg),\n\n    'interactions:before-action-end': (arg) => arg.interaction.modification.beforeEnd(arg),\n\n    'interactions:action-start': addEventModifiers,\n    'interactions:action-move': addEventModifiers,\n    'interactions:action-end': addEventModifiers,\n\n    'interactions:after-action-start': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-move': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n\n    'interactions:stop': (arg) => arg.interaction.modification.stop(arg),\n  },\n}\n\nexport default modifiersBase\n", "import type { Point, Listeners, OrBoolean, Element } from '@interactjs/types/index'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial<BaseDefaults> &\nPartial<PerActionDefaults> &\n{\n  [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n}\n\n// export interface Options extends BaseDefaults, PerActionDefaults {}\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n", "import type { ActionName } from '@interactjs/core/scope'\nimport type { Point, FullRect, PointerEventType, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './options'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase\n> extends BaseEvent<T> {\n  target: Element\n  currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  timeStamp: any\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction<T>,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle < 45 + overlap)\n    const down = !up && 45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get () {\n      return this.page.x\n    },\n    set (value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get () {\n      return this.page.y\n    },\n    set (value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get () {\n      return this.client.x\n    },\n    set (value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get () {\n      return this.client.y\n    },\n    set (value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get () {\n      return this.delta.x\n    },\n    set (value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get () {\n      return this.delta.y\n    },\n    set (value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get () {\n      return this.velocity.x\n    },\n    set (value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get () {\n      return this.velocity.y\n    },\n    set (value) {\n      this.velocity.y = value\n    },\n  },\n})\n", "import type { PointerEventType, PointerType } from '@interactjs/types/index'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n", "import type { ActionDefaults } from '@interactjs/core/options'\nimport type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionName, Scope } from './scope'\n\nexport interface ActionProps<T extends ActionName | null = never> {\n  name: T\n  axis?: 'x' | 'y' | 'xy' | null\n  edges?: EdgeOptions | null\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Element = null\n  rect: FullRect\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: (this as unknown) as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: (this as unknown) as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: (this as unknown) as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: PointerType) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n", "import type Interaction from '@interactjs/core/Interaction'\nimport { _ProxyMethods } from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { Point } from '@interactjs/types/index'\nimport * as rectUtils from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    offsetBy?: typeof offsetBy\n    offset: {\n      total: Point\n      pending: Point\n    }\n  }\n\n  enum _ProxyMethods {\n    offsetBy = '',\n  }\n}\n\n;(_ProxyMethods as any).offsetBy = ''\n\nexport function addTotal (interaction: Interaction) {\n  if (!interaction.pointerIsDown) {\n    return\n  }\n\n  addToCoords(interaction.coords.cur, interaction.offset.total)\n\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nfunction beforeAction ({ interaction }: { interaction: Interaction }) {\n  applyPending(interaction)\n}\n\nfunction beforeEnd ({ interaction }: { interaction: Interaction }): boolean | void {\n  const hadPending = applyPending(interaction)\n\n  if (!hadPending) return\n\n  interaction.move({ offset: true })\n  interaction.end()\n\n  return false\n}\n\nfunction end ({ interaction }: { interaction: Interaction }) {\n  interaction.offset.total.x = 0\n  interaction.offset.total.y = 0\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nexport function applyPending (interaction: Interaction) {\n  if (!hasPending(interaction)) {\n    return false\n  }\n\n  const { pending } = interaction.offset\n\n  addToCoords(interaction.coords.cur, pending)\n  addToCoords(interaction.coords.delta, pending)\n  rectUtils.addEdges(interaction.edges, interaction.rect, pending)\n\n  pending.x = 0\n  pending.y = 0\n\n  return true\n}\n\nfunction offsetBy (this: Interaction, { x, y }: Point) {\n  this.offset.pending.x += x\n  this.offset.pending.y += y\n\n  this.offset.total.x += x\n  this.offset.total.y += y\n}\n\nfunction addToCoords ({ page, client }, { x, y }: Point) {\n  page.x += x\n  page.y += y\n  client.x += x\n  client.y += y\n}\n\nfunction hasPending (interaction: Interaction) {\n  return !!(interaction.offset.pending.x || interaction.offset.pending.y)\n}\n\nconst offset: Plugin = {\n  id: 'offset',\n  before: ['modifiers', 'pointer-events', 'actions', 'inertia'],\n  install (scope) {\n    scope.Interaction.prototype.offsetBy = offsetBy\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.offset = {\n        total: { x: 0, y: 0 },\n        pending: { x: 0, y: 0 },\n      }\n    },\n    'interactions:update-pointer': ({ interaction }) => addTotal(interaction),\n    'interactions:before-action-start': beforeAction,\n    'interactions:before-action-move': beforeAction,\n    'interactions:before-action-end': beforeEnd,\n    'interactions:stop': end,\n  },\n}\n\nexport default offset\n", "import type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport Modification from '@interactjs/modifiers/Modification'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport offset from '@interactjs/offset/plugin'\nimport type { Point, PointerEventType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number // the lambda in exponential decay\n      minSpeed?: number // target speed must be above this for inertia to start\n      endSpeed?: number // the speed at which inertia is slow enough to stop\n      allowResume?: true // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit<DoPhaseArg<ActionName, 'inertiastart'>, 'iEvent'>\n    'interactions:action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:after-action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:before-action-resume': Omit<DoPhaseArg<ActionName, 'resume'>, 'iEvent'>\n    'interactions:action-resume': DoPhaseArg<ActionName, 'resume'>\n    'interactions:after-action-resume': DoPhaseArg<ActionName, 'resume'>\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled: false,\n    resistance: 10, // the lambda in exponential decay\n    minSpeed: 100, // target speed must be above this for inertia to start\n    endSpeed: 10, // the speed at which inertia is slow enough to stop\n    allowResume: true, // allow resuming an action in inertia phase\n    smoothEndDuration: 300, // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification!: Modification\n  modifierCount = 0\n  modifierArg!: modifiers.ModifierArg\n\n  startCoords!: Point\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset!: Point\n  modifiedOffset!: Point\n  currentOffset!: Point\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout!: number\n  readonly interaction: Interaction\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n  }\n\n  start (event: PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = modification.fillArg({\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    })\n\n    const thrown =\n      this.t0 - interaction.coords.cur.timeStamp < 50 &&\n      pointerSpeed > options.minSpeed &&\n      pointerSpeed > options.endSpeed\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia () {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() => this.inertiaTick())\n  }\n\n  startSmoothEnd () {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() => this.smoothEndTick())\n  }\n\n  onNextFrame (tickFn: () => void) {\n    this.timeout = raf.request(() => {\n      if (this.active) {\n        tickFn()\n      }\n    })\n  }\n\n  inertiaTick () {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t < this.te) {\n      const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0,\n          0,\n          this.targetOffset.x,\n          this.targetOffset.y,\n          this.modifiedOffset.x,\n          this.modifiedOffset.y,\n          progress,\n        )\n      } else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() => this.inertiaTick())\n    } else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick () {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t < duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() => this.smoothEndTick())\n    } else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume ({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end () {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop () {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start ({ interaction, event }: DoPhaseArg<ActionName, 'end'>) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume (arg: SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) return\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop ({ interaction }: { interaction: Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions ({ interactable, prepared }: Interaction) {\n  return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia\n}\n\nconst inertia: Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': (arg) => {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': (arg) => arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': (arg) =>\n      arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint (\n  startX: number,\n  startY: number,\n  cpX: number,\n  cpY: number,\n  endX: number,\n  endY: number,\n  position: number,\n) {\n  return {\n    x: _getQBezierValue(position, startX, cpX, endX),\n    y: _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n", "import type { Listener, ListenersArg, Rect } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire<T extends { type: string, propagationStopped?: boolean }> (event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Element): Rect {\n    return null\n  }\n}\n", "import type { Actions } from '@interactjs/core/scope'\n\nexport default function isNonNativeEvent (type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n", "/** @module interact */\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, Listener, ListenersArg, Target, Element } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Interactable } from './Interactable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { Options } from './options'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    (target: Target, options?: Options): Interactable\n    getPointerAverage: typeof pointerUtils.pointerAverage\n    getTouchBBox: typeof pointerUtils.touchBBox\n    getTouchDistance: typeof pointerUtils.touchDistance\n    getTouchAngle: typeof pointerUtils.touchAngle\n    getElementRect: typeof domUtils.getElementRect\n    getElementClientRect: typeof domUtils.getElementClientRect\n    matchesSelector: typeof domUtils.matchesSelector\n    closest: typeof domUtils.closest\n    /** @internal */ globalEvents: any\n    version: string\n    /** @internal */ scope: Scope\n    use(\n      plugin: Plugin,\n      options?: {\n        [key: string]: any\n      },\n    ): any\n    isSet(target: Element, options?: any): boolean\n    on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n    off(type: EventTypes, listener: any, options?: object): any\n    debug(): any\n    supportsTouch(): boolean\n    supportsPointerEvent(): boolean\n    stop(): any\n    pointerMoveTolerance(newValue?: number): any\n    addDocument(doc: Document, options?: object): void\n    removeDocument(doc: Document): void\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype _InteractStatic = import('@interactjs/core/InteractStatic').InteractStatic\n\nexport function createInteractStatic (scope: Scope): _InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target: Target, options: Options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as _InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n   * Use a plugin\n   *\n   * @alias module:interact.use\n   *\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Target} target The Element or string being searched for\n   * @param {object} options\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * @deprecated\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  /**\n   * @deprecated\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact\n}\n", "/* eslint-disable no-dupe-class-members */\nimport type { ActionMap, ActionName, Actions, Scope } from '@interactjs/core/scope'\nimport type {\n  Context,\n  Element,\n  Target,\n  Listeners,\n  OrBoolean,\n  EventTypes,\n  ListenersArg,\n  ActionMethod,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults } from './options'\nimport { Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Target\n  readonly events = new Eventable()\n  readonly _context: Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker (checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = (element) => {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }> (iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/options'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target, Context } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Context\n  interactable: Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Scope\n\n  constructor (scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, (m) => m.context === context)\n        if (targetMappings[targetIndex]) {\n          // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Target, options?: Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) {\n      return null\n    }\n\n    const found = arr.find(\n      targetMappings,\n      (m) => m.context === context && (isSelector || m.interactable.inContext(target as any)),\n    )\n\n    return found && found.interactable\n  }\n\n  forEachMatch<T> (node: Node, callback: (interactable: Interactable) => T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n          is.element(node) && domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n          node === interactable.target) &&\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n", "import type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture () {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive () {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (\n    eventTarget: EventTarget,\n    type: string,\n    listener?: 'all' | Listener,\n    optionalArg?: boolean | any,\n  ) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      } else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n", "import type { Scope, ActionName, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Listener } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string, listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class <T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName> (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'> (\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n", "import type Interaction from '@interactjs/core/Interaction'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport type { PhaseMap } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport { createInteractStatic } from './InteractStatic'\nimport type { Interactable } from './Interactable'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport events from './events'\nimport interactions from './interactions'\nimport type { OptionsArg } from './options'\nimport { defaults } from './options'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record<string, any>\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionMap {}\nexport type ActionName = keyof ActionMap\n\nexport interface Actions {\n  map: ActionMap\n  phases: PhaseMap\n  methodDict: { [P in ActionName]?: keyof Interactable }\n  phaselessTypes: { [type: string]: true }\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {},\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n    list: [],\n    map: {},\n  }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () {\n        return scope.defaults\n      }\n\n      set<T extends InteractableBase> (this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1)\n\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName> (name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init (window: Window | typeof globalThis) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window | typeof globalThis) {\n  scope.isInitialized = true\n\n  if (is.window(window)) {\n    win.init(window)\n  }\n\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  // @ts-expect-error\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n", "import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this\nscope.init(_global)\n", "export default () => {}\n", "export default () => {}\n", "import type { SnapFunction, SnapTarget } from '@interactjs/modifiers/snap/pointer'\nimport type { Rect, Point } from '@interactjs/types/index'\n\nexport type GridOptions = (Partial<Rect> | Point) & {\n  range?: number\n  limits?: Rect\n  offset?: Point\n}\n\nexport default (grid: GridOptions) => {\n  const coordFields = ([\n    ['x', 'y'],\n    ['left', 'top'],\n    ['right', 'bottom'],\n    ['width', 'height'],\n  ] as const).filter(([xField, yField]) => xField in grid || yField in grid)\n\n  const gridFunc: SnapFunction & {\n    grid: typeof grid\n    coordFields: typeof coordFields\n  } = (x, y) => {\n    const {\n      range,\n      limits = {\n        left: -Infinity,\n        right: Infinity,\n        top: -Infinity,\n        bottom: Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result: SnapTarget & {\n      grid: typeof grid\n    } = { range, grid, x: null as number, y: null as number }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\n    }\n\n    return result\n  }\n\n  gridFunc.grid = grid\n  gridFunc.coordFields = coordFields\n\n  return gridFunc\n}\n", "import type { Plugin } from '@interactjs/core/scope'\nimport extend from '@interactjs/utils/extend'\n\nimport * as allSnappers from './all'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    snappers: typeof allSnappers\n    createSnapGrid: typeof allSnappers.grid\n  }\n}\n\nconst snappersPlugin: Plugin = {\n  id: 'snappers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\n    interact.createSnapGrid = interact.snappers.grid\n  },\n}\n\nexport default snappersPlugin\n", "/**\n * @module modifiers/aspectRatio\n *\n * @description\n * This module forces elements to be resized with a specified dx/dy ratio.\n *\n * ```js\n * interact(target).resizable({\n *   modifiers: [\n *     interact.modifiers.snapSize({\n *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],\n *     }),\n *     interact.aspectRatio({ ratio: 'preserve' }),\n *   ],\n * });\n * ```\n */\n\nimport type { Point, Rect, EdgeOptions } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport { addEdges } from '@interactjs/utils/rect'\n\nimport Modification from './Modification'\nimport type { Modifier, ModifierModule, ModifierState } from './base'\nimport { makeModifier } from './base'\n\nexport interface AspectRatioOptions {\n  ratio?: number | 'preserve'\n  equalDelta?: boolean\n  modifiers?: Modifier[]\n  enabled?: boolean\n}\n\nexport type AspectRatioState = ModifierState<\nAspectRatioOptions,\n{\n  startCoords: Point\n  startRect: Rect\n  linkedEdges: EdgeOptions\n  ratio: number\n  equalDelta: boolean\n  xIsPrimaryAxis: boolean\n  edgeSign: 1 | -1\n  subModification: Modification\n}\n>\n\nconst aspectRatio: ModifierModule<AspectRatioOptions, AspectRatioState> = {\n  start (arg) {\n    const { state, rect, edges: originalEdges, pageCoords: coords } = arg\n    let { ratio } = state.options\n    const { equalDelta, modifiers } = state.options\n\n    if (ratio === 'preserve') {\n      ratio = rect.width / rect.height\n    }\n\n    state.startCoords = extend({}, coords)\n    state.startRect = extend({}, rect)\n    state.ratio = ratio\n    state.equalDelta = equalDelta\n\n    const linkedEdges = (state.linkedEdges = {\n      top: originalEdges.top || (originalEdges.left && !originalEdges.bottom),\n      left: originalEdges.left || (originalEdges.top && !originalEdges.right),\n      bottom: originalEdges.bottom || (originalEdges.right && !originalEdges.top),\n      right: originalEdges.right || (originalEdges.bottom && !originalEdges.left),\n    })\n\n    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right)\n\n    if (state.equalDelta) {\n      state.edgeSign = ((linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1)) as 1 | -1\n    } else {\n      const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left\n      state.edgeSign = negativeSecondaryEdge ? -1 : 1\n    }\n\n    extend(arg.edges, linkedEdges)\n\n    if (!modifiers || !modifiers.length) return\n\n    const subModification = new Modification(arg.interaction)\n\n    subModification.copyFrom(arg.interaction.modification)\n    subModification.prepareStates(modifiers)\n\n    state.subModification = subModification\n    subModification.startAll({ ...arg })\n  },\n\n  set (arg) {\n    const { state, rect, coords } = arg\n    const initialCoords = extend({}, coords)\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\n\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\n\n    if (!state.subModification) {\n      return null\n    }\n\n    const correctedRect = extend({}, rect)\n\n    addEdges(state.linkedEdges, correctedRect, {\n      x: coords.x - initialCoords.x,\n      y: coords.y - initialCoords.y,\n    })\n\n    const result = state.subModification.setAll({\n      ...arg,\n      rect: correctedRect,\n      edges: state.linkedEdges,\n      pageCoords: coords,\n      prevCoords: coords,\n      prevRect: correctedRect,\n    })\n\n    const { delta } = result\n\n    if (result.changed) {\n      const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y)\n\n      // do aspect modification again with critical edge axis as primary\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\n      extend(coords, result.coords)\n    }\n\n    return result.eventProps\n  },\n\n  defaults: {\n    ratio: 'preserve',\n    equalDelta: false,\n    modifiers: [],\n    enabled: false,\n  },\n}\n\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Point) {\n  if (xIsPrimaryAxis) {\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign\n  } else {\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign\n  }\n}\n\nfunction setRatio (\n  { startRect, startCoords, ratio, edgeSign }: AspectRatioState,\n  xIsPrimaryAxis: boolean,\n  coords: Point,\n  rect: Rect,\n) {\n  if (xIsPrimaryAxis) {\n    const newHeight = rect.width / ratio\n\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign\n  } else {\n    const newWidth = rect.height * ratio\n\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign\n  }\n}\n\nexport default makeModifier(aspectRatio, 'aspectRatio')\nexport { aspectRatio }\n", "import type { ModifierFunction } from '@interactjs/modifiers/base'\n\nconst noop = ((() => {}) as unknown) as ModifierFunction<any, any, 'noop'>\n\nnoop._defaults = {}\n\nexport default noop\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { RectResolvable, Rect, Point } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierModule, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nexport interface RestrictOptions {\n  // where to drag over\n  restriction: RectResolvable<[number, number, Interaction]>\n  // what part of self is allowed to drag over\n  elementRect: Rect\n  offset: Rect\n  // restrict just before the end drag\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictState = ModifierState<\nRestrictOptions,\n{\n  offset: Rect\n}\n>\n\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg<RestrictState>) {\n  const { options } = state\n  const { elementRect } = options\n  const offset: Rect = extend(\n    {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    },\n    options.offset || {},\n  )\n\n  if (rect && elementRect) {\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\n\n    if (restriction) {\n      const widthDiff = restriction.right - restriction.left - rect.width\n      const heightDiff = restriction.bottom - restriction.top - rect.height\n\n      if (widthDiff < 0) {\n        offset.left += widthDiff\n        offset.right += widthDiff\n      }\n      if (heightDiff < 0) {\n        offset.top += heightDiff\n        offset.bottom += heightDiff\n      }\n    }\n\n    offset.left += startOffset.left - rect.width * elementRect.left\n    offset.top += startOffset.top - rect.height * elementRect.top\n\n    offset.right += startOffset.right - rect.width * (1 - elementRect.right)\n    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom)\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }: ModifierArg<RestrictState>) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) return\n\n  const rect = rectUtils.xywhToTlbr(restriction)\n\n  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left)\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top)\n}\n\nexport function getRestrictionRect (\n  value: RectResolvable<[number, number, Interaction]>,\n  interaction: Interaction,\n  coords?: Point,\n) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [\n      coords.x,\n      coords.y,\n      interaction,\n    ])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\n  }\n}\n\nconst defaults: RestrictOptions = {\n  restriction: null,\n  elementRect: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrict: ModifierModule<RestrictOptions, RestrictState> = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrict, 'restrict')\nexport { restrict }\n", "// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// })\n\nimport type { Point, Rect } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nexport interface RestrictEdgesOptions {\n  inner: RestrictOptions['restriction']\n  outer: RestrictOptions['restriction']\n  offset?: RestrictOptions['offset']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictEdgesState = ModifierState<\nRestrictEdgesOptions,\n{\n  inner: Rect\n  outer: Rect\n  offset: RestrictEdgesOptions['offset']\n}\n>\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, startOffset, state }: ModifierArg<RestrictEdgesState>) {\n  const { options } = state\n  let offset: Point\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top: offset.y + startOffset.top,\n    left: offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right: offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, edges, interaction, state }: ModifierArg<RestrictEdgesState>) {\n  const { offset, options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || ({} as Rect)\n  const outer = getRestrictionRect(options.outer, interaction, page) || ({} as Rect)\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top)\n  } else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left)\n  } else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right)\n  }\n}\n\nfunction fixRect (rect: Rect, defaults: Rect) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst defaults: RestrictEdgesOptions = {\n  inner: null,\n  outer: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictEdges, 'restrictEdges')\nexport { restrictEdges }\n", "import extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\n\nimport { restrict } from './pointer'\n\nconst defaults = extend(\n  {\n    get elementRect () {\n      return { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    set elementRect (_) {},\n  },\n  restrict.defaults,\n)\n\nconst restrictRect = {\n  start: restrict.start,\n  set: restrict.set,\n  defaults,\n}\n\nexport default makeModifier(restrictRect, 'restrictRect')\nexport { restrictRect }\n", "import type { Point, Rect, Size } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { RestrictEdgesState } from './edges'\nimport { restrictEdges } from './edges'\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nexport interface RestrictSizeOptions {\n  min?: Size | Point | RestrictOptions['restriction']\n  max?: Size | Point | RestrictOptions['restriction']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nfunction start (arg: ModifierArg<RestrictEdgesState>) {\n  return restrictEdges.start(arg)\n}\n\nexport type RestrictSizeState = RestrictEdgesState &\nModifierState<\nRestrictSizeOptions & { inner: Rect, outer: Rect },\n{\n  min: Rect\n  max: Rect\n}\n>\n\nfunction set (arg: ModifierArg<RestrictSizeState>) {\n  const { interaction, state, rect, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const minSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\n  const maxSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\n\n  state.options = {\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  } else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  } else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst defaults: RestrictSizeOptions = {\n  min: null,\n  max: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictSize, 'restrictSize')\nexport { restrictSize }\n", "import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { Point, RectResolvable, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[] | null\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Point[] | null\n  // startCoords = offset snapping from drag start page position\n  offset: Point | RectResolvable<[Interaction]> | 'startCoords' | null\n  offsetWithOrigin?: boolean\n  origin: RectResolvable<[Element]> | Point | null\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\nSnapOptions,\n{\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}\n>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n        index,\n        relativePoint,\n        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n      }))\n      : [\n        {\n          index: 0,\n          relativePoint: null,\n          x: snapOffset.x,\n          y: snapOffset.y,\n        },\n      ]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n        closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n          distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n          (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n        !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n", "// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport type { ModifierArg } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snap } from './pointer'\n\nexport type SnapSizeOptions = Pick<SnapOptions, 'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { state, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state = {\n    options: {\n      targets: null,\n      relativePoints: [\n        {\n          x: edges.left ? 0 : 1,\n          y: edges.top ? 0 : 1,\n        },\n      ],\n      offset: options.offset || 'self',\n      origin: { x: 0, y: 0 },\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of options.targets || []) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    } else {\n      target = snapTarget\n    }\n\n    if (!target) {\n      continue\n    }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  const returnValue = snap.set(arg)\n\n  state.options = options\n\n  return returnValue\n}\n\nconst defaults: SnapSizeOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snapSize, 'snapSize')\nexport { snapSize }\n", "/**\n * @module modifiers/snapEdges\n *\n * @description\n * WOW> This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * ```js\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * })\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * })\n * ```\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\n\nimport type { ModifierArg, ModifierModule } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snapSize } from './size'\n\nexport type SnapEdgesOptions = Pick<SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { edges } = arg\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nconst snapEdges: ModifierModule<SnapEdgesOptions, SnapState, ReturnType<typeof snapSize.set>> = {\n  start,\n  set: snapSize.set,\n  defaults: extend(clone(snapSize.defaults), {\n    targets: null,\n    range: null,\n    offset: { x: 0, y: 0 },\n  } as const),\n}\n\nexport default makeModifier(snapEdges, 'snapEdges')\nexport { snapEdges }\n", "/* eslint-disable node/no-extraneous-import, import/no-unresolved */\nimport aspectRatio from './aspectRatio'\nimport avoid from './avoid/avoid'\nimport restrictEdges from './restrict/edges'\nimport restrict from './restrict/pointer'\nimport restrictRect from './restrict/rect'\nimport restrictSize from './restrict/size'\nimport rubberband from './rubberband/rubberband'\nimport snapEdges from './snap/edges'\nimport snap from './snap/pointer'\nimport snapSize from './snap/size'\nimport spring from './spring/spring'\nimport transform from './transform/transform'\n\nexport default {\n  aspectRatio,\n  restrictEdges,\n  restrict,\n  restrictRect,\n  restrictSize,\n  snapEdges,\n  snap,\n  snapSize,\n\n  spring,\n  avoid,\n  transform,\n  rubberband,\n}\n", "import type { Plugin } from '@interactjs/core/scope'\nimport snappers from '@interactjs/snappers/plugin'\n\nimport all from './all'\nimport base from './base'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    modifiers: typeof all\n  }\n}\n\nconst modifiers: Plugin = {\n  id: 'modifiers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    scope.usePlugin(base)\n    scope.usePlugin(snappers)\n\n    interact.modifiers = all\n\n    // for backwrads compatibility\n    for (const type in all) {\n      const { _defaults, _methods } = all[type as keyof typeof all]\n\n      ;(_defaults as any)._methods = _methods\n      ;(scope.defaults.perAction as any)[type] = _defaults\n    }\n  },\n}\n\nexport default modifiers\n", "import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { PointerEventType, PointerType, Point } from '@interactjs/types/index'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport default class PointerEvent<T extends string = any> extends BaseEvent<never> {\n  type: T\n  originalEvent: PointerEventType\n  pointerId: number\n  pointerType: string\n  double: boolean\n  pageX: number\n  pageY: number\n  clientX: number\n  clientY: number\n  dt: number\n  eventable: any;\n  [key: string]: any\n\n  /** */\n  constructor (\n    type: T,\n    pointer: PointerType | PointerEvent<any>,\n    event: PointerEventType,\n    eventTarget: Node,\n    interaction: Interaction<never>,\n    timeStamp: number,\n  ) {\n    super(interaction)\n    pointerUtils.pointerExtend(this, event)\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer)\n    }\n\n    this.timeStamp = timeStamp\n    this.originalEvent = event\n    this.type = type\n    this.pointerId = pointerUtils.getPointerId(pointer)\n    this.pointerType = pointerUtils.getPointerType(pointer)\n    this.target = eventTarget\n    this.currentTarget = null\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer)\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\n\n      const interval = this.timeStamp - interaction.tapTime\n\n      this.double = !!(\n        interaction.prevTap &&\n        interaction.prevTap.type !== 'doubletap' &&\n        interaction.prevTap.target === this.target &&\n        interval < 500\n      )\n    } else if (type === 'doubletap') {\n      this.dt = (pointer as PointerEvent<'tap'>).timeStamp - interaction.tapTime\n    }\n  }\n\n  _subtractOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX -= originX\n    this.pageY -= originY\n    this.clientX -= originX\n    this.clientY -= originY\n\n    return this\n  }\n\n  _addOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX += originX\n    this.pageY += originY\n    this.clientX += originX\n    this.clientY += originY\n\n    return this\n  }\n\n  /**\n   * Prevent the default behaviour of the original Event\n   */\n  preventDefault () {\n    this.originalEvent.preventDefault()\n  }\n}\n\nexport { PointerEvent }\n", "import type { Eventable } from '@interactjs/core/Eventable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Point | string | Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    pointerEvents: Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction<null>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction<any>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 },\n}\n\nconst pointerEvents: Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string> (\n  arg: {\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    interaction: Interaction<never>\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Scope,\n) {\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      ;(pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (\n      pointerEvent.immediatePropagationStopped ||\n      (pointerEvent.propagationStopped &&\n        i + 1 < targets.length &&\n        targets[i + 1].node !== pointerEvent.currentTarget)\n    ) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire(\n        {\n          interaction,\n          pointer,\n          event,\n          eventTarget,\n          type: 'doubletap',\n        },\n        scope,\n      )\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string> (\n  {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n  }: {\n    interaction: Interaction<any>\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    type: T\n  },\n  scope: Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (\n    type === 'tap' &&\n    (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))\n  ) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(\n      (target) => target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold.duration,\n    )\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps ({ interaction }) {\n  interaction.prevTap = null // the most recent tap event on this interaction\n  interaction.tapTime = 0 // time of the most recent tap event\n}\n\nfunction addHoldInfo ({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold ({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold && hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire(\n      {\n        interaction,\n        pointer,\n        event,\n        eventTarget: eventTarget as Element,\n        type: 'move',\n      },\n      scope,\n    )\n  }\n}\n\nfunction downAndStartHold (\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  const timer = interaction.pointers[pointerIndex].hold\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) return\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire(\n      {\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      },\n      scope,\n    )\n  }, minDuration)\n}\n\nfunction tapAfterUp (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\n  scope: Scope,\n) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { ListenerMap, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\n\nimport type PointerEvent from './PointerEvent'\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    holdIntervalHandle?: any\n  }\n}\n\ndeclare module '@interactjs/pointer-events/PointerEvent' {\n  interface PointerEvent<T extends string = any> {\n    count?: number\n  }\n}\n\ndeclare module '@interactjs/pointer-events/base' {\n  interface PointerEventOptions {\n    holdRepeatInterval?: number\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.usePlugin(basePlugin)\n\n  const { pointerEvents } = scope\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\n}\n\nfunction onNew ({ pointerEvent }: { pointerEvent: PointerEvent<any> }) {\n  if (pointerEvent.type !== 'hold') return\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired (\n  { interaction, pointerEvent, eventTarget, targets }: SignalArgs['pointerEvents:fired'],\n  scope: Scope,\n) {\n  if (pointerEvent.type !== 'hold' || !targets.length) return\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) return\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() => {\n    scope.pointerEvents.fire(\n      {\n        interaction,\n        eventTarget,\n        type: 'hold',\n        pointer: pointerEvent,\n        event: pointerEvent,\n      },\n      scope,\n    )\n  }, interval)\n}\n\nfunction endHoldRepeat ({ interaction }: { interaction: Interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nconst holdRepeat: Plugin = {\n  id: 'pointer-events/holdRepeat',\n  install,\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\n    (acc, enderTypes) => {\n      ;(acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\n      return acc\n    },\n    {\n      'pointerEvents:new': onNew,\n      'pointerEvents:fired': onFired,\n    } as ListenerMap,\n  ),\n}\n\nexport default holdRepeat\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    pointerEvents: typeof pointerEventsMethod\n    __backCompatOption: (optionName: string, newValue: any) => any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { Interactable } = scope\n\n  Interactable.prototype.pointerEvents = pointerEventsMethod\n\n  const __backCompatOption = Interactable.prototype._backCompatOption\n\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\n    const ret = __backCompatOption.call(this, optionName, newValue)\n\n    if (ret === this) {\n      this.events.options[optionName] = newValue\n    }\n\n    return ret\n  }\n}\n\nfunction pointerEventsMethod (this: Interactable, options: any) {\n  extend(this.events.options, options)\n\n  return this\n}\n\nconst plugin: Plugin = {\n  id: 'pointer-events/interactableTargets',\n  install,\n  listeners: {\n    'pointerEvents:collect-targets': ({ targets, node, type, eventTarget }, scope) => {\n      scope.interactables.forEachMatch(node, (interactable: Interactable) => {\n        const eventable = interactable.events\n        const options = eventable.options\n\n        if (\n          eventable.types[type] &&\n          eventable.types[type].length &&\n          interactable.testIgnoreAllow(options, node, eventTarget)\n        ) {\n          targets.push({\n            node,\n            eventable,\n            props: { interactable },\n          })\n        }\n      })\n    },\n\n    'interactable:new': ({ interactable }) => {\n      interactable.events.getRect = function (element: Element) {\n        return interactable.getRect(element)\n      }\n    },\n\n    'interactable:set': ({ interactable, options }, scope) => {\n      extend(interactable.events.options, scope.pointerEvents.defaults)\n      extend(interactable.events.options, options.pointerEvents || {})\n    },\n  },\n}\n\nexport default plugin\n", "import type { Plugin } from '@interactjs/core/scope'\n\nimport * as pointerEvents from './base'\nimport holdRepeat from './holdRepeat'\nimport interactableTargets from './interactableTargets'\n\nconst plugin: Plugin = {\n  id: 'pointer-events',\n  install (scope) {\n    scope.usePlugin(pointerEvents)\n    scope.usePlugin(holdRepeat)\n    scope.usePlugin(interactableTargets)\n  },\n}\n\nexport default plugin\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-reflow': DoAnyPhaseArg\n    'interactions:after-action-reflow': DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: <T extends ActionName>(action: ActionProps<T>) => ReturnType<typeof doReflow>\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise<void>\n    _reflowResolve: (...args: unknown[]) => void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable,\n  } = scope\n\n  scope.actions.phases.reflow = true\n\n  /**\n   * ```js\n   * const interactable = interact(target)\n   * const drag = { name: drag, axis: 'x' }\n   * const resize = { name: resize, edges: { left: true, bottom: true }\n   *\n   * interactable.reflow(drag)\n   * interactable.reflow(resize)\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n   */\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return doReflow(this, action, scope)\n  }\n}\n\nfunction doReflow<T extends ActionName> (\n  interactable: Interactable,\n  action: ActionProps<T>,\n  scope: Scope,\n): Promise<Interactable> {\n  const elements = (is.string(interactable.target)\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\n    : [interactable.target]) as Element[]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) {\n      break\n    }\n\n    const runningInteraction = arr.find(scope.interactions.list, (interaction: Interaction) => {\n      return (\n        interaction.interacting() &&\n        interaction.interactable === interactable &&\n        interaction.element === element &&\n        interaction.prepared.name === action.name\n      )\n    })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise =\n          runningInteraction._reflowPromise ||\n          new Promise((resolve: any) => {\n            runningInteraction._reflowResolve = resolve\n          })\n      }\n    } else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page: { x: xywh.x, y: xywh.y },\n        client: { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow<T>(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow<T extends ActionName> (\n  scope: Scope,\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  event: any,\n) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = (scope.window as unknown) as { Promise: PromiseConstructor }\n  const reflowPromise = Promise\n    ? new Promise<undefined>((resolve) => {\n      interaction._reflowResolve = resolve\n    })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  } else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nconst reflow: Plugin = {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) => {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n}\n\nexport default reflow\n", "import actions from '@interactjs/actions/plugin'\nimport autoScroll from '@interactjs/auto-scroll/plugin'\nimport autoStart from '@interactjs/auto-start/plugin'\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\nimport devTools from '@interactjs/dev-tools/plugin'\nimport inertia from '@interactjs/inertia/plugin'\nimport interact from '@interactjs/interact'\nimport modifiers from '@interactjs/modifiers/plugin'\nimport offset from '@interactjs/offset/plugin'\nimport pointerEvents from '@interactjs/pointer-events/plugin'\nimport reflow from '@interactjs/reflow/plugin'\n\ninteract.use(interactablePreventDefault)\n\ninteract.use(offset)\n\n// pointerEvents\ninteract.use(pointerEvents)\n\n// inertia\ninteract.use(inertia)\n\n// snap, resize, etc.\ninteract.use(modifiers)\n\n// autoStart, hold\ninteract.use(autoStart)\n\n// drag and drop, resize, gesture\ninteract.use(actions)\n\n// autoScroll\ninteract.use(autoScroll)\n\n// reflow\ninteract.use(reflow)\n\n// eslint-disable-next-line no-undef\nif (process.env.NODE_ENV !== 'production') {\n  interact.use(devTools)\n}\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n", "// eslint-disable-next-line import/no-extraneous-dependencies\nimport interact from '@interactjs/interactjs/index'\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n", "\nreturn _$index_79;\n\n});\n", "export default require(\"./node_modules/interactjs/dist/interact.min.js\");"],
  "mappings": "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",
  "names": []
}
