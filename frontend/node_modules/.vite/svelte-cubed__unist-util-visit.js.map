{
  "version": 3,
  "sources": ["../unist-util-is/index.js", "../unist-util-visit-parents/color.browser.js", "../unist-util-visit-parents/index.js", "../unist-util-visit/index.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n *\r\n * @typedef {string} Type\r\n * @typedef {Object<string, unknown>} Props\r\n *\r\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\r\n */\r\n\r\n/**\r\n * Check if a node passes a test\r\n *\r\n * @callback TestFunctionAnything\r\n * @param {Node} node\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {boolean|void}\r\n */\r\n\r\n/**\r\n * Check if a node passes a certain node test\r\n *\r\n * @template {Node} X\r\n * @callback TestFunctionPredicate\r\n * @param {Node} node\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {node is X}\r\n */\r\n\r\n/**\r\n * @callback AssertAnything\r\n * @param {unknown} [node]\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {boolean}\r\n */\r\n\r\n/**\r\n * Check if a node passes a certain node test\r\n *\r\n * @template {Node} Y\r\n * @callback AssertPredicate\r\n * @param {unknown} [node]\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {node is Y}\r\n */\r\n\r\nexport const is =\r\n  /**\r\n   * Check if a node passes a test.\r\n   * When a `parent` node is known the `index` of node should also be given.\r\n   *\r\n   * @type {(\r\n   *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\r\n   *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * Check if a node passes a test.\r\n     * When a `parent` node is known the `index` of node should also be given.\r\n     *\r\n     * @param {unknown} [node] Node to check\r\n     * @param {Test} [test]\r\n     * When nullish, checks if `node` is a `Node`.\r\n     * When `string`, works like passing `function (node) {return node.type === test}`.\r\n     * When `function` checks if function passed the node is true.\r\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n     * When `array`, checks any one of the subtests pass.\r\n     * @param {number|null|undefined} [index] Position of `node` in `parent`\r\n     * @param {Parent|null|undefined} [parent] Parent of `node`\r\n     * @param {unknown} [context] Context object to invoke `test` with\r\n     * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function is(node, test, index, parent, context) {\r\n      const check = convert(test)\r\n\r\n      if (\r\n        index !== undefined &&\r\n        index !== null &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite index')\r\n      }\r\n\r\n      if (\r\n        parent !== undefined &&\r\n        parent !== null &&\r\n        (!is(parent) || !parent.children)\r\n      ) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (\r\n        (parent === undefined || parent === null) !==\r\n        (index === undefined || index === null)\r\n      ) {\r\n        throw new Error('Expected both parent and index')\r\n      }\r\n\r\n      // @ts-expect-error Looks like a node.\r\n      return node && node.type && typeof node.type === 'string'\r\n        ? Boolean(check.call(context, node, index, parent))\r\n        : false\r\n    }\r\n  )\r\n\r\nexport const convert =\r\n  /**\r\n   * @type {(\r\n   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\r\n   *   ((test?: Test) => AssertAnything)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * Generate an assertion from a check.\r\n     * @param {Test} [test]\r\n     * When nullish, checks if `node` is a `Node`.\r\n     * When `string`, works like passing `function (node) {return node.type === test}`.\r\n     * When `function` checks if function passed the node is true.\r\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n     * When `array`, checks any one of the subtests pass.\r\n     * @returns {AssertAnything}\r\n     */\r\n    function (test) {\r\n      if (test === undefined || test === null) {\r\n        return ok\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return typeFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'object') {\r\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or object as test')\r\n    }\r\n  )\r\n/**\r\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\r\n * @returns {AssertAnything}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array.<AssertAnything>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convert(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param {unknown[]} parameters\r\n   * @returns {boolean}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].call(this, ...parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to assert each property in `test` is represented in `node`, and each\r\n * values are strictly equal.\r\n *\r\n * @param {Props} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction propsFactory(check) {\r\n  return castFactory(all)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   * @returns {boolean}\r\n   */\r\n  function all(node) {\r\n    /** @type {string} */\r\n    let key\r\n\r\n    for (key in check) {\r\n      // @ts-expect-error: hush, it sure works as an index.\r\n      if (node[key] !== check[key]) return false\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to convert a string into a function which checks a given node\u2019s type\r\n * for said string.\r\n *\r\n * @param {Type} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction typeFactory(check) {\r\n  return castFactory(type)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   */\r\n  function type(node) {\r\n    return node && node.type === check\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to convert a string into a function which checks a given node\u2019s type\r\n * for said string.\r\n * @param {TestFunctionAnything} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction castFactory(check) {\r\n  return assertion\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param {Array.<unknown>} parameters\r\n   * @returns {boolean}\r\n   */\r\n  function assertion(...parameters) {\r\n    // @ts-expect-error: spreading is fine.\r\n    return Boolean(check.call(this, ...parameters))\r\n  }\r\n}\r\n\r\n// Utility to return true.\r\nfunction ok() {\r\n  return true\r\n}\r\n", "/**\r\n * @param {string} d\r\n * @returns {string}\r\n */\r\nexport function color(d) {\r\n  return d\r\n}\r\n", "/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n * @typedef {import('unist-util-is').Test} Test\r\n * @typedef {import('./complex-types').Action} Action\r\n * @typedef {import('./complex-types').Index} Index\r\n * @typedef {import('./complex-types').ActionTuple} ActionTuple\r\n * @typedef {import('./complex-types').VisitorResult} VisitorResult\r\n * @typedef {import('./complex-types').Visitor} Visitor\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\nimport {color} from './color.js'\r\n\r\n/**\r\n * Continue traversing as normal\r\n */\r\nexport const CONTINUE = true\r\n/**\r\n * Do not traverse this node\u2019s children\r\n */\r\nexport const SKIP = 'skip'\r\n/**\r\n * Stop traversing immediately\r\n */\r\nexport const EXIT = false\r\n\r\n/**\r\n * Visit children of tree which pass a test\r\n *\r\n * @param tree Abstract syntax tree to walk\r\n * @param test Test node, optional\r\n * @param visitor Function to run for each node\r\n * @param reverse Visit the tree in reverse order, defaults to false\r\n */\r\nexport const visitParents =\r\n  /**\r\n   * @type {(\r\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\r\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Node} tree\r\n     * @param {Test} test\r\n     * @param {import('./complex-types').Visitor<Node>} visitor\r\n     * @param {boolean} [reverse]\r\n     */\r\n    function (tree, test, visitor, reverse) {\r\n      if (typeof test === 'function' && typeof visitor !== 'function') {\r\n        reverse = visitor\r\n        // @ts-expect-error no visitor given, so `visitor` is test.\r\n        visitor = test\r\n        test = null\r\n      }\r\n\r\n      const is = convert(test)\r\n      const step = reverse ? -1 : 1\r\n\r\n      factory(tree, null, [])()\r\n\r\n      /**\r\n       * @param {Node} node\r\n       * @param {number?} index\r\n       * @param {Array.<Parent>} parents\r\n       */\r\n      function factory(node, index, parents) {\r\n        /** @type {Object.<string, unknown>} */\r\n        // @ts-expect-error: hush\r\n        const value = typeof node === 'object' && node !== null ? node : {}\r\n        /** @type {string|undefined} */\r\n        let name\r\n\r\n        if (typeof value.type === 'string') {\r\n          name =\r\n            typeof value.tagName === 'string'\r\n              ? value.tagName\r\n              : typeof value.name === 'string'\r\n              ? value.name\r\n              : undefined\r\n\r\n          Object.defineProperty(visit, 'name', {\r\n            value:\r\n              'node (' +\r\n              color(value.type + (name ? '<' + name + '>' : '')) +\r\n              ')'\r\n          })\r\n        }\r\n\r\n        return visit\r\n\r\n        function visit() {\r\n          /** @type {ActionTuple} */\r\n          let result = []\r\n          /** @type {ActionTuple} */\r\n          let subresult\r\n          /** @type {number} */\r\n          let offset\r\n          /** @type {Array.<Parent>} */\r\n          let grandparents\r\n\r\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\r\n            result = toResult(visitor(node, parents))\r\n\r\n            if (result[0] === EXIT) {\r\n              return result\r\n            }\r\n          }\r\n\r\n          // @ts-expect-error looks like a parent.\r\n          if (node.children && result[0] !== SKIP) {\r\n            // @ts-expect-error looks like a parent.\r\n            offset = (reverse ? node.children.length : -1) + step\r\n            // @ts-expect-error looks like a parent.\r\n            grandparents = parents.concat(node)\r\n\r\n            // @ts-expect-error looks like a parent.\r\n            while (offset > -1 && offset < node.children.length) {\r\n              // @ts-expect-error looks like a parent.\r\n              subresult = factory(node.children[offset], offset, grandparents)()\r\n\r\n              if (subresult[0] === EXIT) {\r\n                return subresult\r\n              }\r\n\r\n              offset =\r\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\r\n            }\r\n          }\r\n\r\n          return result\r\n        }\r\n      }\r\n    }\r\n  )\r\n\r\n/**\r\n * @param {VisitorResult} value\r\n * @returns {ActionTuple}\r\n */\r\nfunction toResult(value) {\r\n  if (Array.isArray(value)) {\r\n    return value\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    return [CONTINUE, value]\r\n  }\r\n\r\n  return [value]\r\n}\r\n", "/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n * @typedef {import('unist-util-is').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n * @typedef {import('./complex-types').Visitor} Visitor\r\n */\r\n\r\nimport {visitParents, CONTINUE, SKIP, EXIT} from 'unist-util-visit-parents'\r\n\r\nexport {CONTINUE, SKIP, EXIT}\r\n\r\n/**\r\n * Visit children of tree which pass a test\r\n *\r\n * @param tree Abstract syntax tree to walk\r\n * @param test Test, optional\r\n * @param visitor Function to run for each node\r\n * @param reverse Fisit the tree in reverse, defaults to false\r\n */\r\nexport const visit =\r\n  /**\r\n   * @type {(\r\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\r\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Node} tree\r\n     * @param {Test} test\r\n     * @param {import('./complex-types').Visitor} visitor\r\n     * @param {boolean} [reverse]\r\n     */\r\n    function (tree, test, visitor, reverse) {\r\n      if (typeof test === 'function' && typeof visitor !== 'function') {\r\n        reverse = visitor\r\n        visitor = test\r\n        test = null\r\n      }\r\n\r\n      visitParents(tree, test, overload, reverse)\r\n\r\n      /**\r\n       * @param {Node} node\r\n       * @param {Array.<Parent>} parents\r\n       */\r\n      function overload(node, parents) {\r\n        const parent = parents[parents.length - 1]\r\n        return visitor(\r\n          node,\r\n          parent ? parent.children.indexOf(node) : null,\r\n          parent\r\n        )\r\n      }\r\n    }\r\n  )\r\n"],
  "mappings": "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",
  "names": []
}
