import {
  Ca,
  Ea,
  Eh,
  F,
  Fh,
  Gh,
  Gu,
  Hh,
  Ia,
  Jh,
  Kh,
  Lh,
  Mh,
  Nt,
  O,
  Pa,
  Ph,
  Qh,
  Ra,
  Rh,
  Sa,
  Ta,
  Th,
  Uh,
  Vh,
  Vt,
  Wh,
  Xu,
  Yh,
  Zu,
  _a,
  ah,
  el,
  fh,
  ga,
  gh,
  ha,
  hh,
  ia,
  il,
  j,
  jh,
  ma,
  mt,
  na,
  nl,
  oa,
  pa,
  ph,
  q,
  qh,
  ra,
  rl,
  sa,
  sl,
  tl,
  uh,
  ut,
  va,
  vh,
  wh,
  xh,
  yt,
  zh,
  zu
} from "./chunk-HV6TORL3.js";
import {
  OnDisconnect,
  QueryImpl,
  QueryParams,
  ReferenceImpl,
  child,
  connectDatabaseEmulator,
  enableLogging,
  endAt,
  endBefore,
  equalTo,
  get,
  goOffline,
  goOnline,
  increment,
  limitToFirst,
  limitToLast,
  off,
  onChildAdded,
  onChildChanged,
  onChildMoved,
  onChildRemoved,
  onValue,
  orderByChild,
  orderByKey,
  orderByPriority,
  orderByValue,
  push,
  query,
  ref,
  refFromURL,
  remove,
  repoManagerDatabaseFromApp,
  runTransaction,
  serverTimestamp,
  set,
  setPriority,
  setSDKVersion,
  setWithPriority,
  startAfter,
  startAt,
  update,
  validatePathString,
  validateWritablePath
} from "./chunk-JMRZUWXQ.js";
import {
  ActionCodeOperation,
  AuthCredential,
  AuthEventManager,
  EmailAuthProvider,
  FacebookAuthProvider,
  GithubAuthProvider,
  GoogleAuthProvider,
  OAuthCredential,
  OAuthProvider,
  PhoneAuthProvider,
  PhoneMultiFactorGenerator,
  ProviderId,
  RecaptchaVerifier,
  SAMLAuthCredential,
  SAMLAuthProvider,
  TwitterAuthProvider,
  _assert,
  _castAuth,
  _clearRedirectOutcomes,
  _createError,
  _fail,
  _generateEventId,
  _getInstance,
  _getProjectConfig,
  _getRedirectResult,
  _getRedirectUrl,
  _isAndroid,
  _isIOS,
  _isIOS7Or8,
  _persistenceKeyName,
  applyActionCode,
  browserLocalPersistence,
  browserPopupRedirectResolver,
  browserSessionPersistence,
  checkActionCode,
  confirmPasswordReset,
  connectAuthEmulator,
  createUserWithEmailAndPassword,
  debugAssert,
  debugErrorMap,
  fetchSignInMethodsForEmail,
  getAdditionalUserInfo,
  getMultiFactorResolver,
  getRedirectResult,
  inMemoryPersistence,
  indexedDBLocalPersistence,
  isSignInWithEmailLink,
  linkWithCredential,
  linkWithPhoneNumber,
  linkWithPopup,
  linkWithRedirect,
  multiFactor,
  reauthenticateWithCredential,
  reauthenticateWithPhoneNumber,
  reauthenticateWithPopup,
  reauthenticateWithRedirect,
  sendEmailVerification,
  sendPasswordResetEmail,
  sendSignInLinkToEmail,
  signInAnonymously,
  signInWithCredential,
  signInWithCustomToken,
  signInWithEmailAndPassword,
  signInWithEmailLink,
  signInWithPhoneNumber,
  signInWithPopup,
  signInWithRedirect,
  unlink,
  updateEmail,
  updatePassword,
  updatePhoneNumber,
  updateProfile,
  verifyBeforeUpdateEmail,
  verifyPasswordResetCode
} from "./chunk-FKFOLTQS.js";
import {
  Component,
  ComponentContainer,
  DEFAULT_ENTRY_NAME,
  Deferred,
  ErrorFactory,
  FirebaseError,
  LogLevel,
  Logger,
  Provider,
  SDK_VERSION,
  _addComponent,
  _addOrOverwriteComponent,
  _getProvider,
  _registerComponent,
  areCookiesEnabled,
  base64,
  calculateBackoffMillis,
  contains,
  createMockUserToken,
  createSubscribe,
  deepExtend,
  deleteApp,
  deleteDb,
  errorPrefix,
  getApp,
  getGlobal,
  getModularInstance,
  getUA,
  index_esm2017_exports,
  initializeApp,
  isBrowser,
  isBrowserExtension,
  isIE,
  isIndexedDBAvailable,
  isNode,
  isReactNative,
  issuedAtTime,
  onLog,
  openDb,
  querystringDecode,
  registerVersion,
  setLogLevel,
  validateArgCount,
  validateCallback,
  validateContextObject,
  validateIndexedDBOpenable
} from "./chunk-S4CFBSPA.js";
import "./chunk-SSYGV25P.js";

// node_modules/@firebase/app-compat/dist/esm/index.esm2017.js
var FirebaseAppImpl = class {
  constructor(_delegate, firebase2) {
    this._delegate = _delegate;
    this.firebase = firebase2;
    _addComponent(_delegate, new Component("app-compat", () => this, "PUBLIC"));
    this.container = _delegate.container;
  }
  get automaticDataCollectionEnabled() {
    return this._delegate.automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this._delegate.automaticDataCollectionEnabled = val;
  }
  get name() {
    return this._delegate.name;
  }
  get options() {
    return this._delegate.options;
  }
  delete() {
    return new Promise((resolve) => {
      this._delegate.checkDestroyed();
      resolve();
    }).then(() => {
      this.firebase.INTERNAL.removeApp(this.name);
      return deleteApp(this._delegate);
    });
  }
  _getService(name21, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    var _a2;
    this._delegate.checkDestroyed();
    const provider = this._delegate.container.getProvider(name21);
    if (!provider.isInitialized() && ((_a2 = provider.getComponent()) === null || _a2 === void 0 ? void 0 : _a2.instantiationMode) === "EXPLICIT") {
      provider.initialize();
    }
    return provider.getImmediate({
      identifier: instanceIdentifier
    });
  }
  _removeServiceInstance(name21, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    this._delegate.container.getProvider(name21).clearInstance(instanceIdentifier);
  }
  _addComponent(component) {
    _addComponent(this._delegate, component);
  }
  _addOrOverwriteComponent(component) {
    _addOrOverwriteComponent(this._delegate, component);
  }
  toJSON() {
    return {
      name: this.name,
      automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
      options: this.options
    };
  }
};
var ERRORS = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance."
};
var ERROR_FACTORY = new ErrorFactory("app-compat", "Firebase", ERRORS);
function createFirebaseNamespaceCore(firebaseAppImpl) {
  const apps = {};
  const namespace = {
    __esModule: true,
    initializeApp: initializeAppCompat,
    app,
    registerVersion,
    setLogLevel,
    onLog,
    apps: null,
    SDK_VERSION,
    INTERNAL: {
      registerComponent: registerComponentCompat,
      removeApp,
      useAsService,
      modularAPIs: index_esm2017_exports
    }
  };
  namespace["default"] = namespace;
  Object.defineProperty(namespace, "apps", {
    get: getApps
  });
  function removeApp(name21) {
    delete apps[name21];
  }
  function app(name21) {
    name21 = name21 || DEFAULT_ENTRY_NAME;
    if (!contains(apps, name21)) {
      throw ERROR_FACTORY.create("no-app", { appName: name21 });
    }
    return apps[name21];
  }
  app["App"] = firebaseAppImpl;
  function initializeAppCompat(options, rawConfig = {}) {
    const app2 = initializeApp(options, rawConfig);
    if (contains(apps, app2.name)) {
      return apps[app2.name];
    }
    const appCompat = new firebaseAppImpl(app2, namespace);
    apps[app2.name] = appCompat;
    return appCompat;
  }
  function getApps() {
    return Object.keys(apps).map((name21) => apps[name21]);
  }
  function registerComponentCompat(component) {
    const componentName = component.name;
    const componentNameWithoutCompat = componentName.replace("-compat", "");
    if (_registerComponent(component) && component.type === "PUBLIC") {
      const serviceNamespace = (appArg = app()) => {
        if (typeof appArg[componentNameWithoutCompat] !== "function") {
          throw ERROR_FACTORY.create("invalid-app-argument", {
            appName: componentName
          });
        }
        return appArg[componentNameWithoutCompat]();
      };
      if (component.serviceProps !== void 0) {
        deepExtend(serviceNamespace, component.serviceProps);
      }
      namespace[componentNameWithoutCompat] = serviceNamespace;
      firebaseAppImpl.prototype[componentNameWithoutCompat] = function(...args) {
        const serviceFxn = this._getService.bind(this, componentName);
        return serviceFxn.apply(this, component.multipleInstances ? args : []);
      };
    }
    return component.type === "PUBLIC" ? namespace[componentNameWithoutCompat] : null;
  }
  function useAsService(app2, name21) {
    if (name21 === "serverAuth") {
      return null;
    }
    const useService = name21;
    return useService;
  }
  return namespace;
}
function createFirebaseNamespace() {
  const namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
  namespace.INTERNAL = Object.assign(Object.assign({}, namespace.INTERNAL), {
    createFirebaseNamespace,
    extendNamespace,
    createSubscribe,
    ErrorFactory,
    deepExtend
  });
  function extendNamespace(props) {
    deepExtend(namespace, props);
  }
  return namespace;
}
var firebase$1 = createFirebaseNamespace();
var logger = new Logger("@firebase/app-compat");
var name = "@firebase/app-compat";
var version = "0.1.19";
function registerCoreComponents(variant) {
  registerVersion(name, version, variant);
}
if (isBrowser() && self.firebase !== void 0) {
  logger.warn(`
    Warning: Firebase is already defined in the global scope. Please make sure
    Firebase library is only loaded once.
  `);
  const sdkVersion = self.firebase.SDK_VERSION;
  if (sdkVersion && sdkVersion.indexOf("LITE") >= 0) {
    logger.warn(`
    Warning: You are trying to load Firebase while using Firebase Performance standalone script.
    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.
    `);
  }
}
var firebase = firebase$1;
registerCoreComponents();

// node_modules/@firebase/installations/dist/esm/index.esm2017.js
var name2 = "@firebase/installations";
var version2 = "0.5.5";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = `w:${version2}`;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var ERROR_DESCRIPTION_MAP = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["not-registered"]: "Firebase Installation is not registered.",
  ["installation-not-found"]: "Firebase Installation not found.",
  ["request-failed"]: '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  ["app-offline"]: "Could not process request. Application offline.",
  ["delete-pending-registration"]: "Can't delete installation while there is a pending registration request."
};
var ERROR_FACTORY2 = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error) {
  return error instanceof FirebaseError && error.code.includes("request-failed");
}
function getInstallationsEndpoint({ projectId }) {
  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
async function getErrorFromResponse(requestName, response) {
  const responseJson = await response.json();
  const errorData = responseJson.error;
  return ERROR_FACTORY2.create("request-failed", {
    requestName,
    serverCode: errorData.code,
    serverMessage: errorData.message,
    serverStatus: errorData.status
  });
}
function getHeaders({ apiKey }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, { refreshToken }) {
  const headers = getHeaders(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
async function retryIfServerError(fn) {
  const result = await fn();
  if (result.status >= 500 && result.status < 600) {
    return fn();
  }
  return result;
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;
}
async function createInstallationRequest(appConfig, { fid }) {
  const endpoint = getInstallationsEndpoint(appConfig);
  const headers = getHeaders(appConfig);
  const body = {
    fid,
    authVersion: INTERNAL_AUTH_VERSION,
    appId: appConfig.appId,
    sdkVersion: PACKAGE_VERSION
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const registeredInstallationEntry = {
      fid: responseValue.fid || fid,
      registrationStatus: 2,
      refreshToken: responseValue.refreshToken,
      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
    };
    return registeredInstallationEntry;
  } else {
    throw await getErrorFromResponse("Create Installation", response);
  }
}
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
function bufferToBase64UrlSafe(array) {
  const b64 = btoa(String.fromCharCode(...array));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    const fidByteArray = new Uint8Array(17);
    const crypto2 = self.crypto || self.msCrypto;
    crypto2.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    const fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a2) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  const b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return `${appConfig.appName}!${appConfig.appId}`;
}
var fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  const key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function callFidChangeCallbacks(key, fid) {
  const callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  for (const callback of callbacks) {
    callback(fid);
  }
}
function broadcastFidChange(key, fid) {
  const channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = (e) => {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, (upgradeDB) => {
      switch (upgradeDB.oldVersion) {
        case 0:
          upgradeDB.createObjectStore(OBJECT_STORE_NAME);
      }
    });
  }
  return dbPromise;
}
async function set2(appConfig, value) {
  const key = getKey(appConfig);
  const db = await getDbPromise();
  const tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
  const objectStore = tx.objectStore(OBJECT_STORE_NAME);
  const oldValue = await objectStore.get(key);
  await objectStore.put(value, key);
  await tx.complete;
  if (!oldValue || oldValue.fid !== value.fid) {
    fidChanged(appConfig, value.fid);
  }
  return value;
}
async function remove2(appConfig) {
  const key = getKey(appConfig);
  const db = await getDbPromise();
  const tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).delete(key);
  await tx.complete;
}
async function update2(appConfig, updateFn) {
  const key = getKey(appConfig);
  const db = await getDbPromise();
  const tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
  const store = tx.objectStore(OBJECT_STORE_NAME);
  const oldValue = await store.get(key);
  const newValue = updateFn(oldValue);
  if (newValue === void 0) {
    await store.delete(key);
  } else {
    await store.put(newValue, key);
  }
  await tx.complete;
  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
    fidChanged(appConfig, newValue.fid);
  }
  return newValue;
}
async function getInstallationEntry(appConfig) {
  let registrationPromise;
  const installationEntry = await update2(appConfig, (oldEntry) => {
    const installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
    const entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry2);
    registrationPromise = entryWithPromise.registrationPromise;
    return entryWithPromise.installationEntry;
  });
  if (installationEntry.fid === INVALID_FID) {
    return { installationEntry: await registrationPromise };
  }
  return {
    installationEntry,
    registrationPromise
  };
}
function updateOrCreateInstallationEntry(oldEntry) {
  const entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(appConfig, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      const registrationPromiseWithError = Promise.reject(ERROR_FACTORY2.create("app-offline"));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    const inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    const registrationPromise = registerInstallation(appConfig, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(appConfig)
    };
  } else {
    return { installationEntry };
  }
}
async function registerInstallation(appConfig, installationEntry) {
  try {
    const registeredInstallationEntry = await createInstallationRequest(appConfig, installationEntry);
    return set2(appConfig, registeredInstallationEntry);
  } catch (e) {
    if (isServerError(e) && e.customData.serverCode === 409) {
      await remove2(appConfig);
    } else {
      await set2(appConfig, {
        fid: installationEntry.fid,
        registrationStatus: 0
      });
    }
    throw e;
  }
}
async function waitUntilFidRegistration(appConfig) {
  let entry = await updateInstallationRequest(appConfig);
  while (entry.registrationStatus === 1) {
    await sleep(100);
    entry = await updateInstallationRequest(appConfig);
  }
  if (entry.registrationStatus === 0) {
    const { installationEntry, registrationPromise } = await getInstallationEntry(appConfig);
    if (registrationPromise) {
      return registrationPromise;
    } else {
      return installationEntry;
    }
  }
  return entry;
}
function updateInstallationRequest(appConfig) {
  return update2(appConfig, (oldEntry) => {
    if (!oldEntry) {
      throw ERROR_FACTORY2.create("installation-not-found");
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
async function generateAuthTokenRequest({ appConfig, platformLoggerProvider }, installationEntry) {
  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
  const headers = getHeadersWithAuth(appConfig, installationEntry);
  const platformLogger = platformLoggerProvider.getImmediate({
    optional: true
  });
  if (platformLogger) {
    headers.append("x-firebase-client", platformLogger.getPlatformInfoString());
  }
  const body = {
    installation: {
      sdkVersion: PACKAGE_VERSION
    }
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
    return completedAuthToken;
  } else {
    throw await getErrorFromResponse("Generate Auth Token", response);
  }
}
function getGenerateAuthTokenEndpoint(appConfig, { fid }) {
  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;
}
async function refreshAuthToken(installations, forceRefresh = false) {
  let tokenPromise;
  const entry = await update2(installations.appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY2.create("not-registered");
    }
    const oldAuthToken = oldEntry.authToken;
    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
      return oldEntry;
    } else if (oldAuthToken.requestStatus === 1) {
      tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);
      return oldEntry;
    } else {
      if (!navigator.onLine) {
        throw ERROR_FACTORY2.create("app-offline");
      }
      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
      tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);
      return inProgressEntry;
    }
  });
  const authToken = tokenPromise ? await tokenPromise : entry.authToken;
  return authToken;
}
async function waitUntilAuthTokenRequest(installations, forceRefresh) {
  let entry = await updateAuthTokenRequest(installations.appConfig);
  while (entry.authToken.requestStatus === 1) {
    await sleep(100);
    entry = await updateAuthTokenRequest(installations.appConfig);
  }
  const authToken = entry.authToken;
  if (authToken.requestStatus === 0) {
    return refreshAuthToken(installations, forceRefresh);
  } else {
    return authToken;
  }
}
function updateAuthTokenRequest(appConfig) {
  return update2(appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY2.create("not-registered");
    }
    const oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 } });
    }
    return oldEntry;
  });
}
async function fetchAuthTokenFromServer(installations, installationEntry) {
  try {
    const authToken = await generateAuthTokenRequest(installations, installationEntry);
    const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });
    await set2(installations.appConfig, updatedInstallationEntry);
    return authToken;
  } catch (e) {
    if (isServerError(e) && (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {
      await remove2(installations.appConfig);
    } else {
      const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 } });
      await set2(installations.appConfig, updatedInstallationEntry);
    }
    throw e;
  }
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  const now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  const inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
async function getId(installations) {
  const installationsImpl = installations;
  const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl.appConfig);
  if (registrationPromise) {
    registrationPromise.catch(console.error);
  } else {
    refreshAuthToken(installationsImpl).catch(console.error);
  }
  return installationEntry.fid;
}
async function getToken(installations, forceRefresh = false) {
  const installationsImpl = installations;
  await completeInstallationRegistration(installationsImpl.appConfig);
  const authToken = await refreshAuthToken(installationsImpl, forceRefresh);
  return authToken.token;
}
async function completeInstallationRegistration(appConfig) {
  const { registrationPromise } = await getInstallationEntry(appConfig);
  if (registrationPromise) {
    await registrationPromise;
  }
}
function extractAppConfig(app) {
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const keyName of configKeys) {
    if (!app.options[keyName]) {
      throw getMissingValueError(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY2.create("missing-app-config-values", {
    valueName
  });
}
var INSTALLATIONS_NAME = "installations";
var INSTALLATIONS_NAME_INTERNAL = "installations-internal";
var publicFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const appConfig = extractAppConfig(app);
  const platformLoggerProvider = _getProvider(app, "platform-logger");
  const installationsImpl = {
    app,
    appConfig,
    platformLoggerProvider,
    _delete: () => Promise.resolve()
  };
  return installationsImpl;
};
var internalFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();
  const installationsInternal = {
    getId: () => getId(installations),
    getToken: (forceRefresh) => getToken(installations, forceRefresh)
  };
  return installationsInternal;
};
function registerInstallations() {
  _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, "PUBLIC"));
  _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, "PRIVATE"));
}
registerInstallations();
registerVersion(name2, version2);
registerVersion(name2, version2, "esm2017");

// node_modules/@firebase/analytics/dist/esm/index.esm2017.js
var ANALYTICS_TYPE = "analytics";
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var logger2 = new Logger("@firebase/analytics");
function promiseAllSettled(promises) {
  return Promise.all(promises.map((promise) => promise.catch((e) => e)));
}
function insertScriptTag(dataLayerName2, measurementId) {
  const script = document.createElement("script");
  script.src = `${GTAG_URL}?l=${dataLayerName2}&id=${measurementId}`;
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  let dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
async function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  const correspondingAppId = measurementIdToAppId2[measurementId];
  try {
    if (correspondingAppId) {
      await initializationPromisesMap2[correspondingAppId];
    } else {
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      const foundConfig = dynamicConfigResults.find((config) => config.measurementId === measurementId);
      if (foundConfig) {
        await initializationPromisesMap2[foundConfig.appId];
      }
    }
  } catch (e) {
    logger2.error(e);
  }
  gtagCore("config", measurementId, gtagParams);
}
async function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  try {
    let initializationPromisesToWaitFor = [];
    if (gtagParams && gtagParams["send_to"]) {
      let gaSendToList = gtagParams["send_to"];
      if (!Array.isArray(gaSendToList)) {
        gaSendToList = [gaSendToList];
      }
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      for (const sendToId of gaSendToList) {
        const foundConfig = dynamicConfigResults.find((config) => config.measurementId === sendToId);
        const initializationPromise2 = foundConfig && initializationPromisesMap2[foundConfig.appId];
        if (initializationPromise2) {
          initializationPromisesToWaitFor.push(initializationPromise2);
        } else {
          initializationPromisesToWaitFor = [];
          break;
        }
      }
    }
    if (initializationPromisesToWaitFor.length === 0) {
      initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
    }
    await Promise.all(initializationPromisesToWaitFor);
    gtagCore("event", measurementId, gtagParams || {});
  } catch (e) {
    logger2.error(e);
  }
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  async function gtagWrapper(command, idOrNameOrParams, gtagParams) {
    try {
      if (command === "event") {
        await gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, idOrNameOrParams, gtagParams);
      } else if (command === "config") {
        await gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, idOrNameOrParams, gtagParams);
      } else {
        gtagCore("set", idOrNameOrParams);
      }
    } catch (e) {
      logger2.error(e);
    }
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  let gtagCore = function(..._args) {
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage() {
  const scriptTags = window.document.getElementsByTagName("script");
  for (const tag of Object.values(scriptTags)) {
    if (tag.src && tag.src.includes(GTAG_URL)) {
      return tag;
    }
  }
  return null;
}
var ERRORS2 = {
  ["already-exists"]: "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
  ["already-initialized"]: "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.",
  ["already-initialized-settings"]: "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
  ["interop-component-reg-failed"]: "Firebase Analytics Interop Component failed to instantiate: {$reason}",
  ["invalid-analytics-context"]: "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  ["indexeddb-unavailable"]: "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  ["fetch-throttle"]: "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
  ["config-fetch-failed"]: "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
  ["no-api-key"]: 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
  ["no-app-id"]: 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.'
};
var ERROR_FACTORY3 = new ErrorFactory("analytics", "Analytics", ERRORS2);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = class {
  constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {
    this.throttleMetadata = throttleMetadata;
    this.intervalMillis = intervalMillis;
  }
  getThrottleMetadata(appId) {
    return this.throttleMetadata[appId];
  }
  setThrottleMetadata(appId, metadata) {
    this.throttleMetadata[appId] = metadata;
  }
  deleteThrottleMetadata(appId) {
    delete this.throttleMetadata[appId];
  }
};
var defaultRetryData = new RetryData();
function getHeaders2(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
async function fetchDynamicConfig(appFields) {
  var _a2;
  const { appId, apiKey } = appFields;
  const request = {
    method: "GET",
    headers: getHeaders2(apiKey)
  };
  const appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
  const response = await fetch(appUrl, request);
  if (response.status !== 200 && response.status !== 304) {
    let errorMessage = "";
    try {
      const jsonResponse = await response.json();
      if ((_a2 = jsonResponse.error) === null || _a2 === void 0 ? void 0 : _a2.message) {
        errorMessage = jsonResponse.error.message;
      }
    } catch (_ignored) {
    }
    throw ERROR_FACTORY3.create("config-fetch-failed", {
      httpStatus: response.status,
      responseMessage: errorMessage
    });
  }
  return response.json();
}
async function fetchDynamicConfigWithRetry(app, retryData = defaultRetryData, timeoutMillis) {
  const { appId, apiKey, measurementId } = app.options;
  if (!appId) {
    throw ERROR_FACTORY3.create("no-app-id");
  }
  if (!apiKey) {
    if (measurementId) {
      return {
        measurementId,
        appId
      };
    }
    throw ERROR_FACTORY3.create("no-api-key");
  }
  const throttleMetadata = retryData.getThrottleMetadata(appId) || {
    backoffCount: 0,
    throttleEndTimeMillis: Date.now()
  };
  const signal = new AnalyticsAbortSignal();
  setTimeout(async () => {
    signal.abort();
  }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
  return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);
}
async function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData) {
  const { appId, measurementId } = appFields;
  try {
    await setAbortableTimeout(signal, throttleEndTimeMillis);
  } catch (e) {
    if (measurementId) {
      logger2.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${e.message}]`);
      return { appId, measurementId };
    }
    throw e;
  }
  try {
    const response = await fetchDynamicConfig(appFields);
    retryData.deleteThrottleMetadata(appId);
    return response;
  } catch (e) {
    if (!isRetriableError(e)) {
      retryData.deleteThrottleMetadata(appId);
      if (measurementId) {
        logger2.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${e.message}]`);
        return { appId, measurementId };
      } else {
        throw e;
      }
    }
    const backoffMillis = Number(e.customData.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
    const throttleMetadata = {
      throttleEndTimeMillis: Date.now() + backoffMillis,
      backoffCount: backoffCount + 1
    };
    retryData.setThrottleMetadata(appId, throttleMetadata);
    logger2.debug(`Calling attemptFetch again in ${backoffMillis} millis`);
    return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);
  }
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise((resolve, reject) => {
    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    const timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(() => {
      clearTimeout(timeout);
      reject(ERROR_FACTORY3.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  const httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = class {
  constructor() {
    this.listeners = [];
  }
  addEventListener(listener) {
    this.listeners.push(listener);
  }
  abort() {
    this.listeners.forEach((listener) => listener());
  }
};
async function validateIndexedDB() {
  if (!isIndexedDBAvailable()) {
    logger2.warn(ERROR_FACTORY3.create("indexeddb-unavailable", {
      errorInfo: "IndexedDB is not available in this environment."
    }).message);
    return false;
  } else {
    try {
      await validateIndexedDBOpenable();
    } catch (e) {
      logger2.warn(ERROR_FACTORY3.create("indexeddb-unavailable", {
        errorInfo: e
      }).message);
      return false;
    }
  }
  return true;
}
async function _initializeAnalytics(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2, options) {
  var _a2;
  const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
  dynamicConfigPromise.then((config) => {
    measurementIdToAppId2[config.measurementId] = config.appId;
    if (app.options.measurementId && config.measurementId !== app.options.measurementId) {
      logger2.warn(`The measurement ID in the local Firebase config (${app.options.measurementId}) does not match the measurement ID fetched from the server (${config.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`);
    }
  }).catch((e) => logger2.error(e));
  dynamicConfigPromisesList2.push(dynamicConfigPromise);
  const fidPromise = validateIndexedDB().then((envIsValid) => {
    if (envIsValid) {
      return installations.getId();
    } else {
      return void 0;
    }
  });
  const [dynamicConfig, fid] = await Promise.all([
    dynamicConfigPromise,
    fidPromise
  ]);
  if (!findGtagScriptOnPage()) {
    insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
  }
  gtagCore("js", new Date());
  const configProperties = (_a2 = options === null || options === void 0 ? void 0 : options.config) !== null && _a2 !== void 0 ? _a2 : {};
  configProperties[ORIGIN_KEY] = "firebase";
  configProperties.update = true;
  if (fid != null) {
    configProperties[GA_FID_KEY] = fid;
  }
  gtagCore("config", dynamicConfig.measurementId, configProperties);
  return dynamicConfig.measurementId;
}
var AnalyticsService = class {
  constructor(app) {
    this.app = app;
  }
  _delete() {
    delete initializationPromisesMap[this.app.options.appId];
    return Promise.resolve();
  }
};
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function settings(options) {
  if (globalInitDone) {
    throw ERROR_FACTORY3.create("already-initialized");
  }
  if (options.dataLayerName) {
    dataLayerName = options.dataLayerName;
  }
  if (options.gtagName) {
    gtagName = options.gtagName;
  }
}
function warnOnBrowserContextMismatch() {
  const mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    const details = mismatchedEnvMessages.map((message, index) => `(${index + 1}) ${message}`).join(" ");
    const err = ERROR_FACTORY3.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger2.warn(err.message);
  }
}
function factory(app, installations, options) {
  warnOnBrowserContextMismatch();
  const appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY3.create("no-app-id");
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger2.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
    } else {
      throw ERROR_FACTORY3.create("no-api-key");
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY3.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);
  const analyticsInstance = new AnalyticsService(app);
  return analyticsInstance;
}
async function logEvent$1(gtagFunction, initializationPromise2, eventName, eventParams, options) {
  if (options && options.global) {
    gtagFunction("event", eventName, eventParams);
    return;
  } else {
    const measurementId = await initializationPromise2;
    const params = Object.assign(Object.assign({}, eventParams), { "send_to": measurementId });
    gtagFunction("event", eventName, params);
  }
}
async function setCurrentScreen$1(gtagFunction, initializationPromise2, screenName, options) {
  if (options && options.global) {
    gtagFunction("set", { "screen_name": screenName });
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise2;
    gtagFunction("config", measurementId, {
      update: true,
      "screen_name": screenName
    });
  }
}
async function setUserId$1(gtagFunction, initializationPromise2, id, options) {
  if (options && options.global) {
    gtagFunction("set", { "user_id": id });
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise2;
    gtagFunction("config", measurementId, {
      update: true,
      "user_id": id
    });
  }
}
async function setUserProperties$1(gtagFunction, initializationPromise2, properties, options) {
  if (options && options.global) {
    const flatProperties = {};
    for (const key of Object.keys(properties)) {
      flatProperties[`user_properties.${key}`] = properties[key];
    }
    gtagFunction("set", flatProperties);
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise2;
    gtagFunction("config", measurementId, {
      update: true,
      "user_properties": properties
    });
  }
}
async function setAnalyticsCollectionEnabled$1(initializationPromise2, enabled) {
  const measurementId = await initializationPromise2;
  window[`ga-disable-${measurementId}`] = !enabled;
}
async function isSupported() {
  if (isBrowserExtension()) {
    return false;
  }
  if (!areCookiesEnabled()) {
    return false;
  }
  if (!isIndexedDBAvailable()) {
    return false;
  }
  try {
    const isDBOpenable = await validateIndexedDBOpenable();
    return isDBOpenable;
  } catch (error) {
    return false;
  }
}
function setCurrentScreen(analyticsInstance, screenName, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch((e) => logger2.error(e));
}
function setUserId(analyticsInstance, id, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch((e) => logger2.error(e));
}
function setUserProperties(analyticsInstance, properties, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch((e) => logger2.error(e));
}
function setAnalyticsCollectionEnabled(analyticsInstance, enabled) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch((e) => logger2.error(e));
}
function logEvent(analyticsInstance, eventName, eventParams, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch((e) => logger2.error(e));
}
var name3 = "@firebase/analytics";
var version3 = "0.7.5";
function registerAnalytics() {
  _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {
    const app = container.getProvider("app").getImmediate();
    const installations = container.getProvider("installations-internal").getImmediate();
    return factory(app, installations, analyticsOptions);
  }, "PUBLIC"));
  _registerComponent(new Component("analytics-internal", internalFactory3, "PRIVATE"));
  registerVersion(name3, version3);
  registerVersion(name3, version3, "esm2017");
  function internalFactory3(container) {
    try {
      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)
      };
    } catch (e) {
      throw ERROR_FACTORY3.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics();

// node_modules/@firebase/analytics-compat/dist/esm/index.esm2017.js
var name4 = "@firebase/analytics-compat";
var version4 = "0.1.6";
var AnalyticsService2 = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  logEvent(eventName, eventParams, options) {
    logEvent(this._delegate, eventName, eventParams, options);
  }
  setCurrentScreen(screenName, options) {
    setCurrentScreen(this._delegate, screenName, options);
  }
  setUserId(id, options) {
    setUserId(this._delegate, id, options);
  }
  setUserProperties(properties, options) {
    setUserProperties(this._delegate, properties, options);
  }
  setAnalyticsCollectionEnabled(enabled) {
    setAnalyticsCollectionEnabled(this._delegate, enabled);
  }
};
var EventName;
(function(EventName2) {
  EventName2["ADD_SHIPPING_INFO"] = "add_shipping_info";
  EventName2["ADD_PAYMENT_INFO"] = "add_payment_info";
  EventName2["ADD_TO_CART"] = "add_to_cart";
  EventName2["ADD_TO_WISHLIST"] = "add_to_wishlist";
  EventName2["BEGIN_CHECKOUT"] = "begin_checkout";
  EventName2["CHECKOUT_PROGRESS"] = "checkout_progress";
  EventName2["EXCEPTION"] = "exception";
  EventName2["GENERATE_LEAD"] = "generate_lead";
  EventName2["LOGIN"] = "login";
  EventName2["PAGE_VIEW"] = "page_view";
  EventName2["PURCHASE"] = "purchase";
  EventName2["REFUND"] = "refund";
  EventName2["REMOVE_FROM_CART"] = "remove_from_cart";
  EventName2["SCREEN_VIEW"] = "screen_view";
  EventName2["SEARCH"] = "search";
  EventName2["SELECT_CONTENT"] = "select_content";
  EventName2["SELECT_ITEM"] = "select_item";
  EventName2["SELECT_PROMOTION"] = "select_promotion";
  EventName2["SET_CHECKOUT_OPTION"] = "set_checkout_option";
  EventName2["SHARE"] = "share";
  EventName2["SIGN_UP"] = "sign_up";
  EventName2["TIMING_COMPLETE"] = "timing_complete";
  EventName2["VIEW_CART"] = "view_cart";
  EventName2["VIEW_ITEM"] = "view_item";
  EventName2["VIEW_ITEM_LIST"] = "view_item_list";
  EventName2["VIEW_PROMOTION"] = "view_promotion";
  EventName2["VIEW_SEARCH_RESULTS"] = "view_search_results";
})(EventName || (EventName = {}));
var factory2 = (container) => {
  const app = container.getProvider("app-compat").getImmediate();
  const analyticsServiceExp = container.getProvider("analytics").getImmediate();
  return new AnalyticsService2(app, analyticsServiceExp);
};
function registerAnalytics2() {
  const namespaceExports = {
    Analytics: AnalyticsService2,
    settings,
    isSupported,
    EventName
  };
  firebase.INTERNAL.registerComponent(new Component("analytics-compat", factory2, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
}
registerAnalytics2();
firebase.registerVersion(name4, version4);

// node_modules/@firebase/app-check/dist/esm/index.esm2017.js
var APP_CHECK_STATES = /* @__PURE__ */ new Map();
var DEFAULT_STATE = {
  activated: false,
  tokenObservers: []
};
var DEBUG_STATE = {
  initialized: false,
  enabled: false
};
function getState(app) {
  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;
}
function setState(app, state) {
  APP_CHECK_STATES.set(app, state);
}
function getDebugState() {
  return DEBUG_STATE;
}
var BASE_ENDPOINT = "https://content-firebaseappcheck.googleapis.com/v1beta";
var EXCHANGE_RECAPTCHA_TOKEN_METHOD = "exchangeRecaptchaToken";
var EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = "exchangeRecaptchaEnterpriseToken";
var EXCHANGE_DEBUG_TOKEN_METHOD = "exchangeDebugToken";
var TOKEN_REFRESH_TIME = {
  OFFSET_DURATION: 5 * 60 * 1e3,
  RETRIAL_MIN_WAIT: 30 * 1e3,
  RETRIAL_MAX_WAIT: 16 * 60 * 1e3
};
var ONE_DAY = 24 * 60 * 60 * 1e3;
var Refresher = class {
  constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {
    this.operation = operation;
    this.retryPolicy = retryPolicy;
    this.getWaitDuration = getWaitDuration;
    this.lowerBound = lowerBound;
    this.upperBound = upperBound;
    this.pending = null;
    this.nextErrorWaitInterval = lowerBound;
    if (lowerBound > upperBound) {
      throw new Error("Proactive refresh lower bound greater than upper bound!");
    }
  }
  start() {
    this.nextErrorWaitInterval = this.lowerBound;
    this.process(true).catch(() => {
    });
  }
  stop() {
    if (this.pending) {
      this.pending.reject("cancelled");
      this.pending = null;
    }
  }
  isRunning() {
    return !!this.pending;
  }
  async process(hasSucceeded) {
    this.stop();
    try {
      this.pending = new Deferred();
      await sleep2(this.getNextRun(hasSucceeded));
      this.pending.resolve();
      await this.pending.promise;
      this.pending = new Deferred();
      await this.operation();
      this.pending.resolve();
      await this.pending.promise;
      this.process(true).catch(() => {
      });
    } catch (error) {
      if (this.retryPolicy(error)) {
        this.process(false).catch(() => {
        });
      } else {
        this.stop();
      }
    }
  }
  getNextRun(hasSucceeded) {
    if (hasSucceeded) {
      this.nextErrorWaitInterval = this.lowerBound;
      return this.getWaitDuration();
    } else {
      const currentErrorWaitInterval = this.nextErrorWaitInterval;
      this.nextErrorWaitInterval *= 2;
      if (this.nextErrorWaitInterval > this.upperBound) {
        this.nextErrorWaitInterval = this.upperBound;
      }
      return currentErrorWaitInterval;
    }
  }
};
function sleep2(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
var ERRORS3 = {
  ["already-initialized"]: "You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.",
  ["use-before-activation"]: "App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.",
  ["fetch-network-error"]: "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.",
  ["fetch-parse-error"]: "Fetch client could not parse response. Original error: {$originalErrorMessage}.",
  ["fetch-status-error"]: "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.",
  ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
  ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
  ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
  ["recaptcha-error"]: "ReCAPTCHA error.",
  ["throttled"]: `Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}`
};
var ERROR_FACTORY4 = new ErrorFactory("appCheck", "AppCheck", ERRORS3);
function getRecaptcha(isEnterprise = false) {
  var _a2;
  if (isEnterprise) {
    return (_a2 = self.grecaptcha) === null || _a2 === void 0 ? void 0 : _a2.enterprise;
  }
  return self.grecaptcha;
}
function ensureActivated(app) {
  if (!getState(app).activated) {
    throw ERROR_FACTORY4.create("use-before-activation", {
      appName: app.name
    });
  }
}
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getDurationString(durationInMillis) {
  const totalSeconds = Math.round(durationInMillis / 1e3);
  const days = Math.floor(totalSeconds / (3600 * 24));
  const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);
  const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);
  const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;
  let result = "";
  if (days) {
    result += pad(days) + "d:";
  }
  if (hours) {
    result += pad(hours) + "h:";
  }
  result += pad(minutes) + "m:" + pad(seconds) + "s";
  return result;
}
function pad(value) {
  if (value === 0) {
    return "00";
  }
  return value >= 10 ? value.toString() : "0" + value;
}
async function exchangeToken({ url, body }, platformLoggerProvider) {
  const headers = {
    "Content-Type": "application/json"
  };
  const platformLogger = platformLoggerProvider.getImmediate({
    optional: true
  });
  if (platformLogger) {
    headers["X-Firebase-Client"] = platformLogger.getPlatformInfoString();
  }
  const options = {
    method: "POST",
    body: JSON.stringify(body),
    headers
  };
  let response;
  try {
    response = await fetch(url, options);
  } catch (originalError) {
    throw ERROR_FACTORY4.create("fetch-network-error", {
      originalErrorMessage: originalError.message
    });
  }
  if (response.status !== 200) {
    throw ERROR_FACTORY4.create("fetch-status-error", {
      httpStatus: response.status
    });
  }
  let responseBody;
  try {
    responseBody = await response.json();
  } catch (originalError) {
    throw ERROR_FACTORY4.create("fetch-parse-error", {
      originalErrorMessage: originalError.message
    });
  }
  const match = responseBody.ttl.match(/^([\d.]+)(s)$/);
  if (!match || !match[2] || isNaN(Number(match[1]))) {
    throw ERROR_FACTORY4.create("fetch-parse-error", {
      originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration format: ${responseBody.ttl}`
    });
  }
  const timeToLiveAsNumber = Number(match[1]) * 1e3;
  const now = Date.now();
  return {
    token: responseBody.attestationToken,
    expireTimeMillis: now + timeToLiveAsNumber,
    issuedAtTimeMillis: now
  };
}
function getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {
  const { projectId, appId, apiKey } = app.options;
  return {
    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,
    body: {
      "recaptcha_token": reCAPTCHAToken
    }
  };
}
function getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {
  const { projectId, appId, apiKey } = app.options;
  return {
    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,
    body: {
      "recaptcha_enterprise_token": reCAPTCHAToken
    }
  };
}
function getExchangeDebugTokenRequest(app, debugToken) {
  const { projectId, appId, apiKey } = app.options;
  return {
    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,
    body: {
      debug_token: debugToken
    }
  };
}
var DB_NAME = "firebase-app-check-database";
var DB_VERSION = 1;
var STORE_NAME = "firebase-app-check-store";
var DEBUG_TOKEN_KEY = "debug-token";
var dbPromise2 = null;
function getDBPromise() {
  if (dbPromise2) {
    return dbPromise2;
  }
  dbPromise2 = new Promise((resolve, reject) => {
    try {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      request.onerror = (event) => {
        var _a2;
        reject(ERROR_FACTORY4.create("storage-open", {
          originalErrorMessage: (_a2 = event.target.error) === null || _a2 === void 0 ? void 0 : _a2.message
        }));
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        switch (event.oldVersion) {
          case 0:
            db.createObjectStore(STORE_NAME, {
              keyPath: "compositeKey"
            });
        }
      };
    } catch (e) {
      reject(ERROR_FACTORY4.create("storage-open", {
        originalErrorMessage: e.message
      }));
    }
  });
  return dbPromise2;
}
function readTokenFromIndexedDB(app) {
  return read(computeKey(app));
}
function writeTokenToIndexedDB(app, token) {
  return write(computeKey(app), token);
}
function writeDebugTokenToIndexedDB(token) {
  return write(DEBUG_TOKEN_KEY, token);
}
function readDebugTokenFromIndexedDB() {
  return read(DEBUG_TOKEN_KEY);
}
async function write(key, value) {
  const db = await getDBPromise();
  const transaction = db.transaction(STORE_NAME, "readwrite");
  const store = transaction.objectStore(STORE_NAME);
  const request = store.put({
    compositeKey: key,
    value
  });
  return new Promise((resolve, reject) => {
    request.onsuccess = (_event) => {
      resolve();
    };
    transaction.onerror = (event) => {
      var _a2;
      reject(ERROR_FACTORY4.create("storage-set", {
        originalErrorMessage: (_a2 = event.target.error) === null || _a2 === void 0 ? void 0 : _a2.message
      }));
    };
  });
}
async function read(key) {
  const db = await getDBPromise();
  const transaction = db.transaction(STORE_NAME, "readonly");
  const store = transaction.objectStore(STORE_NAME);
  const request = store.get(key);
  return new Promise((resolve, reject) => {
    request.onsuccess = (event) => {
      const result = event.target.result;
      if (result) {
        resolve(result.value);
      } else {
        resolve(void 0);
      }
    };
    transaction.onerror = (event) => {
      var _a2;
      reject(ERROR_FACTORY4.create("storage-get", {
        originalErrorMessage: (_a2 = event.target.error) === null || _a2 === void 0 ? void 0 : _a2.message
      }));
    };
  });
}
function computeKey(app) {
  return `${app.options.appId}-${app.name}`;
}
var logger3 = new Logger("@firebase/app-check");
async function readTokenFromStorage(app) {
  if (isIndexedDBAvailable()) {
    let token = void 0;
    try {
      token = await readTokenFromIndexedDB(app);
    } catch (e) {
      logger3.warn(`Failed to read token from IndexedDB. Error: ${e}`);
    }
    return token;
  }
  return void 0;
}
function writeTokenToStorage(app, token) {
  if (isIndexedDBAvailable()) {
    return writeTokenToIndexedDB(app, token).catch((e) => {
      logger3.warn(`Failed to write token to IndexedDB. Error: ${e}`);
    });
  }
  return Promise.resolve();
}
async function readOrCreateDebugTokenFromStorage() {
  let existingDebugToken = void 0;
  try {
    existingDebugToken = await readDebugTokenFromIndexedDB();
  } catch (_e) {
  }
  if (!existingDebugToken) {
    const newToken = uuidv4();
    writeDebugTokenToIndexedDB(newToken).catch((e) => logger3.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));
    return newToken;
  } else {
    return existingDebugToken;
  }
}
function isDebugMode() {
  const debugState = getDebugState();
  return debugState.enabled;
}
async function getDebugToken() {
  const state = getDebugState();
  if (state.enabled && state.token) {
    return state.token.promise;
  } else {
    throw Error(`
            Can't get debug token in production mode.
        `);
  }
}
function initializeDebugMode() {
  const globals = getGlobal();
  const debugState = getDebugState();
  debugState.initialized = true;
  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== "string" && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {
    return;
  }
  debugState.enabled = true;
  const deferredToken = new Deferred();
  debugState.token = deferredToken;
  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === "string") {
    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);
  } else {
    deferredToken.resolve(readOrCreateDebugTokenFromStorage());
  }
}
var defaultTokenErrorData = { error: "UNKNOWN_ERROR" };
function formatDummyToken(tokenErrorData) {
  return base64.encodeString(JSON.stringify(tokenErrorData), false);
}
async function getToken$2(appCheck, forceRefresh = false) {
  const app = appCheck.app;
  ensureActivated(app);
  const state = getState(app);
  let token = state.token;
  let error = void 0;
  if (!token) {
    const cachedToken = await state.cachedTokenPromise;
    if (cachedToken && isValid(cachedToken)) {
      token = cachedToken;
    }
  }
  if (!forceRefresh && token && isValid(token)) {
    return {
      token: token.token
    };
  }
  let shouldCallListeners = false;
  if (isDebugMode()) {
    if (!state.exchangeTokenPromise) {
      state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.platformLoggerProvider).then((token2) => {
        state.exchangeTokenPromise = void 0;
        return token2;
      });
      shouldCallListeners = true;
    }
    const tokenFromDebugExchange = await state.exchangeTokenPromise;
    await writeTokenToStorage(app, tokenFromDebugExchange);
    setState(app, Object.assign(Object.assign({}, state), { token: tokenFromDebugExchange }));
    return { token: tokenFromDebugExchange.token };
  }
  try {
    if (!state.exchangeTokenPromise) {
      state.exchangeTokenPromise = state.provider.getToken().then((token2) => {
        state.exchangeTokenPromise = void 0;
        return token2;
      });
      shouldCallListeners = true;
    }
    token = await state.exchangeTokenPromise;
  } catch (e) {
    if (e.code === `appCheck/${"throttled"}`) {
      logger3.warn(e.message);
    } else {
      logger3.error(e);
    }
    error = e;
  }
  let interopTokenResult;
  if (!token) {
    interopTokenResult = makeDummyTokenResult(error);
  } else {
    interopTokenResult = {
      token: token.token
    };
    setState(app, Object.assign(Object.assign({}, state), { token }));
    await writeTokenToStorage(app, token);
  }
  if (shouldCallListeners) {
    notifyTokenListeners(app, interopTokenResult);
  }
  return interopTokenResult;
}
function addTokenListener(appCheck, type, listener, onError) {
  const { app } = appCheck;
  const state = getState(app);
  const tokenObserver = {
    next: listener,
    error: onError,
    type
  };
  setState(app, Object.assign(Object.assign({}, state), { tokenObservers: [...state.tokenObservers, tokenObserver] }));
  if (state.token && isValid(state.token)) {
    const validToken = state.token;
    Promise.resolve().then(() => {
      listener({ token: validToken.token });
      initTokenRefresher(appCheck);
    }).catch(() => {
    });
  }
  void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));
}
function removeTokenListener(app, listener) {
  const state = getState(app);
  const newObservers = state.tokenObservers.filter((tokenObserver) => tokenObserver.next !== listener);
  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {
    state.tokenRefresher.stop();
  }
  setState(app, Object.assign(Object.assign({}, state), { tokenObservers: newObservers }));
}
function initTokenRefresher(appCheck) {
  const { app } = appCheck;
  const state = getState(app);
  let refresher = state.tokenRefresher;
  if (!refresher) {
    refresher = createTokenRefresher(appCheck);
    setState(app, Object.assign(Object.assign({}, state), { tokenRefresher: refresher }));
  }
  if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {
    refresher.start();
  }
}
function createTokenRefresher(appCheck) {
  const { app } = appCheck;
  return new Refresher(async () => {
    const state = getState(app);
    let result;
    if (!state.token) {
      result = await getToken$2(appCheck);
    } else {
      result = await getToken$2(appCheck, true);
    }
    if (result.error) {
      throw result.error;
    }
  }, () => {
    return true;
  }, () => {
    const state = getState(app);
    if (state.token) {
      let nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1e3;
      const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1e3;
      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);
      return Math.max(0, nextRefreshTimeMillis - Date.now());
    } else {
      return 0;
    }
  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);
}
function notifyTokenListeners(app, token) {
  const observers = getState(app).tokenObservers;
  for (const observer of observers) {
    try {
      if (observer.type === "EXTERNAL" && token.error != null) {
        observer.error(token.error);
      } else {
        observer.next(token);
      }
    } catch (e) {
    }
  }
}
function isValid(token) {
  return token.expireTimeMillis - Date.now() > 0;
}
function makeDummyTokenResult(error) {
  return {
    token: formatDummyToken(defaultTokenErrorData),
    error
  };
}
var AppCheckService = class {
  constructor(app, platformLoggerProvider) {
    this.app = app;
    this.platformLoggerProvider = platformLoggerProvider;
  }
  _delete() {
    const { tokenObservers } = getState(this.app);
    for (const tokenObserver of tokenObservers) {
      removeTokenListener(this.app, tokenObserver.next);
    }
    return Promise.resolve();
  }
};
function factory3(app, platformLoggerProvider) {
  return new AppCheckService(app, platformLoggerProvider);
}
function internalFactory2(appCheck) {
  return {
    getToken: (forceRefresh) => getToken$2(appCheck, forceRefresh),
    addTokenListener: (listener) => addTokenListener(appCheck, "INTERNAL", listener),
    removeTokenListener: (listener) => removeTokenListener(appCheck.app, listener)
  };
}
var name5 = "@firebase/app-check";
var version5 = "0.5.3";
var RECAPTCHA_URL = "https://www.google.com/recaptcha/api.js";
var RECAPTCHA_ENTERPRISE_URL = "https://www.google.com/recaptcha/enterprise.js";
function initializeV3(app, siteKey) {
  const state = getState(app);
  const initialized = new Deferred();
  setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: { initialized } }));
  const divId = makeDiv(app);
  const grecaptcha = getRecaptcha(false);
  if (!grecaptcha) {
    loadReCAPTCHAV3Script(() => {
      const grecaptcha2 = getRecaptcha(false);
      if (!grecaptcha2) {
        throw new Error("no recaptcha");
      }
      queueWidgetRender(app, siteKey, grecaptcha2, divId, initialized);
    });
  } else {
    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);
  }
  return initialized.promise;
}
function initializeEnterprise(app, siteKey) {
  const state = getState(app);
  const initialized = new Deferred();
  setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: { initialized } }));
  const divId = makeDiv(app);
  const grecaptcha = getRecaptcha(true);
  if (!grecaptcha) {
    loadReCAPTCHAEnterpriseScript(() => {
      const grecaptcha2 = getRecaptcha(true);
      if (!grecaptcha2) {
        throw new Error("no recaptcha");
      }
      queueWidgetRender(app, siteKey, grecaptcha2, divId, initialized);
    });
  } else {
    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);
  }
  return initialized.promise;
}
function queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {
  grecaptcha.ready(() => {
    renderInvisibleWidget(app, siteKey, grecaptcha, container);
    initialized.resolve(grecaptcha);
  });
}
function makeDiv(app) {
  const divId = `fire_app_check_${app.name}`;
  const invisibleDiv = document.createElement("div");
  invisibleDiv.id = divId;
  invisibleDiv.style.display = "none";
  document.body.appendChild(invisibleDiv);
  return divId;
}
async function getToken$1(app) {
  ensureActivated(app);
  const reCAPTCHAState = getState(app).reCAPTCHAState;
  const recaptcha = await reCAPTCHAState.initialized.promise;
  return new Promise((resolve, _reject) => {
    const reCAPTCHAState2 = getState(app).reCAPTCHAState;
    recaptcha.ready(() => {
      resolve(recaptcha.execute(reCAPTCHAState2.widgetId, {
        action: "fire_app_check"
      }));
    });
  });
}
function renderInvisibleWidget(app, siteKey, grecaptcha, container) {
  const widgetId = grecaptcha.render(container, {
    sitekey: siteKey,
    size: "invisible"
  });
  const state = getState(app);
  setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: Object.assign(Object.assign({}, state.reCAPTCHAState), {
    widgetId
  }) }));
}
function loadReCAPTCHAV3Script(onload) {
  const script = document.createElement("script");
  script.src = RECAPTCHA_URL;
  script.onload = onload;
  document.head.appendChild(script);
}
function loadReCAPTCHAEnterpriseScript(onload) {
  const script = document.createElement("script");
  script.src = RECAPTCHA_ENTERPRISE_URL;
  script.onload = onload;
  document.head.appendChild(script);
}
var ReCaptchaV3Provider = class {
  constructor(_siteKey) {
    this._siteKey = _siteKey;
    this._throttleData = null;
  }
  async getToken() {
    var _a2;
    throwIfThrottled(this._throttleData);
    const attestedClaimsToken = await getToken$1(this._app).catch((_e) => {
      throw ERROR_FACTORY4.create("recaptcha-error");
    });
    let result;
    try {
      result = await exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._platformLoggerProvider);
    } catch (e) {
      if (e.code === "fetch-status-error") {
        this._throttleData = setBackoff(Number((_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2.httpStatus), this._throttleData);
        throw ERROR_FACTORY4.create("throttled", {
          time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),
          httpStatus: this._throttleData.httpStatus
        });
      } else {
        throw e;
      }
    }
    this._throttleData = null;
    return result;
  }
  initialize(app) {
    this._app = app;
    this._platformLoggerProvider = _getProvider(app, "platform-logger");
    initializeV3(app, this._siteKey).catch(() => {
    });
  }
  isEqual(otherProvider) {
    if (otherProvider instanceof ReCaptchaV3Provider) {
      return this._siteKey === otherProvider._siteKey;
    } else {
      return false;
    }
  }
};
var ReCaptchaEnterpriseProvider = class {
  constructor(_siteKey) {
    this._siteKey = _siteKey;
    this._throttleData = null;
  }
  async getToken() {
    var _a2;
    throwIfThrottled(this._throttleData);
    const attestedClaimsToken = await getToken$1(this._app).catch((_e) => {
      throw ERROR_FACTORY4.create("recaptcha-error");
    });
    let result;
    try {
      result = await exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._platformLoggerProvider);
    } catch (e) {
      if (e.code === "fetch-status-error") {
        this._throttleData = setBackoff(Number((_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2.httpStatus), this._throttleData);
        throw ERROR_FACTORY4.create("throttled", {
          time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),
          httpStatus: this._throttleData.httpStatus
        });
      } else {
        throw e;
      }
    }
    this._throttleData = null;
    return result;
  }
  initialize(app) {
    this._app = app;
    this._platformLoggerProvider = _getProvider(app, "platform-logger");
    initializeEnterprise(app, this._siteKey).catch(() => {
    });
  }
  isEqual(otherProvider) {
    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {
      return this._siteKey === otherProvider._siteKey;
    } else {
      return false;
    }
  }
};
var CustomProvider = class {
  constructor(_customProviderOptions) {
    this._customProviderOptions = _customProviderOptions;
  }
  async getToken() {
    const customToken = await this._customProviderOptions.getToken();
    const issuedAtTimeSeconds = issuedAtTime(customToken.token);
    const issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1e3 : Date.now();
    return Object.assign(Object.assign({}, customToken), { issuedAtTimeMillis });
  }
  initialize(app) {
    this._app = app;
  }
  isEqual(otherProvider) {
    if (otherProvider instanceof CustomProvider) {
      return this._customProviderOptions.getToken.toString() === otherProvider._customProviderOptions.getToken.toString();
    } else {
      return false;
    }
  }
};
function setBackoff(httpStatus, throttleData) {
  if (httpStatus === 404 || httpStatus === 403) {
    return {
      backoffCount: 1,
      allowRequestsAfter: Date.now() + ONE_DAY,
      httpStatus
    };
  } else {
    const backoffCount = throttleData ? throttleData.backoffCount : 0;
    const backoffMillis = calculateBackoffMillis(backoffCount, 1e3, 2);
    return {
      backoffCount: backoffCount + 1,
      allowRequestsAfter: Date.now() + backoffMillis,
      httpStatus
    };
  }
}
function throwIfThrottled(throttleData) {
  if (throttleData) {
    if (Date.now() - throttleData.allowRequestsAfter <= 0) {
      throw ERROR_FACTORY4.create("throttled", {
        time: getDurationString(throttleData.allowRequestsAfter - Date.now()),
        httpStatus: throttleData.httpStatus
      });
    }
  }
}
function initializeAppCheck(app = getApp(), options) {
  app = getModularInstance(app);
  const provider = _getProvider(app, "app-check");
  if (!getDebugState().initialized) {
    initializeDebugMode();
  }
  if (isDebugMode()) {
    void getDebugToken().then((token) => console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));
  }
  if (provider.isInitialized()) {
    const existingInstance = provider.getImmediate();
    const initialOptions = provider.getOptions();
    if (initialOptions.isTokenAutoRefreshEnabled === options.isTokenAutoRefreshEnabled && initialOptions.provider.isEqual(options.provider)) {
      return existingInstance;
    } else {
      throw ERROR_FACTORY4.create("already-initialized", {
        appName: app.name
      });
    }
  }
  const appCheck = provider.initialize({ options });
  _activate(app, options.provider, options.isTokenAutoRefreshEnabled);
  if (getState(app).isTokenAutoRefreshEnabled) {
    addTokenListener(appCheck, "INTERNAL", () => {
    });
  }
  return appCheck;
}
function _activate(app, provider, isTokenAutoRefreshEnabled) {
  const state = getState(app);
  const newState = Object.assign(Object.assign({}, state), { activated: true });
  newState.provider = provider;
  newState.cachedTokenPromise = readTokenFromStorage(app).then((cachedToken) => {
    if (cachedToken && isValid(cachedToken)) {
      setState(app, Object.assign(Object.assign({}, getState(app)), { token: cachedToken }));
      notifyTokenListeners(app, { token: cachedToken.token });
    }
    return cachedToken;
  });
  newState.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === void 0 ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;
  setState(app, newState);
  newState.provider.initialize(app);
}
function setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {
  const app = appCheckInstance.app;
  const state = getState(app);
  if (state.tokenRefresher) {
    if (isTokenAutoRefreshEnabled === true) {
      state.tokenRefresher.start();
    } else {
      state.tokenRefresher.stop();
    }
  }
  setState(app, Object.assign(Object.assign({}, state), { isTokenAutoRefreshEnabled }));
}
async function getToken2(appCheckInstance, forceRefresh) {
  const result = await getToken$2(appCheckInstance, forceRefresh);
  if (result.error) {
    throw result.error;
  }
  return { token: result.token };
}
function onTokenChanged(appCheckInstance, onNextOrObserver, onError, onCompletion) {
  let nextFn = () => {
  };
  let errorFn = () => {
  };
  if (onNextOrObserver.next != null) {
    nextFn = onNextOrObserver.next.bind(onNextOrObserver);
  } else {
    nextFn = onNextOrObserver;
  }
  if (onNextOrObserver.error != null) {
    errorFn = onNextOrObserver.error.bind(onNextOrObserver);
  } else if (onError) {
    errorFn = onError;
  }
  addTokenListener(appCheckInstance, "EXTERNAL", nextFn, errorFn);
  return () => removeTokenListener(appCheckInstance.app, nextFn);
}
var APP_CHECK_NAME = "app-check";
var APP_CHECK_NAME_INTERNAL = "app-check-internal";
function registerAppCheck() {
  _registerComponent(new Component(APP_CHECK_NAME, (container) => {
    const app = container.getProvider("app").getImmediate();
    const platformLoggerProvider = container.getProvider("platform-logger");
    return factory3(app, platformLoggerProvider);
  }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container, _identifier, _appcheckService) => {
    container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();
  }));
  _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, (container) => {
    const appCheck = container.getProvider("app-check").getImmediate();
    return internalFactory2(appCheck);
  }, "PUBLIC").setInstantiationMode("EXPLICIT"));
  registerVersion(name5, version5);
}
registerAppCheck();

// node_modules/@firebase/app-check-compat/dist/esm/index.esm2017.js
var name6 = "@firebase/app-check-compat";
var version6 = "0.2.3";
var ERRORS4 = {
  ["use-before-activation"]: "App Check is being used before activate() is called for FirebaseApp {$appName}. Call activate() before instantiating other Firebase services."
};
var ERROR_FACTORY5 = new ErrorFactory("appCheck", "AppCheck", ERRORS4);
var AppCheckService2 = class {
  constructor(app) {
    this.app = app;
  }
  activate(siteKeyOrProvider, isTokenAutoRefreshEnabled) {
    let provider;
    if (typeof siteKeyOrProvider === "string") {
      provider = new ReCaptchaV3Provider(siteKeyOrProvider);
    } else if (siteKeyOrProvider instanceof ReCaptchaEnterpriseProvider || siteKeyOrProvider instanceof ReCaptchaV3Provider || siteKeyOrProvider instanceof CustomProvider) {
      provider = siteKeyOrProvider;
    } else {
      provider = new CustomProvider({ getToken: siteKeyOrProvider.getToken });
    }
    this._delegate = initializeAppCheck(this.app, {
      provider,
      isTokenAutoRefreshEnabled
    });
  }
  setTokenAutoRefreshEnabled(isTokenAutoRefreshEnabled) {
    if (!this._delegate) {
      throw ERROR_FACTORY5.create("use-before-activation", {
        appName: this.app.name
      });
    }
    setTokenAutoRefreshEnabled(this._delegate, isTokenAutoRefreshEnabled);
  }
  getToken(forceRefresh) {
    if (!this._delegate) {
      throw ERROR_FACTORY5.create("use-before-activation", {
        appName: this.app.name
      });
    }
    return getToken2(this._delegate, forceRefresh);
  }
  onTokenChanged(onNextOrObserver, onError, onCompletion) {
    if (!this._delegate) {
      throw ERROR_FACTORY5.create("use-before-activation", {
        appName: this.app.name
      });
    }
    return onTokenChanged(this._delegate, onNextOrObserver, onError, onCompletion);
  }
};
var factory4 = (container) => {
  const app = container.getProvider("app-compat").getImmediate();
  return new AppCheckService2(app);
};
function registerAppCheck2() {
  firebase.INTERNAL.registerComponent(new Component("appCheck-compat", factory4, "PUBLIC").setServiceProps({
    ReCaptchaEnterpriseProvider,
    ReCaptchaV3Provider,
    CustomProvider
  }));
}
registerAppCheck2();
firebase.registerVersion(name6, version6);

// node_modules/@firebase/auth/dist/esm2017/internal.js
function _cordovaWindow() {
  return window;
}
var REDIRECT_TIMEOUT_MS = 2e3;
async function _generateHandlerUrl(auth, event, provider) {
  var _a2;
  const { BuildInfo } = _cordovaWindow();
  debugAssert(event.sessionId, "AuthEvent did not contain a session ID");
  const sessionDigest = await computeSha256(event.sessionId);
  const additionalParams = {};
  if (_isIOS()) {
    additionalParams["ibi"] = BuildInfo.packageName;
  } else if (_isAndroid()) {
    additionalParams["apn"] = BuildInfo.packageName;
  } else {
    _fail(auth, "operation-not-supported-in-this-environment");
  }
  if (BuildInfo.displayName) {
    additionalParams["appDisplayName"] = BuildInfo.displayName;
  }
  additionalParams["sessionId"] = sessionDigest;
  return _getRedirectUrl(auth, provider, event.type, void 0, (_a2 = event.eventId) !== null && _a2 !== void 0 ? _a2 : void 0, additionalParams);
}
async function _validateOrigin(auth) {
  const { BuildInfo } = _cordovaWindow();
  const request = {};
  if (_isIOS()) {
    request.iosBundleId = BuildInfo.packageName;
  } else if (_isAndroid()) {
    request.androidPackageName = BuildInfo.packageName;
  } else {
    _fail(auth, "operation-not-supported-in-this-environment");
  }
  await _getProjectConfig(auth, request);
}
function _performRedirect(handlerUrl) {
  const { cordova } = _cordovaWindow();
  return new Promise((resolve) => {
    cordova.plugins.browsertab.isAvailable((browserTabIsAvailable) => {
      let iabRef = null;
      if (browserTabIsAvailable) {
        cordova.plugins.browsertab.openUrl(handlerUrl);
      } else {
        iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? "_blank" : "_system", "location=yes");
      }
      resolve(iabRef);
    });
  });
}
async function _waitForAppResume(auth, eventListener, iabRef) {
  const { cordova } = _cordovaWindow();
  let cleanup = () => {
  };
  try {
    await new Promise((resolve, reject) => {
      let onCloseTimer = null;
      function authEventSeen() {
        var _a2;
        resolve();
        const closeBrowserTab = (_a2 = cordova.plugins.browsertab) === null || _a2 === void 0 ? void 0 : _a2.close;
        if (typeof closeBrowserTab === "function") {
          closeBrowserTab();
        }
        if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === "function") {
          iabRef.close();
        }
      }
      function resumed() {
        if (onCloseTimer) {
          return;
        }
        onCloseTimer = window.setTimeout(() => {
          reject(_createError(auth, "redirect-cancelled-by-user"));
        }, REDIRECT_TIMEOUT_MS);
      }
      function visibilityChanged() {
        if ((document === null || document === void 0 ? void 0 : document.visibilityState) === "visible") {
          resumed();
        }
      }
      eventListener.addPassiveListener(authEventSeen);
      document.addEventListener("resume", resumed, false);
      if (_isAndroid()) {
        document.addEventListener("visibilitychange", visibilityChanged, false);
      }
      cleanup = () => {
        eventListener.removePassiveListener(authEventSeen);
        document.removeEventListener("resume", resumed, false);
        document.removeEventListener("visibilitychange", visibilityChanged, false);
        if (onCloseTimer) {
          window.clearTimeout(onCloseTimer);
        }
      };
    });
  } finally {
    cleanup();
  }
}
function _checkCordovaConfiguration(auth) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const win = _cordovaWindow();
  _assert(typeof ((_a2 = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a2 === void 0 ? void 0 : _a2.subscribe) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-universal-links-plugin-fix"
  });
  _assert(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== "undefined", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-buildInfo"
  });
  _assert(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-inappbrowser"
  });
}
async function computeSha256(sessionId) {
  const bytes = stringToArrayBuffer(sessionId);
  const buf = await crypto.subtle.digest("SHA-256", bytes);
  const arr = Array.from(new Uint8Array(buf));
  return arr.map((num) => num.toString(16).padStart(2, "0")).join("");
}
function stringToArrayBuffer(str) {
  debugAssert(/[0-9a-zA-Z]+/.test(str), "Can only convert alpha-numeric strings");
  if (typeof TextEncoder !== "undefined") {
    return new TextEncoder().encode(str);
  }
  const buff = new ArrayBuffer(str.length);
  const view = new Uint8Array(buff);
  for (let i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }
  return view;
}
var SESSION_ID_LENGTH = 20;
var CordovaAuthEventManager = class extends AuthEventManager {
  constructor() {
    super(...arguments);
    this.passiveListeners = /* @__PURE__ */ new Set();
    this.initPromise = new Promise((resolve) => {
      this.resolveInialized = resolve;
    });
  }
  addPassiveListener(cb) {
    this.passiveListeners.add(cb);
  }
  removePassiveListener(cb) {
    this.passiveListeners.delete(cb);
  }
  resetRedirect() {
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
  }
  onEvent(event) {
    this.resolveInialized();
    this.passiveListeners.forEach((cb) => cb(event));
    return super.onEvent(event);
  }
  async initialized() {
    await this.initPromise;
  }
};
function _generateNewEvent(auth, type, eventId = null) {
  return {
    type,
    eventId,
    urlResponse: null,
    sessionId: generateSessionId(),
    postBody: null,
    tenantId: auth.tenantId,
    error: _createError(auth, "no-auth-event")
  };
}
function _savePartialEvent(auth, event) {
  return storage()._set(persistenceKey(auth), event);
}
async function _getAndRemoveEvent(auth) {
  const event = await storage()._get(persistenceKey(auth));
  if (event) {
    await storage()._remove(persistenceKey(auth));
  }
  return event;
}
function _eventFromPartialAndUrl(partialEvent, url) {
  var _a2, _b;
  const callbackUrl = _getDeepLinkFromCallback(url);
  if (callbackUrl.includes("/__/auth/callback")) {
    const params = searchParamsOrEmpty(callbackUrl);
    const errorObject = params["firebaseError"] ? parseJsonOrNull(decodeURIComponent(params["firebaseError"])) : null;
    const code = (_b = (_a2 = errorObject === null || errorObject === void 0 ? void 0 : errorObject["code"]) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")) === null || _b === void 0 ? void 0 : _b[1];
    const error = code ? _createError(code) : null;
    if (error) {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        error,
        urlResponse: null,
        sessionId: null,
        postBody: null
      };
    } else {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        sessionId: partialEvent.sessionId,
        urlResponse: callbackUrl,
        postBody: null
      };
    }
  }
  return null;
}
function generateSessionId() {
  const chars = [];
  const allowedChars = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let i = 0; i < SESSION_ID_LENGTH; i++) {
    const idx = Math.floor(Math.random() * allowedChars.length);
    chars.push(allowedChars.charAt(idx));
  }
  return chars.join("");
}
function storage() {
  return _getInstance(browserLocalPersistence);
}
function persistenceKey(auth) {
  return _persistenceKeyName("authEvent", auth.config.apiKey, auth.name);
}
function parseJsonOrNull(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
function _getDeepLinkFromCallback(url) {
  const params = searchParamsOrEmpty(url);
  const link = params["link"] ? decodeURIComponent(params["link"]) : void 0;
  const doubleDeepLink = searchParamsOrEmpty(link)["link"];
  const iOSDeepLink = params["deep_link_id"] ? decodeURIComponent(params["deep_link_id"]) : void 0;
  const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)["link"];
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
function searchParamsOrEmpty(url) {
  if (!(url === null || url === void 0 ? void 0 : url.includes("?"))) {
    return {};
  }
  const [_, ...rest] = url.split("?");
  return querystringDecode(rest.join("?"));
}
var INITIAL_EVENT_TIMEOUT_MS = 500;
var CordovaPopupRedirectResolver = class {
  constructor() {
    this._redirectPersistence = browserSessionPersistence;
    this._shouldInitProactively = true;
    this.eventManagers = /* @__PURE__ */ new Map();
    this.originValidationPromises = {};
    this._completeRedirectFn = _getRedirectResult;
  }
  async _initialize(auth) {
    const key = auth._key();
    let manager = this.eventManagers.get(key);
    if (!manager) {
      manager = new CordovaAuthEventManager(auth);
      this.eventManagers.set(key, manager);
      this.attachCallbackListeners(auth, manager);
    }
    return manager;
  }
  _openPopup(auth) {
    _fail(auth, "operation-not-supported-in-this-environment");
  }
  async _openRedirect(auth, provider, authType, eventId) {
    _checkCordovaConfiguration(auth);
    const manager = await this._initialize(auth);
    await manager.initialized();
    manager.resetRedirect();
    _clearRedirectOutcomes();
    await this._originValidation(auth);
    const event = _generateNewEvent(auth, authType, eventId);
    await _savePartialEvent(auth, event);
    const url = await _generateHandlerUrl(auth, event, provider);
    const iabRef = await _performRedirect(url);
    return _waitForAppResume(auth, manager, iabRef);
  }
  _isIframeWebStorageSupported(_auth, _cb) {
    throw new Error("Method not implemented.");
  }
  _originValidation(auth) {
    const key = auth._key();
    if (!this.originValidationPromises[key]) {
      this.originValidationPromises[key] = _validateOrigin(auth);
    }
    return this.originValidationPromises[key];
  }
  attachCallbackListeners(auth, manager) {
    const { universalLinks, handleOpenURL, BuildInfo } = _cordovaWindow();
    const noEventTimeout = setTimeout(async () => {
      await _getAndRemoveEvent(auth);
      manager.onEvent(generateNoEvent());
    }, INITIAL_EVENT_TIMEOUT_MS);
    const universalLinksCb = async (eventData) => {
      clearTimeout(noEventTimeout);
      const partialEvent = await _getAndRemoveEvent(auth);
      let finalEvent = null;
      if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData["url"])) {
        finalEvent = _eventFromPartialAndUrl(partialEvent, eventData["url"]);
      }
      manager.onEvent(finalEvent || generateNoEvent());
    };
    if (typeof universalLinks !== "undefined" && typeof universalLinks.subscribe === "function") {
      universalLinks.subscribe(null, universalLinksCb);
    }
    const existingHandleOpenURL = handleOpenURL;
    const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;
    _cordovaWindow().handleOpenURL = async (url) => {
      if (url.toLowerCase().startsWith(packagePrefix)) {
        universalLinksCb({ url });
      }
      if (typeof existingHandleOpenURL === "function") {
        try {
          existingHandleOpenURL(url);
        } catch (e) {
          console.error(e);
        }
      }
    };
  }
};
var cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;
function generateNoEvent() {
  return {
    type: "unknown",
    eventId: null,
    sessionId: null,
    urlResponse: null,
    postBody: null,
    tenantId: null,
    error: _createError("no-auth-event")
  };
}
function addFrameworkForLogging(auth, framework) {
  _castAuth(auth)._logFramework(framework);
}

// node_modules/@firebase/auth-compat/dist/index.esm2017.js
var name7 = "@firebase/auth-compat";
var version7 = "0.2.9";
var CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1e3;
function _getCurrentScheme() {
  var _a2;
  return ((_a2 = self === null || self === void 0 ? void 0 : self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _isAndroidOrIosCordovaScheme(ua = getUA()) {
  return !!((_getCurrentScheme() === "file:" || _getCurrentScheme() === "ionic:") && ua.toLowerCase().match(/iphone|ipad|ipod|android/));
}
function _isNativeEnvironment() {
  return isReactNative() || isNode();
}
function _isIe11() {
  return isIE() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
function _isEdge(ua = getUA()) {
  return /Edge\/\d+/.test(ua);
}
function _isLocalStorageNotSynchronized(ua = getUA()) {
  return _isIe11() || _isEdge(ua);
}
function _isWebStorageSupported() {
  try {
    const storage2 = self.localStorage;
    const key = _generateEventId();
    if (storage2) {
      storage2["setItem"](key, "1");
      storage2["removeItem"](key);
      if (_isLocalStorageNotSynchronized()) {
        return isIndexedDBAvailable();
      }
      return true;
    }
  } catch (e) {
    return _isWorker() && isIndexedDBAvailable();
  }
  return false;
}
function _isWorker() {
  return typeof global !== "undefined" && "WorkerGlobalScope" in global && "importScripts" in global;
}
function _isPopupRedirectSupported() {
  return (_isHttpOrHttps() || isBrowserExtension() || _isAndroidOrIosCordovaScheme()) && !_isNativeEnvironment() && _isWebStorageSupported() && !_isWorker();
}
function _isLikelyCordova() {
  return _isAndroidOrIosCordovaScheme() && typeof document !== "undefined";
}
async function _isCordova() {
  if (!_isLikelyCordova()) {
    return false;
  }
  return new Promise((resolve) => {
    const timeoutId = setTimeout(() => {
      resolve(false);
    }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
    document.addEventListener("deviceready", () => {
      clearTimeout(timeoutId);
      resolve(true);
    });
  });
}
function _getSelfWindow() {
  return typeof window !== "undefined" ? window : null;
}
var Persistence = {
  LOCAL: "local",
  NONE: "none",
  SESSION: "session"
};
var _assert$3 = _assert;
var PERSISTENCE_KEY = "persistence";
function _validatePersistenceArgument(auth, persistence) {
  _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type");
  if (isReactNative()) {
    _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type");
    return;
  }
  if (isNode()) {
    _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type");
    return;
  }
  if (_isWorker()) {
    _assert$3(persistence === Persistence.NONE || persistence === Persistence.LOCAL && isIndexedDBAvailable(), auth, "unsupported-persistence-type");
    return;
  }
  _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type");
}
async function _savePersistenceForRedirect(auth) {
  await auth._initializationPromise;
  const session = getSessionStorageIfAvailable();
  const key = _persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);
  if (session) {
    session.setItem(key, auth._getPersistence());
  }
}
function _getPersistencesFromRedirect(apiKey, appName) {
  const session = getSessionStorageIfAvailable();
  if (!session) {
    return [];
  }
  const key = _persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);
  const persistence = session.getItem(key);
  switch (persistence) {
    case Persistence.NONE:
      return [inMemoryPersistence];
    case Persistence.LOCAL:
      return [indexedDBLocalPersistence, browserSessionPersistence];
    case Persistence.SESSION:
      return [browserSessionPersistence];
    default:
      return [];
  }
}
function getSessionStorageIfAvailable() {
  var _a2;
  try {
    return ((_a2 = _getSelfWindow()) === null || _a2 === void 0 ? void 0 : _a2.sessionStorage) || null;
  } catch (e) {
    return null;
  }
}
var _assert$2 = _assert;
var CompatPopupRedirectResolver = class {
  constructor() {
    this.browserResolver = _getInstance(browserPopupRedirectResolver);
    this.cordovaResolver = _getInstance(cordovaPopupRedirectResolver);
    this.underlyingResolver = null;
    this._redirectPersistence = browserSessionPersistence;
    this._completeRedirectFn = _getRedirectResult;
  }
  async _initialize(auth) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._initialize(auth);
  }
  async _openPopup(auth, provider, authType, eventId) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);
  }
  async _openRedirect(auth, provider, authType, eventId) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);
  }
  _isIframeWebStorageSupported(auth, cb) {
    this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);
  }
  _originValidation(auth) {
    return this.assertedUnderlyingResolver._originValidation(auth);
  }
  get _shouldInitProactively() {
    return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
  }
  get assertedUnderlyingResolver() {
    _assert$2(this.underlyingResolver, "internal-error");
    return this.underlyingResolver;
  }
  async selectUnderlyingResolver() {
    if (this.underlyingResolver) {
      return;
    }
    const isCordova = await _isCordova();
    this.underlyingResolver = isCordova ? this.cordovaResolver : this.browserResolver;
  }
};
function unwrap(object) {
  return object.unwrap();
}
function wrapped(object) {
  return object.wrapped();
}
function credentialFromResponse(userCredential) {
  return credentialFromObject(userCredential);
}
function attachExtraErrorFields(auth, e) {
  var _a2;
  const response = (_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2._tokenResponse;
  if (e.code === "auth/multi-factor-auth-required") {
    const mfaErr = e;
    mfaErr.resolver = new MultiFactorResolver(auth, getMultiFactorResolver(auth, e));
  } else if (response) {
    const credential = credentialFromObject(e);
    const credErr = e;
    if (credential) {
      credErr.credential = credential;
      credErr.tenantId = response.tenantId || void 0;
      credErr.email = response.email || void 0;
      credErr.phoneNumber = response.phoneNumber || void 0;
    }
  }
}
function credentialFromObject(object) {
  const { _tokenResponse } = object instanceof FirebaseError ? object.customData : object;
  if (!_tokenResponse) {
    return null;
  }
  if (!(object instanceof FirebaseError)) {
    if ("temporaryProof" in _tokenResponse && "phoneNumber" in _tokenResponse) {
      return PhoneAuthProvider.credentialFromResult(object);
    }
  }
  const providerId = _tokenResponse.providerId;
  if (!providerId || providerId === ProviderId.PASSWORD) {
    return null;
  }
  let provider;
  switch (providerId) {
    case ProviderId.GOOGLE:
      provider = GoogleAuthProvider;
      break;
    case ProviderId.FACEBOOK:
      provider = FacebookAuthProvider;
      break;
    case ProviderId.GITHUB:
      provider = GithubAuthProvider;
      break;
    case ProviderId.TWITTER:
      provider = TwitterAuthProvider;
      break;
    default:
      const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce } = _tokenResponse;
      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
        return null;
      }
      if (pendingToken) {
        if (providerId.startsWith("saml.")) {
          return SAMLAuthCredential._create(providerId, pendingToken);
        } else {
          return OAuthCredential._fromParams({
            providerId,
            signInMethod: providerId,
            pendingToken,
            idToken: oauthIdToken,
            accessToken: oauthAccessToken
          });
        }
      }
      return new OAuthProvider(providerId).credential({
        idToken: oauthIdToken,
        accessToken: oauthAccessToken,
        rawNonce: nonce
      });
  }
  return object instanceof FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);
}
function convertCredential(auth, credentialPromise) {
  return credentialPromise.catch((e) => {
    if (e instanceof FirebaseError) {
      attachExtraErrorFields(auth, e);
    }
    throw e;
  }).then((credential) => {
    const operationType = credential.operationType;
    const user = credential.user;
    return {
      operationType,
      credential: credentialFromResponse(credential),
      additionalUserInfo: getAdditionalUserInfo(credential),
      user: User.getOrCreate(user)
    };
  });
}
async function convertConfirmationResult(auth, confirmationResultPromise) {
  const confirmationResultExp = await confirmationResultPromise;
  return {
    verificationId: confirmationResultExp.verificationId,
    confirm: (verificationCode) => convertCredential(auth, confirmationResultExp.confirm(verificationCode))
  };
}
var MultiFactorResolver = class {
  constructor(auth, resolver) {
    this.resolver = resolver;
    this.auth = wrapped(auth);
  }
  get session() {
    return this.resolver.session;
  }
  get hints() {
    return this.resolver.hints;
  }
  resolveSignIn(assertion) {
    return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
  }
};
var User = class {
  constructor(_delegate) {
    this._delegate = _delegate;
    this.multiFactor = multiFactor(_delegate);
  }
  static getOrCreate(user) {
    if (!User.USER_MAP.has(user)) {
      User.USER_MAP.set(user, new User(user));
    }
    return User.USER_MAP.get(user);
  }
  delete() {
    return this._delegate.delete();
  }
  reload() {
    return this._delegate.reload();
  }
  toJSON() {
    return this._delegate.toJSON();
  }
  getIdTokenResult(forceRefresh) {
    return this._delegate.getIdTokenResult(forceRefresh);
  }
  getIdToken(forceRefresh) {
    return this._delegate.getIdToken(forceRefresh);
  }
  linkAndRetrieveDataWithCredential(credential) {
    return this.linkWithCredential(credential);
  }
  async linkWithCredential(credential) {
    return convertCredential(this.auth, linkWithCredential(this._delegate, credential));
  }
  async linkWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, linkWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  async linkWithPopup(provider) {
    return convertCredential(this.auth, linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async linkWithRedirect(provider) {
    await _savePersistenceForRedirect(_castAuth(this.auth));
    return linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  reauthenticateAndRetrieveDataWithCredential(credential) {
    return this.reauthenticateWithCredential(credential);
  }
  async reauthenticateWithCredential(credential) {
    return convertCredential(this.auth, reauthenticateWithCredential(this._delegate, credential));
  }
  reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  reauthenticateWithPopup(provider) {
    return convertCredential(this.auth, reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async reauthenticateWithRedirect(provider) {
    await _savePersistenceForRedirect(_castAuth(this.auth));
    return reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  sendEmailVerification(actionCodeSettings) {
    return sendEmailVerification(this._delegate, actionCodeSettings);
  }
  async unlink(providerId) {
    await unlink(this._delegate, providerId);
    return this;
  }
  updateEmail(newEmail) {
    return updateEmail(this._delegate, newEmail);
  }
  updatePassword(newPassword) {
    return updatePassword(this._delegate, newPassword);
  }
  updatePhoneNumber(phoneCredential) {
    return updatePhoneNumber(this._delegate, phoneCredential);
  }
  updateProfile(profile) {
    return updateProfile(this._delegate, profile);
  }
  verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
    return verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
  }
  get emailVerified() {
    return this._delegate.emailVerified;
  }
  get isAnonymous() {
    return this._delegate.isAnonymous;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get phoneNumber() {
    return this._delegate.phoneNumber;
  }
  get providerData() {
    return this._delegate.providerData;
  }
  get refreshToken() {
    return this._delegate.refreshToken;
  }
  get tenantId() {
    return this._delegate.tenantId;
  }
  get displayName() {
    return this._delegate.displayName;
  }
  get email() {
    return this._delegate.email;
  }
  get photoURL() {
    return this._delegate.photoURL;
  }
  get providerId() {
    return this._delegate.providerId;
  }
  get uid() {
    return this._delegate.uid;
  }
  get auth() {
    return this._delegate.auth;
  }
};
User.USER_MAP = /* @__PURE__ */ new WeakMap();
var _assert$1 = _assert;
var Auth = class {
  constructor(app, provider) {
    this.app = app;
    if (provider.isInitialized()) {
      this._delegate = provider.getImmediate();
      this.linkUnderlyingAuth();
      return;
    }
    const { apiKey } = app.options;
    _assert$1(apiKey, "invalid-api-key", {
      appName: app.name
    });
    _assert$1(apiKey, "invalid-api-key", {
      appName: app.name
    });
    const resolver = typeof window !== "undefined" ? CompatPopupRedirectResolver : void 0;
    this._delegate = provider.initialize({
      options: {
        persistence: buildPersistenceHierarchy(apiKey, app.name),
        popupRedirectResolver: resolver
      }
    });
    this._delegate._updateErrorMap(debugErrorMap);
    this.linkUnderlyingAuth();
  }
  get emulatorConfig() {
    return this._delegate.emulatorConfig;
  }
  get currentUser() {
    if (!this._delegate.currentUser) {
      return null;
    }
    return User.getOrCreate(this._delegate.currentUser);
  }
  get languageCode() {
    return this._delegate.languageCode;
  }
  set languageCode(languageCode) {
    this._delegate.languageCode = languageCode;
  }
  get settings() {
    return this._delegate.settings;
  }
  get tenantId() {
    return this._delegate.tenantId;
  }
  set tenantId(tid) {
    this._delegate.tenantId = tid;
  }
  useDeviceLanguage() {
    this._delegate.useDeviceLanguage();
  }
  signOut() {
    return this._delegate.signOut();
  }
  useEmulator(url, options) {
    connectAuthEmulator(this._delegate, url, options);
  }
  applyActionCode(code) {
    return applyActionCode(this._delegate, code);
  }
  checkActionCode(code) {
    return checkActionCode(this._delegate, code);
  }
  confirmPasswordReset(code, newPassword) {
    return confirmPasswordReset(this._delegate, code, newPassword);
  }
  async createUserWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, createUserWithEmailAndPassword(this._delegate, email, password));
  }
  fetchProvidersForEmail(email) {
    return this.fetchSignInMethodsForEmail(email);
  }
  fetchSignInMethodsForEmail(email) {
    return fetchSignInMethodsForEmail(this._delegate, email);
  }
  isSignInWithEmailLink(emailLink) {
    return isSignInWithEmailLink(this._delegate, emailLink);
  }
  async getRedirectResult() {
    _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    const credential = await getRedirectResult(this._delegate, CompatPopupRedirectResolver);
    if (!credential) {
      return {
        credential: null,
        user: null
      };
    }
    return convertCredential(this._delegate, Promise.resolve(credential));
  }
  addFrameworkForLogging(framework) {
    addFrameworkForLogging(this._delegate, framework);
  }
  onAuthStateChanged(nextOrObserver, errorFn, completed) {
    const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onAuthStateChanged(next, error, complete);
  }
  onIdTokenChanged(nextOrObserver, errorFn, completed) {
    const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onIdTokenChanged(next, error, complete);
  }
  sendSignInLinkToEmail(email, actionCodeSettings) {
    return sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);
  }
  sendPasswordResetEmail(email, actionCodeSettings) {
    return sendPasswordResetEmail(this._delegate, email, actionCodeSettings || void 0);
  }
  async setPersistence(persistence) {
    _validatePersistenceArgument(this._delegate, persistence);
    let converted;
    switch (persistence) {
      case Persistence.SESSION:
        converted = browserSessionPersistence;
        break;
      case Persistence.LOCAL:
        const isIndexedDBFullySupported = await _getInstance(indexedDBLocalPersistence)._isAvailable();
        converted = isIndexedDBFullySupported ? indexedDBLocalPersistence : browserLocalPersistence;
        break;
      case Persistence.NONE:
        converted = inMemoryPersistence;
        break;
      default:
        return _fail("argument-error", {
          appName: this._delegate.name
        });
    }
    return this._delegate.setPersistence(converted);
  }
  signInAndRetrieveDataWithCredential(credential) {
    return this.signInWithCredential(credential);
  }
  signInAnonymously() {
    return convertCredential(this._delegate, signInAnonymously(this._delegate));
  }
  signInWithCredential(credential) {
    return convertCredential(this._delegate, signInWithCredential(this._delegate, credential));
  }
  signInWithCustomToken(token) {
    return convertCredential(this._delegate, signInWithCustomToken(this._delegate, token));
  }
  signInWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, signInWithEmailAndPassword(this._delegate, email, password));
  }
  signInWithEmailLink(email, emailLink) {
    return convertCredential(this._delegate, signInWithEmailLink(this._delegate, email, emailLink));
  }
  signInWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this._delegate, signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  async signInWithPopup(provider) {
    _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    return convertCredential(this._delegate, signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async signInWithRedirect(provider) {
    _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    await _savePersistenceForRedirect(this._delegate);
    return signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  updateCurrentUser(user) {
    return this._delegate.updateCurrentUser(user);
  }
  verifyPasswordResetCode(code) {
    return verifyPasswordResetCode(this._delegate, code);
  }
  unwrap() {
    return this._delegate;
  }
  _delete() {
    return this._delegate._delete();
  }
  linkUnderlyingAuth() {
    this._delegate.wrapped = () => this;
  }
};
Auth.Persistence = Persistence;
function wrapObservers(nextOrObserver, error, complete) {
  let next = nextOrObserver;
  if (typeof nextOrObserver !== "function") {
    ({ next, error, complete } = nextOrObserver);
  }
  const oldNext = next;
  const newNext = (user) => oldNext(user && User.getOrCreate(user));
  return {
    next: newNext,
    error,
    complete
  };
}
function buildPersistenceHierarchy(apiKey, appName) {
  const persistences = _getPersistencesFromRedirect(apiKey, appName);
  if (typeof self !== "undefined" && !persistences.includes(indexedDBLocalPersistence)) {
    persistences.push(indexedDBLocalPersistence);
  }
  if (typeof window !== "undefined") {
    for (const persistence of [
      browserLocalPersistence,
      browserSessionPersistence
    ]) {
      if (!persistences.includes(persistence)) {
        persistences.push(persistence);
      }
    }
  }
  if (!persistences.includes(inMemoryPersistence)) {
    persistences.push(inMemoryPersistence);
  }
  return persistences;
}
var PhoneAuthProvider2 = class {
  constructor() {
    this.providerId = "phone";
    this._delegate = new PhoneAuthProvider(unwrap(firebase.auth()));
  }
  static credential(verificationId, verificationCode) {
    return PhoneAuthProvider.credential(verificationId, verificationCode);
  }
  verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
    return this._delegate.verifyPhoneNumber(phoneInfoOptions, applicationVerifier);
  }
  unwrap() {
    return this._delegate;
  }
};
PhoneAuthProvider2.PHONE_SIGN_IN_METHOD = PhoneAuthProvider.PHONE_SIGN_IN_METHOD;
PhoneAuthProvider2.PROVIDER_ID = PhoneAuthProvider.PROVIDER_ID;
var _assert2 = _assert;
var RecaptchaVerifier2 = class {
  constructor(container, parameters, app = firebase.app()) {
    var _a2;
    _assert2((_a2 = app.options) === null || _a2 === void 0 ? void 0 : _a2.apiKey, "invalid-api-key", {
      appName: app.name
    });
    this._delegate = new RecaptchaVerifier(container, parameters, app.auth());
    this.type = this._delegate.type;
  }
  clear() {
    this._delegate.clear();
  }
  render() {
    return this._delegate.render();
  }
  verify() {
    return this._delegate.verify();
  }
};
var AUTH_TYPE = "auth-compat";
function registerAuthCompat(instance) {
  instance.INTERNAL.registerComponent(new Component(AUTH_TYPE, (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const authProvider = container.getProvider("auth");
    return new Auth(app, authProvider);
  }, "PUBLIC").setServiceProps({
    ActionCodeInfo: {
      Operation: {
        EMAIL_SIGNIN: ActionCodeOperation.EMAIL_SIGNIN,
        PASSWORD_RESET: ActionCodeOperation.PASSWORD_RESET,
        RECOVER_EMAIL: ActionCodeOperation.RECOVER_EMAIL,
        REVERT_SECOND_FACTOR_ADDITION: ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
        VERIFY_AND_CHANGE_EMAIL: ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
        VERIFY_EMAIL: ActionCodeOperation.VERIFY_EMAIL
      }
    },
    EmailAuthProvider,
    FacebookAuthProvider,
    GithubAuthProvider,
    GoogleAuthProvider,
    OAuthProvider,
    SAMLAuthProvider,
    PhoneAuthProvider: PhoneAuthProvider2,
    PhoneMultiFactorGenerator,
    RecaptchaVerifier: RecaptchaVerifier2,
    TwitterAuthProvider,
    Auth,
    AuthCredential,
    Error: FirebaseError
  }).setInstantiationMode("LAZY").setMultipleInstances(false));
  instance.registerVersion(name7, version7);
}
registerAuthCompat(firebase);

// node_modules/@firebase/database-compat/dist/index.esm2017.js
var name8 = "@firebase/database-compat";
var version8 = "0.1.5";
var logClient = new Logger("@firebase/database-compat");
var warn = function(msg) {
  const message = "FIREBASE WARNING: " + msg;
  logClient.warn(message);
};
var validateBoolean = function(fnName, argumentName, bool, optional) {
  if (optional && bool === void 0) {
    return;
  }
  if (typeof bool !== "boolean") {
    throw new Error(errorPrefix(fnName, argumentName) + "must be a boolean.");
  }
};
var validateEventType = function(fnName, eventType, optional) {
  if (optional && eventType === void 0) {
    return;
  }
  switch (eventType) {
    case "value":
    case "child_added":
    case "child_removed":
    case "child_changed":
    case "child_moved":
      break;
    default:
      throw new Error(errorPrefix(fnName, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
  }
};
var OnDisconnect2 = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  cancel(onComplete) {
    validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
    validateCallback("OnDisconnect.cancel", "onComplete", onComplete, true);
    const result = this._delegate.cancel();
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  remove(onComplete) {
    validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
    validateCallback("OnDisconnect.remove", "onComplete", onComplete, true);
    const result = this._delegate.remove();
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  set(value, onComplete) {
    validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
    validateCallback("OnDisconnect.set", "onComplete", onComplete, true);
    const result = this._delegate.set(value);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  setWithPriority(value, priority, onComplete) {
    validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
    validateCallback("OnDisconnect.setWithPriority", "onComplete", onComplete, true);
    const result = this._delegate.setWithPriority(value, priority);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  update(objectToMerge, onComplete) {
    validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
    if (Array.isArray(objectToMerge)) {
      const newObjectToMerge = {};
      for (let i = 0; i < objectToMerge.length; ++i) {
        newObjectToMerge["" + i] = objectToMerge[i];
      }
      objectToMerge = newObjectToMerge;
      warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
    }
    validateCallback("OnDisconnect.update", "onComplete", onComplete, true);
    const result = this._delegate.update(objectToMerge);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
};
var TransactionResult = class {
  constructor(committed, snapshot) {
    this.committed = committed;
    this.snapshot = snapshot;
  }
  toJSON() {
    validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
    return { committed: this.committed, snapshot: this.snapshot.toJSON() };
  }
};
var DataSnapshot = class {
  constructor(_database, _delegate) {
    this._database = _database;
    this._delegate = _delegate;
  }
  val() {
    validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
    return this._delegate.val();
  }
  exportVal() {
    validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
    return this._delegate.exportVal();
  }
  toJSON() {
    validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
    return this._delegate.toJSON();
  }
  exists() {
    validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
    return this._delegate.exists();
  }
  child(path) {
    validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
    path = String(path);
    validatePathString("DataSnapshot.child", "path", path, false);
    return new DataSnapshot(this._database, this._delegate.child(path));
  }
  hasChild(path) {
    validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
    validatePathString("DataSnapshot.hasChild", "path", path, false);
    return this._delegate.hasChild(path);
  }
  getPriority() {
    validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
    return this._delegate.priority;
  }
  forEach(action) {
    validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
    validateCallback("DataSnapshot.forEach", "action", action, false);
    return this._delegate.forEach((expDataSnapshot) => action(new DataSnapshot(this._database, expDataSnapshot)));
  }
  hasChildren() {
    validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
    return this._delegate.hasChildren();
  }
  get key() {
    return this._delegate.key;
  }
  numChildren() {
    validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
    return this._delegate.size;
  }
  getRef() {
    validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
    return new Reference(this._database, this._delegate.ref);
  }
  get ref() {
    return this.getRef();
  }
};
var Query = class {
  constructor(database, _delegate) {
    this.database = database;
    this._delegate = _delegate;
  }
  on(eventType, callback, cancelCallbackOrContext, context) {
    var _a2;
    validateArgCount("Query.on", 2, 4, arguments.length);
    validateCallback("Query.on", "callback", callback, false);
    const ret = Query.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context);
    const valueCallback = (expSnapshot, previousChildName) => {
      callback.call(ret.context, new DataSnapshot(this.database, expSnapshot), previousChildName);
    };
    valueCallback.userCallback = callback;
    valueCallback.context = ret.context;
    const cancelCallback = (_a2 = ret.cancel) === null || _a2 === void 0 ? void 0 : _a2.bind(ret.context);
    switch (eventType) {
      case "value":
        onValue(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_added":
        onChildAdded(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_removed":
        onChildRemoved(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_changed":
        onChildChanged(this._delegate, valueCallback, cancelCallback);
        return callback;
      case "child_moved":
        onChildMoved(this._delegate, valueCallback, cancelCallback);
        return callback;
      default:
        throw new Error(errorPrefix("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
    }
  }
  off(eventType, callback, context) {
    validateArgCount("Query.off", 0, 3, arguments.length);
    validateEventType("Query.off", eventType, true);
    validateCallback("Query.off", "callback", callback, true);
    validateContextObject("Query.off", "context", context, true);
    if (callback) {
      const valueCallback = () => {
      };
      valueCallback.userCallback = callback;
      valueCallback.context = context;
      off(this._delegate, eventType, valueCallback);
    } else {
      off(this._delegate, eventType);
    }
  }
  get() {
    return get(this._delegate).then((expSnapshot) => {
      return new DataSnapshot(this.database, expSnapshot);
    });
  }
  once(eventType, callback, failureCallbackOrContext, context) {
    validateArgCount("Query.once", 1, 4, arguments.length);
    validateCallback("Query.once", "callback", callback, true);
    const ret = Query.getCancelAndContextArgs_("Query.once", failureCallbackOrContext, context);
    const deferred = new Deferred();
    const valueCallback = (expSnapshot, previousChildName) => {
      const result = new DataSnapshot(this.database, expSnapshot);
      if (callback) {
        callback.call(ret.context, result, previousChildName);
      }
      deferred.resolve(result);
    };
    valueCallback.userCallback = callback;
    valueCallback.context = ret.context;
    const cancelCallback = (error) => {
      if (ret.cancel) {
        ret.cancel.call(ret.context, error);
      }
      deferred.reject(error);
    };
    switch (eventType) {
      case "value":
        onValue(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_added":
        onChildAdded(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_removed":
        onChildRemoved(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_changed":
        onChildChanged(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      case "child_moved":
        onChildMoved(this._delegate, valueCallback, cancelCallback, {
          onlyOnce: true
        });
        break;
      default:
        throw new Error(errorPrefix("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
    }
    return deferred.promise;
  }
  limitToFirst(limit) {
    validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
    return new Query(this.database, query(this._delegate, limitToFirst(limit)));
  }
  limitToLast(limit) {
    validateArgCount("Query.limitToLast", 1, 1, arguments.length);
    return new Query(this.database, query(this._delegate, limitToLast(limit)));
  }
  orderByChild(path) {
    validateArgCount("Query.orderByChild", 1, 1, arguments.length);
    return new Query(this.database, query(this._delegate, orderByChild(path)));
  }
  orderByKey() {
    validateArgCount("Query.orderByKey", 0, 0, arguments.length);
    return new Query(this.database, query(this._delegate, orderByKey()));
  }
  orderByPriority() {
    validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
    return new Query(this.database, query(this._delegate, orderByPriority()));
  }
  orderByValue() {
    validateArgCount("Query.orderByValue", 0, 0, arguments.length);
    return new Query(this.database, query(this._delegate, orderByValue()));
  }
  startAt(value = null, name21) {
    validateArgCount("Query.startAt", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, startAt(value, name21)));
  }
  startAfter(value = null, name21) {
    validateArgCount("Query.startAfter", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, startAfter(value, name21)));
  }
  endAt(value = null, name21) {
    validateArgCount("Query.endAt", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, endAt(value, name21)));
  }
  endBefore(value = null, name21) {
    validateArgCount("Query.endBefore", 0, 2, arguments.length);
    return new Query(this.database, query(this._delegate, endBefore(value, name21)));
  }
  equalTo(value, name21) {
    validateArgCount("Query.equalTo", 1, 2, arguments.length);
    return new Query(this.database, query(this._delegate, equalTo(value, name21)));
  }
  toString() {
    validateArgCount("Query.toString", 0, 0, arguments.length);
    return this._delegate.toString();
  }
  toJSON() {
    validateArgCount("Query.toJSON", 0, 1, arguments.length);
    return this._delegate.toJSON();
  }
  isEqual(other) {
    validateArgCount("Query.isEqual", 1, 1, arguments.length);
    if (!(other instanceof Query)) {
      const error = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
      throw new Error(error);
    }
    return this._delegate.isEqual(other._delegate);
  }
  static getCancelAndContextArgs_(fnName, cancelOrContext, context) {
    const ret = { cancel: void 0, context: void 0 };
    if (cancelOrContext && context) {
      ret.cancel = cancelOrContext;
      validateCallback(fnName, "cancel", ret.cancel, true);
      ret.context = context;
      validateContextObject(fnName, "context", ret.context, true);
    } else if (cancelOrContext) {
      if (typeof cancelOrContext === "object" && cancelOrContext !== null) {
        ret.context = cancelOrContext;
      } else if (typeof cancelOrContext === "function") {
        ret.cancel = cancelOrContext;
      } else {
        throw new Error(errorPrefix(fnName, "cancelOrContext") + " must either be a cancel callback or a context object.");
      }
    }
    return ret;
  }
  get ref() {
    return new Reference(this.database, new ReferenceImpl(this._delegate._repo, this._delegate._path));
  }
};
var Reference = class extends Query {
  constructor(database, _delegate) {
    super(database, new QueryImpl(_delegate._repo, _delegate._path, new QueryParams(), false));
    this.database = database;
    this._delegate = _delegate;
  }
  getKey() {
    validateArgCount("Reference.key", 0, 0, arguments.length);
    return this._delegate.key;
  }
  child(pathString) {
    validateArgCount("Reference.child", 1, 1, arguments.length);
    if (typeof pathString === "number") {
      pathString = String(pathString);
    }
    return new Reference(this.database, child(this._delegate, pathString));
  }
  getParent() {
    validateArgCount("Reference.parent", 0, 0, arguments.length);
    const parent2 = this._delegate.parent;
    return parent2 ? new Reference(this.database, parent2) : null;
  }
  getRoot() {
    validateArgCount("Reference.root", 0, 0, arguments.length);
    return new Reference(this.database, this._delegate.root);
  }
  set(newVal, onComplete) {
    validateArgCount("Reference.set", 1, 2, arguments.length);
    validateCallback("Reference.set", "onComplete", onComplete, true);
    const result = set(this._delegate, newVal);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  update(values, onComplete) {
    validateArgCount("Reference.update", 1, 2, arguments.length);
    if (Array.isArray(values)) {
      const newObjectToMerge = {};
      for (let i = 0; i < values.length; ++i) {
        newObjectToMerge["" + i] = values[i];
      }
      values = newObjectToMerge;
      warn("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
    }
    validateWritablePath("Reference.update", this._delegate._path);
    validateCallback("Reference.update", "onComplete", onComplete, true);
    const result = update(this._delegate, values);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  setWithPriority(newVal, newPriority, onComplete) {
    validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
    validateCallback("Reference.setWithPriority", "onComplete", onComplete, true);
    const result = setWithPriority(this._delegate, newVal, newPriority);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  remove(onComplete) {
    validateArgCount("Reference.remove", 0, 1, arguments.length);
    validateCallback("Reference.remove", "onComplete", onComplete, true);
    const result = remove(this._delegate);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  transaction(transactionUpdate, onComplete, applyLocally) {
    validateArgCount("Reference.transaction", 1, 3, arguments.length);
    validateCallback("Reference.transaction", "transactionUpdate", transactionUpdate, false);
    validateCallback("Reference.transaction", "onComplete", onComplete, true);
    validateBoolean("Reference.transaction", "applyLocally", applyLocally, true);
    const result = runTransaction(this._delegate, transactionUpdate, {
      applyLocally
    }).then((transactionResult) => new TransactionResult(transactionResult.committed, new DataSnapshot(this.database, transactionResult.snapshot)));
    if (onComplete) {
      result.then((transactionResult) => onComplete(null, transactionResult.committed, transactionResult.snapshot), (error) => onComplete(error, false, null));
    }
    return result;
  }
  setPriority(priority, onComplete) {
    validateArgCount("Reference.setPriority", 1, 2, arguments.length);
    validateCallback("Reference.setPriority", "onComplete", onComplete, true);
    const result = setPriority(this._delegate, priority);
    if (onComplete) {
      result.then(() => onComplete(null), (error) => onComplete(error));
    }
    return result;
  }
  push(value, onComplete) {
    validateArgCount("Reference.push", 0, 2, arguments.length);
    validateCallback("Reference.push", "onComplete", onComplete, true);
    const expPromise = push(this._delegate, value);
    const promise = expPromise.then((expRef) => new Reference(this.database, expRef));
    if (onComplete) {
      promise.then(() => onComplete(null), (error) => onComplete(error));
    }
    const result = new Reference(this.database, expPromise);
    result.then = promise.then.bind(promise);
    result.catch = promise.catch.bind(promise, void 0);
    return result;
  }
  onDisconnect() {
    validateWritablePath("Reference.onDisconnect", this._delegate._path);
    return new OnDisconnect2(new OnDisconnect(this._delegate._repo, this._delegate._path));
  }
  get key() {
    return this.getKey();
  }
  get parent() {
    return this.getParent();
  }
  get root() {
    return this.getRoot();
  }
};
var Database = class {
  constructor(_delegate, app) {
    this._delegate = _delegate;
    this.app = app;
    this.INTERNAL = {
      delete: () => this._delegate._delete()
    };
  }
  useEmulator(host, port, options = {}) {
    connectDatabaseEmulator(this._delegate, host, port, options);
  }
  ref(path) {
    validateArgCount("database.ref", 0, 1, arguments.length);
    if (path instanceof Reference) {
      const childRef = refFromURL(this._delegate, path.toString());
      return new Reference(this, childRef);
    } else {
      const childRef = ref(this._delegate, path);
      return new Reference(this, childRef);
    }
  }
  refFromURL(url) {
    const apiName = "database.refFromURL";
    validateArgCount(apiName, 1, 1, arguments.length);
    const childRef = refFromURL(this._delegate, url);
    return new Reference(this, childRef);
  }
  goOffline() {
    validateArgCount("database.goOffline", 0, 0, arguments.length);
    return goOffline(this._delegate);
  }
  goOnline() {
    validateArgCount("database.goOnline", 0, 0, arguments.length);
    return goOnline(this._delegate);
  }
};
Database.ServerValue = {
  TIMESTAMP: serverTimestamp(),
  increment: (delta) => increment(delta)
};
function initStandalone({ app, url, version: version21, customAuthImpl, namespace, nodeAdmin = false }) {
  setSDKVersion(version21);
  const authProvider = new Provider("auth-internal", new ComponentContainer("database-standalone"));
  authProvider.setComponent(new Component("auth-internal", () => customAuthImpl, "PRIVATE"));
  return {
    instance: new Database(repoManagerDatabaseFromApp(app, authProvider, void 0, url, nodeAdmin), app),
    namespace
  };
}
var INTERNAL = Object.freeze({
  __proto__: null,
  initStandalone
});
var ServerValue = Database.ServerValue;
function registerDatabase(instance) {
  instance.INTERNAL.registerComponent(new Component("database-compat", (container, { instanceIdentifier: url }) => {
    const app = container.getProvider("app-compat").getImmediate();
    const databaseExp = container.getProvider("database").getImmediate({ identifier: url });
    return new Database(databaseExp, app);
  }, "PUBLIC").setServiceProps({
    Reference,
    Query,
    Database,
    DataSnapshot,
    enableLogging,
    INTERNAL,
    ServerValue
  }).setMultipleInstances(true));
  instance.registerVersion(name8, version8);
}
registerDatabase(firebase);

// node_modules/@firebase/firestore-compat/dist/index.esm2017.js
var name9 = "@firebase/firestore-compat";
var version9 = "0.1.14";
function validateSetOptions(methodName, options) {
  if (options === void 0) {
    return {
      merge: false
    };
  }
  if (options.mergeFields !== void 0 && options.merge !== void 0) {
    throw new j("invalid-argument", `Invalid options passed to function ${methodName}(): You cannot specify both "merge" and "mergeFields".`);
  }
  return options;
}
function assertUint8ArrayAvailable() {
  if (typeof Uint8Array === "undefined") {
    throw new j("unimplemented", "Uint8Arrays are not available in this environment.");
  }
}
function assertBase64Available() {
  if (!yt()) {
    throw new j("unimplemented", "Blobs are unavailable in Firestore in this environment.");
  }
}
var Blob2 = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static fromBase64String(base642) {
    assertBase64Available();
    return new Blob2(Sa.fromBase64String(base642));
  }
  static fromUint8Array(array) {
    assertUint8ArrayAvailable();
    return new Blob2(Sa.fromUint8Array(array));
  }
  toBase64() {
    assertBase64Available();
    return this._delegate.toBase64();
  }
  toUint8Array() {
    assertUint8ArrayAvailable();
    return this._delegate.toUint8Array();
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
  toString() {
    return "Blob(base64: " + this.toBase64() + ")";
  }
};
function isPartialObserver(obj) {
  return implementsAnyMethods(obj, ["next", "error", "complete"]);
}
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const object = obj;
  for (const method of methods) {
    if (method in object && typeof object[method] === "function") {
      return true;
    }
  }
  return false;
}
var IndexedDbPersistenceProvider = class {
  enableIndexedDbPersistence(firestore, forceOwnership) {
    return ma(firestore._delegate, { forceOwnership });
  }
  enableMultiTabIndexedDbPersistence(firestore) {
    return ga(firestore._delegate);
  }
  clearIndexedDbPersistence(firestore) {
    return pa(firestore._delegate);
  }
};
var Firestore = class {
  constructor(databaseIdOrApp, _delegate, _persistenceProvider) {
    this._delegate = _delegate;
    this._persistenceProvider = _persistenceProvider;
    this.INTERNAL = {
      delete: () => this.terminate()
    };
    if (!(databaseIdOrApp instanceof Vt)) {
      this._appCompat = databaseIdOrApp;
    }
  }
  get _databaseId() {
    return this._delegate._databaseId;
  }
  settings(settingsLiteral) {
    const currentSettings = this._delegate._getSettings();
    if (!settingsLiteral.merge && currentSettings.host !== settingsLiteral.host) {
      F("You are overriding the original host. If you did not intend to override your settings, use {merge: true}.");
    }
    if (settingsLiteral.merge) {
      settingsLiteral = Object.assign(Object.assign({}, currentSettings), settingsLiteral);
      delete settingsLiteral.merge;
    }
    this._delegate._setSettings(settingsLiteral);
  }
  useEmulator(host, port, options = {}) {
    Xu(this._delegate, host, port, options);
  }
  enableNetwork() {
    return Ea(this._delegate);
  }
  disableNetwork() {
    return Ta(this._delegate);
  }
  enablePersistence(settings2) {
    let synchronizeTabs = false;
    let experimentalForceOwningTab = false;
    if (settings2) {
      synchronizeTabs = !!settings2.synchronizeTabs;
      experimentalForceOwningTab = !!settings2.experimentalForceOwningTab;
      Gu("synchronizeTabs", synchronizeTabs, "experimentalForceOwningTab", experimentalForceOwningTab);
    }
    return synchronizeTabs ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
  }
  clearPersistence() {
    return this._persistenceProvider.clearIndexedDbPersistence(this);
  }
  terminate() {
    if (this._appCompat) {
      this._appCompat._removeServiceInstance("firestore-compat");
      this._appCompat._removeServiceInstance("firestore");
    }
    return this._delegate._delete();
  }
  waitForPendingWrites() {
    return Ia(this._delegate);
  }
  onSnapshotsInSync(arg) {
    return Jh(this._delegate, arg);
  }
  get app() {
    if (!this._appCompat) {
      throw new j("failed-precondition", "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    }
    return this._appCompat;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this, na(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "Firestore.collection()");
    }
  }
  doc(pathString) {
    try {
      return new DocumentReference(this, ia(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "Firestore.doc()");
    }
  }
  collectionGroup(collectionId) {
    try {
      return new Query2(this, sa(this._delegate, collectionId));
    } catch (e) {
      throw replaceFunctionName(e, "collectionGroup()", "Firestore.collectionGroup()");
    }
  }
  runTransaction(updateFunction) {
    return tl(this._delegate, (transaction) => updateFunction(new Transaction(this, transaction)));
  }
  batch() {
    _a(this._delegate);
    return new WriteBatch(new Mh(this._delegate, (mutations) => Yh(this._delegate, mutations)));
  }
  loadBundle(bundleData) {
    return Ra(this._delegate, bundleData);
  }
  namedQuery(name21) {
    return Pa(this._delegate, name21).then((expQuery) => {
      if (!expQuery) {
        return null;
      }
      return new Query2(this, expQuery);
    });
  }
};
var UserDataWriter = class extends xh {
  constructor(firestore) {
    super();
    this.firestore = firestore;
  }
  convertBytes(bytes) {
    return new Blob2(new Sa(bytes));
  }
  convertReference(name21) {
    const key = this.convertDocumentKey(name21, this.firestore._databaseId);
    return DocumentReference.forKey(key, this.firestore, null);
  }
};
function setLogLevel2(level) {
  O(level);
}
var Transaction = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(_firestore);
  }
  get(documentRef) {
    const ref3 = castReference(documentRef);
    return this._delegate.get(ref3).then((result) => new DocumentSnapshot(this._firestore, new uh(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref3.converter)));
  }
  set(documentRef, data, options) {
    const ref3 = castReference(documentRef);
    if (options) {
      validateSetOptions("Transaction.set", options);
      this._delegate.set(ref3, data, options);
    } else {
      this._delegate.set(ref3, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref3 = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref3, dataOrField);
    } else {
      this._delegate.update(ref3, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref3 = castReference(documentRef);
    this._delegate.delete(ref3);
    return this;
  }
};
var WriteBatch = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  set(documentRef, data, options) {
    const ref3 = castReference(documentRef);
    if (options) {
      validateSetOptions("WriteBatch.set", options);
      this._delegate.set(ref3, data, options);
    } else {
      this._delegate.set(ref3, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref3 = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref3, dataOrField);
    } else {
      this._delegate.update(ref3, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref3 = castReference(documentRef);
    this._delegate.delete(ref3);
    return this;
  }
  commit() {
    return this._delegate.commit();
  }
};
var FirestoreDataConverter = class {
  constructor(_firestore, _userDataWriter, _delegate) {
    this._firestore = _firestore;
    this._userDataWriter = _userDataWriter;
    this._delegate = _delegate;
  }
  fromFirestore(snapshot, options) {
    const expSnapshot = new ah(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, null);
    return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : {});
  }
  toFirestore(modelObject, options) {
    if (!options) {
      return this._delegate.toFirestore(modelObject);
    } else {
      return this._delegate.toFirestore(modelObject, options);
    }
  }
  static getInstance(firestore, converter) {
    const converterMapByFirestore = FirestoreDataConverter.INSTANCES;
    let untypedConverterByConverter = converterMapByFirestore.get(firestore);
    if (!untypedConverterByConverter) {
      untypedConverterByConverter = /* @__PURE__ */ new WeakMap();
      converterMapByFirestore.set(firestore, untypedConverterByConverter);
    }
    let instance = untypedConverterByConverter.get(converter);
    if (!instance) {
      instance = new FirestoreDataConverter(firestore, new UserDataWriter(firestore), converter);
      untypedConverterByConverter.set(converter, instance);
    }
    return instance;
  }
};
FirestoreDataConverter.INSTANCES = /* @__PURE__ */ new WeakMap();
var DocumentReference = class {
  constructor(firestore, _delegate) {
    this.firestore = firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore);
  }
  static forPath(path, firestore, converter) {
    if (path.length % 2 !== 0) {
      throw new j("invalid-argument", `Invalid document reference. Document references must have an even number of segments, but ${path.canonicalString()} has ${path.length}`);
    }
    return new DocumentReference(firestore, new Zu(firestore._delegate, converter, new Nt(path)));
  }
  static forKey(key, firestore, converter) {
    return new DocumentReference(firestore, new Zu(firestore._delegate, converter, key));
  }
  get id() {
    return this._delegate.id;
  }
  get parent() {
    return new CollectionReference(this.firestore, this._delegate.parent);
  }
  get path() {
    return this._delegate.path;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this.firestore, na(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "DocumentReference.collection()");
    }
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof Zu)) {
      return false;
    }
    return ra(this._delegate, other);
  }
  set(value, options) {
    options = validateSetOptions("DocumentReference.set", options);
    try {
      if (options) {
        return jh(this._delegate, value, options);
      } else {
        return jh(this._delegate, value);
      }
    } catch (e) {
      throw replaceFunctionName(e, "setDoc()", "DocumentReference.set()");
    }
  }
  update(fieldOrUpdateData, value, ...moreFieldsAndValues) {
    try {
      if (arguments.length === 1) {
        return Qh(this._delegate, fieldOrUpdateData);
      } else {
        return Qh(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);
      }
    } catch (e) {
      throw replaceFunctionName(e, "updateDoc()", "DocumentReference.update()");
    }
  }
  delete() {
    return Wh(this._delegate);
  }
  onSnapshot(...args) {
    const options = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (result) => new DocumentSnapshot(this.firestore, new uh(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
    return Hh(this._delegate, options, observer);
  }
  get(options) {
    let snap;
    if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
      snap = Lh(this._delegate);
    } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
      snap = Uh(this._delegate);
    } else {
      snap = Fh(this._delegate);
    }
    return snap.then((result) => new DocumentSnapshot(this.firestore, new uh(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
  }
  withConverter(converter) {
    return new DocumentReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
function replaceFunctionName(e, original, updated) {
  e.message = e.message.replace(original, updated);
  return e;
}
function extractSnapshotOptions(args) {
  for (const arg of args) {
    if (typeof arg === "object" && !isPartialObserver(arg)) {
      return arg;
    }
  }
  return {};
}
function wrapObserver(args, wrapper) {
  var _a2, _b;
  let userObserver;
  if (isPartialObserver(args[0])) {
    userObserver = args[0];
  } else if (isPartialObserver(args[1])) {
    userObserver = args[1];
  } else if (typeof args[0] === "function") {
    userObserver = {
      next: args[0],
      error: args[1],
      complete: args[2]
    };
  } else {
    userObserver = {
      next: args[1],
      error: args[2],
      complete: args[3]
    };
  }
  return {
    next: (val) => {
      if (userObserver.next) {
        userObserver.next(wrapper(val));
      }
    },
    error: (_a2 = userObserver.error) === null || _a2 === void 0 ? void 0 : _a2.bind(userObserver),
    complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
  };
}
var DocumentSnapshot = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get ref() {
    return new DocumentReference(this._firestore, this._delegate.ref);
  }
  get id() {
    return this._delegate.id;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get exists() {
    return this._delegate.exists();
  }
  data(options) {
    return this._delegate.data(options);
  }
  get(fieldPath, options) {
    return this._delegate.get(fieldPath, options);
  }
  isEqual(other) {
    return fh(this._delegate, other._delegate);
  }
};
var QueryDocumentSnapshot = class extends DocumentSnapshot {
  data(options) {
    const data = this._delegate.data(options);
    q(data !== void 0, "Document in a QueryDocumentSnapshot should exist");
    return data;
  }
};
var Query2 = class {
  constructor(firestore, _delegate) {
    this.firestore = firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore);
  }
  where(fieldPath, opStr, value) {
    try {
      return new Query2(this.firestore, wh(this._delegate, gh(fieldPath, opStr, value)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  orderBy(fieldPath, directionStr) {
    try {
      return new Query2(this.firestore, wh(this._delegate, ph(fieldPath, directionStr)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  limit(n) {
    try {
      return new Query2(this.firestore, wh(this._delegate, Eh(n)));
    } catch (e) {
      throw replaceFunctionName(e, "limit()", "Query.limit()");
    }
  }
  limitToLast(n) {
    try {
      return new Query2(this.firestore, wh(this._delegate, Th(n)));
    } catch (e) {
      throw replaceFunctionName(e, "limitToLast()", "Query.limitToLast()");
    }
  }
  startAt(...args) {
    try {
      return new Query2(this.firestore, wh(this._delegate, Rh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAt()", "Query.startAt()");
    }
  }
  startAfter(...args) {
    try {
      return new Query2(this.firestore, wh(this._delegate, Ph(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAfter()", "Query.startAfter()");
    }
  }
  endBefore(...args) {
    try {
      return new Query2(this.firestore, wh(this._delegate, vh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endBefore()", "Query.endBefore()");
    }
  }
  endAt(...args) {
    try {
      return new Query2(this.firestore, wh(this._delegate, Vh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endAt()", "Query.endAt()");
    }
  }
  isEqual(other) {
    return oa(this._delegate, other._delegate);
  }
  get(options) {
    let query2;
    if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
      query2 = Kh(this._delegate);
    } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
      query2 = Gh(this._delegate);
    } else {
      query2 = qh(this._delegate);
    }
    return query2.then((result) => new QuerySnapshot(this.firestore, new hh(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));
  }
  onSnapshot(...args) {
    const options = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (snap) => new QuerySnapshot(this.firestore, new hh(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));
    return Hh(this._delegate, options, observer);
  }
  withConverter(converter) {
    return new Query2(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
var DocumentChange = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get type() {
    return this._delegate.type;
  }
  get doc() {
    return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
  }
  get oldIndex() {
    return this._delegate.oldIndex;
  }
  get newIndex() {
    return this._delegate.newIndex;
  }
};
var QuerySnapshot = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get query() {
    return new Query2(this._firestore, this._delegate.query);
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get size() {
    return this._delegate.size;
  }
  get empty() {
    return this._delegate.empty;
  }
  get docs() {
    return this._delegate.docs.map((doc) => new QueryDocumentSnapshot(this._firestore, doc));
  }
  docChanges(options) {
    return this._delegate.docChanges(options).map((docChange) => new DocumentChange(this._firestore, docChange));
  }
  forEach(callback, thisArg) {
    this._delegate.forEach((snapshot) => {
      callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));
    });
  }
  isEqual(other) {
    return fh(this._delegate, other._delegate);
  }
};
var CollectionReference = class extends Query2 {
  constructor(firestore, _delegate) {
    super(firestore, _delegate);
    this.firestore = firestore;
    this._delegate = _delegate;
  }
  get id() {
    return this._delegate.id;
  }
  get path() {
    return this._delegate.path;
  }
  get parent() {
    const docRef = this._delegate.parent;
    return docRef ? new DocumentReference(this.firestore, docRef) : null;
  }
  doc(documentPath) {
    try {
      if (documentPath === void 0) {
        return new DocumentReference(this.firestore, ia(this._delegate));
      } else {
        return new DocumentReference(this.firestore, ia(this._delegate, documentPath));
      }
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "CollectionReference.doc()");
    }
  }
  add(data) {
    return zh(this._delegate, data).then((docRef) => new DocumentReference(this.firestore, docRef));
  }
  isEqual(other) {
    return ra(this._delegate, other._delegate);
  }
  withConverter(converter) {
    return new CollectionReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
function castReference(documentRef) {
  return zu(documentRef, Zu);
}
var FieldPath = class {
  constructor(...fieldNames) {
    this._delegate = new va(...fieldNames);
  }
  static documentId() {
    return new FieldPath(mt.keyField().canonicalString());
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof va)) {
      return false;
    }
    return this._delegate._internalPath.isEqual(other._internalPath);
  }
};
var FieldValue = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static serverTimestamp() {
    const delegate = nl();
    delegate._methodName = "FieldValue.serverTimestamp";
    return new FieldValue(delegate);
  }
  static delete() {
    const delegate = el();
    delegate._methodName = "FieldValue.delete";
    return new FieldValue(delegate);
  }
  static arrayUnion(...elements) {
    const delegate = sl(...elements);
    delegate._methodName = "FieldValue.arrayUnion";
    return new FieldValue(delegate);
  }
  static arrayRemove(...elements) {
    const delegate = il(...elements);
    delegate._methodName = "FieldValue.arrayRemove";
    return new FieldValue(delegate);
  }
  static increment(n) {
    const delegate = rl(n);
    delegate._methodName = "FieldValue.increment";
    return new FieldValue(delegate);
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
};
var firestoreNamespace = {
  Firestore,
  GeoPoint: Ca,
  Timestamp: ut,
  Blob: Blob2,
  Transaction,
  WriteBatch,
  DocumentReference,
  DocumentSnapshot,
  Query: Query2,
  QueryDocumentSnapshot,
  QuerySnapshot,
  CollectionReference,
  FieldPath,
  FieldValue,
  setLogLevel: setLogLevel2,
  CACHE_SIZE_UNLIMITED: ha
};
function configureForFirebase(firebase2, firestoreFactory) {
  firebase2.INTERNAL.registerComponent(new Component("firestore-compat", (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const firestoreExp = container.getProvider("firestore").getImmediate();
    return firestoreFactory(app, firestoreExp);
  }, "PUBLIC").setServiceProps(Object.assign({}, firestoreNamespace)));
}
function registerFirestore(instance) {
  configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));
  instance.registerVersion(name9, version9);
}
registerFirestore(firebase);

// node_modules/@firebase/functions/dist/index.esm2017.js
var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
function mapValues(o, f) {
  const result = {};
  for (const key in o) {
    if (o.hasOwnProperty(key)) {
      result[key] = f(o[key]);
    }
  }
  return result;
}
function encode2(data) {
  if (data == null) {
    return null;
  }
  if (data instanceof Number) {
    data = data.valueOf();
  }
  if (typeof data === "number" && isFinite(data)) {
    return data;
  }
  if (data === true || data === false) {
    return data;
  }
  if (Object.prototype.toString.call(data) === "[object String]") {
    return data;
  }
  if (data instanceof Date) {
    return data.toISOString();
  }
  if (Array.isArray(data)) {
    return data.map((x) => encode2(x));
  }
  if (typeof data === "function" || typeof data === "object") {
    return mapValues(data, (x) => encode2(x));
  }
  throw new Error("Data cannot be encoded in JSON: " + data);
}
function decode(json) {
  if (json == null) {
    return json;
  }
  if (json["@type"]) {
    switch (json["@type"]) {
      case LONG_TYPE:
      case UNSIGNED_LONG_TYPE: {
        const value = Number(json["value"]);
        if (isNaN(value)) {
          throw new Error("Data cannot be decoded from JSON: " + json);
        }
        return value;
      }
      default: {
        throw new Error("Data cannot be decoded from JSON: " + json);
      }
    }
  }
  if (Array.isArray(json)) {
    return json.map((x) => decode(x));
  }
  if (typeof json === "function" || typeof json === "object") {
    return mapValues(json, (x) => decode(x));
  }
  return json;
}
var FUNCTIONS_TYPE = "functions";
var errorCodeMap = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var FunctionsError = class extends FirebaseError {
  constructor(code, message, details) {
    super(`${FUNCTIONS_TYPE}/${code}`, message || "");
    this.details = details;
  }
};
function codeForHTTPStatus(status) {
  if (status >= 200 && status < 300) {
    return "ok";
  }
  switch (status) {
    case 0:
      return "internal";
    case 400:
      return "invalid-argument";
    case 401:
      return "unauthenticated";
    case 403:
      return "permission-denied";
    case 404:
      return "not-found";
    case 409:
      return "aborted";
    case 429:
      return "resource-exhausted";
    case 499:
      return "cancelled";
    case 500:
      return "internal";
    case 501:
      return "unimplemented";
    case 503:
      return "unavailable";
    case 504:
      return "deadline-exceeded";
  }
  return "unknown";
}
function _errorForResponse(status, bodyJSON) {
  let code = codeForHTTPStatus(status);
  let description = code;
  let details = void 0;
  try {
    const errorJSON = bodyJSON && bodyJSON.error;
    if (errorJSON) {
      const status2 = errorJSON.status;
      if (typeof status2 === "string") {
        if (!errorCodeMap[status2]) {
          return new FunctionsError("internal", "internal");
        }
        code = errorCodeMap[status2];
        description = status2;
      }
      const message = errorJSON.message;
      if (typeof message === "string") {
        description = message;
      }
      details = errorJSON.details;
      if (details !== void 0) {
        details = decode(details);
      }
    }
  } catch (e) {
  }
  if (code === "ok") {
    return null;
  }
  return new FunctionsError(code, description, details);
}
var ContextProvider = class {
  constructor(authProvider, messagingProvider, appCheckProvider) {
    this.auth = null;
    this.messaging = null;
    this.appCheck = null;
    this.auth = authProvider.getImmediate({ optional: true });
    this.messaging = messagingProvider.getImmediate({
      optional: true
    });
    if (!this.auth) {
      authProvider.get().then((auth) => this.auth = auth, () => {
      });
    }
    if (!this.messaging) {
      messagingProvider.get().then((messaging) => this.messaging = messaging, () => {
      });
    }
    if (!this.appCheck) {
      appCheckProvider.get().then((appCheck) => this.appCheck = appCheck, () => {
      });
    }
  }
  async getAuthToken() {
    if (!this.auth) {
      return void 0;
    }
    try {
      const token = await this.auth.getToken();
      return token === null || token === void 0 ? void 0 : token.accessToken;
    } catch (e) {
      return void 0;
    }
  }
  async getMessagingToken() {
    if (!this.messaging || !("Notification" in self) || Notification.permission !== "granted") {
      return void 0;
    }
    try {
      return await this.messaging.getToken();
    } catch (e) {
      return void 0;
    }
  }
  async getAppCheckToken() {
    if (this.appCheck) {
      const result = await this.appCheck.getToken();
      if (result.error) {
        return null;
      }
      return result.token;
    }
    return null;
  }
  async getContext() {
    const authToken = await this.getAuthToken();
    const messagingToken = await this.getMessagingToken();
    const appCheckToken = await this.getAppCheckToken();
    return { authToken, messagingToken, appCheckToken };
  }
};
var DEFAULT_REGION = "us-central1";
function failAfter(millis) {
  let timer = null;
  return {
    promise: new Promise((_, reject) => {
      timer = setTimeout(() => {
        reject(new FunctionsError("deadline-exceeded", "deadline-exceeded"));
      }, millis);
    }),
    cancel: () => {
      if (timer) {
        clearTimeout(timer);
      }
    }
  };
}
var FunctionsService = class {
  constructor(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain = DEFAULT_REGION, fetchImpl) {
    this.app = app;
    this.fetchImpl = fetchImpl;
    this.emulatorOrigin = null;
    this.contextProvider = new ContextProvider(authProvider, messagingProvider, appCheckProvider);
    this.cancelAllRequests = new Promise((resolve) => {
      this.deleteService = () => {
        return Promise.resolve(resolve());
      };
    });
    try {
      const url = new URL(regionOrCustomDomain);
      this.customDomain = url.origin;
      this.region = DEFAULT_REGION;
    } catch (e) {
      this.customDomain = null;
      this.region = regionOrCustomDomain;
    }
  }
  _delete() {
    return this.deleteService();
  }
  _url(name21) {
    const projectId = this.app.options.projectId;
    if (this.emulatorOrigin !== null) {
      const origin = this.emulatorOrigin;
      return `${origin}/${projectId}/${this.region}/${name21}`;
    }
    if (this.customDomain !== null) {
      return `${this.customDomain}/${name21}`;
    }
    return `https://${this.region}-${projectId}.cloudfunctions.net/${name21}`;
  }
};
function connectFunctionsEmulator$1(functionsInstance, host, port) {
  functionsInstance.emulatorOrigin = `http://${host}:${port}`;
}
function httpsCallable$1(functionsInstance, name21, options) {
  return (data) => {
    return call(functionsInstance, name21, data, options || {});
  };
}
async function postJSON(url, body, headers, fetchImpl) {
  headers["Content-Type"] = "application/json";
  let response;
  try {
    response = await fetchImpl(url, {
      method: "POST",
      body: JSON.stringify(body),
      headers
    });
  } catch (e) {
    return {
      status: 0,
      json: null
    };
  }
  let json = null;
  try {
    json = await response.json();
  } catch (e) {
  }
  return {
    status: response.status,
    json
  };
}
async function call(functionsInstance, name21, data, options) {
  const url = functionsInstance._url(name21);
  data = encode2(data);
  const body = { data };
  const headers = {};
  const context = await functionsInstance.contextProvider.getContext();
  if (context.authToken) {
    headers["Authorization"] = "Bearer " + context.authToken;
  }
  if (context.messagingToken) {
    headers["Firebase-Instance-ID-Token"] = context.messagingToken;
  }
  if (context.appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = context.appCheckToken;
  }
  const timeout = options.timeout || 7e4;
  const failAfterHandle = failAfter(timeout);
  const response = await Promise.race([
    postJSON(url, body, headers, functionsInstance.fetchImpl),
    failAfterHandle.promise,
    functionsInstance.cancelAllRequests
  ]);
  failAfterHandle.cancel();
  if (!response) {
    throw new FunctionsError("cancelled", "Firebase Functions instance was deleted.");
  }
  const error = _errorForResponse(response.status, response.json);
  if (error) {
    throw error;
  }
  if (!response.json) {
    throw new FunctionsError("internal", "Response is not valid JSON object.");
  }
  let responseData = response.json.data;
  if (typeof responseData === "undefined") {
    responseData = response.json.result;
  }
  if (typeof responseData === "undefined") {
    throw new FunctionsError("internal", "Response is missing data field.");
  }
  const decodedData = decode(responseData);
  return { data: decodedData };
}
var name10 = "@firebase/functions";
var version10 = "0.7.8";
var AUTH_INTERNAL_NAME = "auth-internal";
var APP_CHECK_INTERNAL_NAME = "app-check-internal";
var MESSAGING_INTERNAL_NAME = "messaging-internal";
function registerFunctions(fetchImpl, variant) {
  const factory9 = (container, { instanceIdentifier: regionOrCustomDomain }) => {
    const app = container.getProvider("app").getImmediate();
    const authProvider = container.getProvider(AUTH_INTERNAL_NAME);
    const messagingProvider = container.getProvider(MESSAGING_INTERNAL_NAME);
    const appCheckProvider = container.getProvider(APP_CHECK_INTERNAL_NAME);
    return new FunctionsService(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl);
  };
  _registerComponent(new Component(FUNCTIONS_TYPE, factory9, "PUBLIC").setMultipleInstances(true));
  registerVersion(name10, version10, variant);
  registerVersion(name10, version10, "esm2017");
}
function connectFunctionsEmulator(functionsInstance, host, port) {
  connectFunctionsEmulator$1(getModularInstance(functionsInstance), host, port);
}
function httpsCallable(functionsInstance, name21, options) {
  return httpsCallable$1(getModularInstance(functionsInstance), name21, options);
}
registerFunctions(fetch.bind(self));

// node_modules/@firebase/functions-compat/dist/index.esm2017.js
var name11 = "@firebase/functions-compat";
var version11 = "0.1.9";
var FunctionsService2 = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
    this._region = this._delegate.region;
    this._customDomain = this._delegate.customDomain;
  }
  httpsCallable(name21, options) {
    return httpsCallable(this._delegate, name21, options);
  }
  useFunctionsEmulator(origin) {
    const match = origin.match("[a-zA-Z]+://([a-zA-Z0-9.-]+)(?::([0-9]+))?");
    if (match == null) {
      throw new FirebaseError("functions", "No origin provided to useFunctionsEmulator()");
    }
    if (match[2] == null) {
      throw new FirebaseError("functions", "Port missing in origin provided to useFunctionsEmulator()");
    }
    return connectFunctionsEmulator(this._delegate, match[1], Number(match[2]));
  }
  useEmulator(host, port) {
    return connectFunctionsEmulator(this._delegate, host, port);
  }
};
var DEFAULT_REGION2 = "us-central1";
var factory5 = (container, { instanceIdentifier: regionOrCustomDomain }) => {
  const app = container.getProvider("app-compat").getImmediate();
  const functionsServiceExp = container.getProvider("functions").getImmediate({
    identifier: regionOrCustomDomain !== null && regionOrCustomDomain !== void 0 ? regionOrCustomDomain : DEFAULT_REGION2
  });
  return new FunctionsService2(app, functionsServiceExp);
};
function registerFunctions2() {
  const namespaceExports = {
    Functions: FunctionsService2
  };
  firebase.INTERNAL.registerComponent(new Component("functions-compat", factory5, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
}
registerFunctions2();
firebase.registerVersion(name11, version11);

// node_modules/@firebase/messaging/dist/esm/index.esm2017.js
var DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
var DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
var DEFAULT_VAPID_KEY = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT = "https://fcmregistrations.googleapis.com/v1";
var CONSOLE_CAMPAIGN_ID = "google.c.a.c_id";
var CONSOLE_CAMPAIGN_NAME = "google.c.a.c_l";
var CONSOLE_CAMPAIGN_TIME = "google.c.a.ts";
var CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = "google.c.a.e";
var MessageType$1;
(function(MessageType3) {
  MessageType3[MessageType3["DATA_MESSAGE"] = 1] = "DATA_MESSAGE";
  MessageType3[MessageType3["DISPLAY_NOTIFICATION"] = 3] = "DISPLAY_NOTIFICATION";
})(MessageType$1 || (MessageType$1 = {}));
var MessageType;
(function(MessageType3) {
  MessageType3["PUSH_RECEIVED"] = "push-received";
  MessageType3["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType || (MessageType = {}));
function arrayToBase64(array) {
  const uint8Array = new Uint8Array(array);
  const base64String = btoa(String.fromCharCode(...uint8Array));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray(base64String) {
  const padding = "=".repeat((4 - base64String.length % 4) % 4);
  const base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  const rawData = atob(base642);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME = "fcm_token_details_db";
var OLD_DB_VERSION = 5;
var OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
async function migrateOldDatabase(senderId) {
  if ("databases" in indexedDB) {
    const databases = await indexedDB.databases();
    const dbNames = databases.map((db2) => db2.name);
    if (!dbNames.includes(OLD_DB_NAME)) {
      return null;
    }
  }
  let tokenDetails = null;
  const db = await openDb(OLD_DB_NAME, OLD_DB_VERSION, async (db2) => {
    var _a2;
    if (db2.oldVersion < 2) {
      return;
    }
    if (!db2.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {
      return;
    }
    const objectStore = db2.transaction.objectStore(OLD_OBJECT_STORE_NAME);
    const value = await objectStore.index("fcmSenderId").get(senderId);
    await objectStore.clear();
    if (!value) {
      return;
    }
    if (db2.oldVersion === 2) {
      const oldDetails = value;
      if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
        return;
      }
      tokenDetails = {
        token: oldDetails.fcmToken,
        createTime: (_a2 = oldDetails.createTime) !== null && _a2 !== void 0 ? _a2 : Date.now(),
        subscriptionOptions: {
          auth: oldDetails.auth,
          p256dh: oldDetails.p256dh,
          endpoint: oldDetails.endpoint,
          swScope: oldDetails.swScope,
          vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)
        }
      };
    } else if (db2.oldVersion === 3) {
      const oldDetails = value;
      tokenDetails = {
        token: oldDetails.fcmToken,
        createTime: oldDetails.createTime,
        subscriptionOptions: {
          auth: arrayToBase64(oldDetails.auth),
          p256dh: arrayToBase64(oldDetails.p256dh),
          endpoint: oldDetails.endpoint,
          swScope: oldDetails.swScope,
          vapidKey: arrayToBase64(oldDetails.vapidKey)
        }
      };
    } else if (db2.oldVersion === 4) {
      const oldDetails = value;
      tokenDetails = {
        token: oldDetails.fcmToken,
        createTime: oldDetails.createTime,
        subscriptionOptions: {
          auth: arrayToBase64(oldDetails.auth),
          p256dh: arrayToBase64(oldDetails.p256dh),
          endpoint: oldDetails.endpoint,
          swScope: oldDetails.swScope,
          vapidKey: arrayToBase64(oldDetails.vapidKey)
        }
      };
    }
  });
  db.close();
  await deleteDb(OLD_DB_NAME);
  await deleteDb("fcm_vapid_details_db");
  await deleteDb("undefined");
  return checkTokenDetails(tokenDetails) ? tokenDetails : null;
}
function checkTokenDetails(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  const { subscriptionOptions } = tokenDetails;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME2 = "firebase-messaging-database";
var DATABASE_VERSION2 = 1;
var OBJECT_STORE_NAME2 = "firebase-messaging-store";
var dbPromise3 = null;
function getDbPromise2() {
  if (!dbPromise3) {
    dbPromise3 = openDb(DATABASE_NAME2, DATABASE_VERSION2, (upgradeDb) => {
      switch (upgradeDb.oldVersion) {
        case 0:
          upgradeDb.createObjectStore(OBJECT_STORE_NAME2);
      }
    });
  }
  return dbPromise3;
}
async function dbGet(firebaseDependencies) {
  const key = getKey2(firebaseDependencies);
  const db = await getDbPromise2();
  const tokenDetails = await db.transaction(OBJECT_STORE_NAME2).objectStore(OBJECT_STORE_NAME2).get(key);
  if (tokenDetails) {
    return tokenDetails;
  } else {
    const oldTokenDetails = await migrateOldDatabase(firebaseDependencies.appConfig.senderId);
    if (oldTokenDetails) {
      await dbSet(firebaseDependencies, oldTokenDetails);
      return oldTokenDetails;
    }
  }
}
async function dbSet(firebaseDependencies, tokenDetails) {
  const key = getKey2(firebaseDependencies);
  const db = await getDbPromise2();
  const tx = db.transaction(OBJECT_STORE_NAME2, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME2).put(tokenDetails, key);
  await tx.complete;
  return tokenDetails;
}
async function dbRemove(firebaseDependencies) {
  const key = getKey2(firebaseDependencies);
  const db = await getDbPromise2();
  const tx = db.transaction(OBJECT_STORE_NAME2, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME2).delete(key);
  await tx.complete;
}
function getKey2({ appConfig }) {
  return appConfig.appId;
}
var ERROR_MAP = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["only-available-in-window"]: "This method is available in a Window context.",
  ["only-available-in-sw"]: "This method is available in a service worker context.",
  ["permission-default"]: "The notification permission was not granted and dismissed instead.",
  ["permission-blocked"]: "The notification permission was not granted and blocked instead.",
  ["unsupported-browser"]: "This browser doesn't support the API's required to use the Firebase SDK.",
  ["indexed-db-unsupported"]: "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  ["failed-service-worker-registration"]: "We are unable to register the default service worker. {$browserErrorMessage}",
  ["token-subscribe-failed"]: "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  ["token-subscribe-no-token"]: "FCM returned no token when subscribing the user to push.",
  ["token-unsubscribe-failed"]: "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  ["token-update-failed"]: "A problem occurred while updating the user from FCM: {$errorInfo}",
  ["token-update-no-token"]: "FCM returned no token when updating the user to push.",
  ["use-sw-after-get-token"]: "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  ["invalid-sw-registration"]: "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  ["invalid-bg-handler"]: "The input to setBackgroundMessageHandler() must be a function.",
  ["invalid-vapid-key"]: "The public VAPID key must be a string.",
  ["use-vapid-key-after-get-token"]: "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
};
var ERROR_FACTORY6 = new ErrorFactory("messaging", "Messaging", ERROR_MAP);
async function requestGetToken(firebaseDependencies, subscriptionOptions) {
  const headers = await getHeaders3(firebaseDependencies);
  const body = getBody(subscriptionOptions);
  const subscribeOptions = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY6.create("token-subscribe-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY6.create("token-subscribe-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY6.create("token-subscribe-no-token");
  }
  return responseData.token;
}
async function requestUpdateToken(firebaseDependencies, tokenDetails) {
  const headers = await getHeaders3(firebaseDependencies);
  const body = getBody(tokenDetails.subscriptionOptions);
  const updateOptions = {
    method: "PATCH",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(`${getEndpoint(firebaseDependencies.appConfig)}/${tokenDetails.token}`, updateOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY6.create("token-update-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY6.create("token-update-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY6.create("token-update-no-token");
  }
  return responseData.token;
}
async function requestDeleteToken(firebaseDependencies, token) {
  const headers = await getHeaders3(firebaseDependencies);
  const unsubscribeOptions = {
    method: "DELETE",
    headers
  };
  try {
    const response = await fetch(`${getEndpoint(firebaseDependencies.appConfig)}/${token}`, unsubscribeOptions);
    const responseData = await response.json();
    if (responseData.error) {
      const message = responseData.error.message;
      throw ERROR_FACTORY6.create("token-unsubscribe-failed", {
        errorInfo: message
      });
    }
  } catch (err) {
    throw ERROR_FACTORY6.create("token-unsubscribe-failed", {
      errorInfo: err
    });
  }
}
function getEndpoint({ projectId }) {
  return `${ENDPOINT}/projects/${projectId}/registrations`;
}
async function getHeaders3({ appConfig, installations }) {
  const authToken = await installations.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": appConfig.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${authToken}`
  });
}
function getBody({ p256dh, auth, endpoint, vapidKey }) {
  const body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1e3;
async function getTokenInternal(messaging) {
  const pushSubscription = await getPushSubscription(messaging.swRegistration, messaging.vapidKey);
  const subscriptionOptions = {
    vapidKey: messaging.vapidKey,
    swScope: messaging.swRegistration.scope,
    endpoint: pushSubscription.endpoint,
    auth: arrayToBase64(pushSubscription.getKey("auth")),
    p256dh: arrayToBase64(pushSubscription.getKey("p256dh"))
  };
  const tokenDetails = await dbGet(messaging.firebaseDependencies);
  if (!tokenDetails) {
    return getNewToken(messaging.firebaseDependencies, subscriptionOptions);
  } else if (!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions)) {
    try {
      await requestDeleteToken(messaging.firebaseDependencies, tokenDetails.token);
    } catch (e) {
      console.warn(e);
    }
    return getNewToken(messaging.firebaseDependencies, subscriptionOptions);
  } else if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {
    return updateToken(messaging, {
      token: tokenDetails.token,
      createTime: Date.now(),
      subscriptionOptions
    });
  } else {
    return tokenDetails.token;
  }
}
async function deleteTokenInternal(messaging) {
  const tokenDetails = await dbGet(messaging.firebaseDependencies);
  if (tokenDetails) {
    await requestDeleteToken(messaging.firebaseDependencies, tokenDetails.token);
    await dbRemove(messaging.firebaseDependencies);
  }
  const pushSubscription = await messaging.swRegistration.pushManager.getSubscription();
  if (pushSubscription) {
    return pushSubscription.unsubscribe();
  }
  return true;
}
async function updateToken(messaging, tokenDetails) {
  try {
    const updatedToken = await requestUpdateToken(messaging.firebaseDependencies, tokenDetails);
    const updatedTokenDetails = Object.assign(Object.assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
    await dbSet(messaging.firebaseDependencies, updatedTokenDetails);
    return updatedToken;
  } catch (e) {
    await deleteTokenInternal(messaging);
    throw e;
  }
}
async function getNewToken(firebaseDependencies, subscriptionOptions) {
  const token = await requestGetToken(firebaseDependencies, subscriptionOptions);
  const tokenDetails = {
    token,
    createTime: Date.now(),
    subscriptionOptions
  };
  await dbSet(firebaseDependencies, tokenDetails);
  return tokenDetails.token;
}
async function getPushSubscription(swRegistration, vapidKey) {
  const subscription = await swRegistration.pushManager.getSubscription();
  if (subscription) {
    return subscription;
  }
  return swRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: base64ToArray(vapidKey)
  });
}
function isTokenValid(dbOptions, currentOptions) {
  const isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  const isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  const isAuthEqual = currentOptions.auth === dbOptions.auth;
  const isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload(internalPayload) {
  const payload = {
    from: internalPayload.from,
    collapseKey: internalPayload.collapse_key,
    messageId: internalPayload.fcmMessageId
  };
  propagateNotificationPayload(payload, internalPayload);
  propagateDataPayload(payload, internalPayload);
  propagateFcmOptions(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  const title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  const body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  const image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.fcmOptions) {
    return;
  }
  payload.fcmOptions = {};
  const link = messagePayloadInternal.fcmOptions.link;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  const analyticsLabel = messagePayloadInternal.fcmOptions.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID in data;
}
_mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
_mergeStrings("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
function _mergeStrings(s1, s2) {
  const resultArray = [];
  for (let i = 0; i < s1.length; i++) {
    resultArray.push(s1.charAt(i));
    if (i < s2.length) {
      resultArray.push(s2.charAt(i));
    }
  }
  return resultArray.join("");
}
function extractAppConfig2(app) {
  if (!app || !app.options) {
    throw getMissingValueError2("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError2("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  const { options } = app;
  for (const keyName of configKeys) {
    if (!options[keyName]) {
      throw getMissingValueError2(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError2(valueName) {
  return ERROR_FACTORY6.create("missing-app-config-values", {
    valueName
  });
}
var MessagingService = class {
  constructor(app, installations, analyticsProvider) {
    this.deliveryMetricsExportedToBigQueryEnabled = false;
    this.onBackgroundMessageHandler = null;
    this.onMessageHandler = null;
    this.logEvents = [];
    this.isLogServiceStarted = false;
    const appConfig = extractAppConfig2(app);
    this.firebaseDependencies = {
      app,
      appConfig,
      installations,
      analyticsProvider
    };
  }
  _delete() {
    return Promise.resolve();
  }
};
async function registerDefaultSw(messaging) {
  try {
    messaging.swRegistration = await navigator.serviceWorker.register(DEFAULT_SW_PATH, {
      scope: DEFAULT_SW_SCOPE
    });
    messaging.swRegistration.update().catch(() => {
    });
  } catch (e) {
    throw ERROR_FACTORY6.create("failed-service-worker-registration", {
      browserErrorMessage: e.message
    });
  }
}
async function updateSwReg(messaging, swRegistration) {
  if (!swRegistration && !messaging.swRegistration) {
    await registerDefaultSw(messaging);
  }
  if (!swRegistration && !!messaging.swRegistration) {
    return;
  }
  if (!(swRegistration instanceof ServiceWorkerRegistration)) {
    throw ERROR_FACTORY6.create("invalid-sw-registration");
  }
  messaging.swRegistration = swRegistration;
}
async function updateVapidKey(messaging, vapidKey) {
  if (!!vapidKey) {
    messaging.vapidKey = vapidKey;
  } else if (!messaging.vapidKey) {
    messaging.vapidKey = DEFAULT_VAPID_KEY;
  }
}
async function getToken$12(messaging, options) {
  if (!navigator) {
    throw ERROR_FACTORY6.create("only-available-in-window");
  }
  if (Notification.permission === "default") {
    await Notification.requestPermission();
  }
  if (Notification.permission !== "granted") {
    throw ERROR_FACTORY6.create("permission-blocked");
  }
  await updateVapidKey(messaging, options === null || options === void 0 ? void 0 : options.vapidKey);
  await updateSwReg(messaging, options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration);
  return getTokenInternal(messaging);
}
async function logToScion(messaging, messageType, data) {
  const eventType = getEventType(messageType);
  const analytics = await messaging.firebaseDependencies.analyticsProvider.get();
  analytics.logEvent(eventType, {
    message_id: data[CONSOLE_CAMPAIGN_ID],
    message_name: data[CONSOLE_CAMPAIGN_NAME],
    message_time: data[CONSOLE_CAMPAIGN_TIME],
    message_device_time: Math.floor(Date.now() / 1e3)
  });
}
function getEventType(messageType) {
  switch (messageType) {
    case MessageType.NOTIFICATION_CLICKED:
      return "notification_open";
    case MessageType.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
async function messageEventListener(messaging, event) {
  const internalPayload = event.data;
  if (!internalPayload.isFirebaseMessaging) {
    return;
  }
  if (messaging.onMessageHandler && internalPayload.messageType === MessageType.PUSH_RECEIVED) {
    if (typeof messaging.onMessageHandler === "function") {
      messaging.onMessageHandler(externalizePayload(internalPayload));
    } else {
      messaging.onMessageHandler.next(externalizePayload(internalPayload));
    }
  }
  const dataPayload = internalPayload.data;
  if (isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === "1") {
    await logToScion(messaging, internalPayload.messageType, dataPayload);
  }
}
var name12 = "@firebase/messaging";
var version12 = "0.9.9";
var WindowMessagingFactory = (container) => {
  const messaging = new MessagingService(container.getProvider("app").getImmediate(), container.getProvider("installations-internal").getImmediate(), container.getProvider("analytics-internal"));
  navigator.serviceWorker.addEventListener("message", (e) => messageEventListener(messaging, e));
  return messaging;
};
var WindowMessagingInternalFactory = (container) => {
  const messaging = container.getProvider("messaging").getImmediate();
  const messagingInternal = {
    getToken: (options) => getToken$12(messaging, options)
  };
  return messagingInternal;
};
function registerMessagingInWindow() {
  _registerComponent(new Component("messaging", WindowMessagingFactory, "PUBLIC"));
  _registerComponent(new Component("messaging-internal", WindowMessagingInternalFactory, "PRIVATE"));
  registerVersion(name12, version12);
  registerVersion(name12, version12, "esm2017");
}
async function deleteToken$1(messaging) {
  if (!navigator) {
    throw ERROR_FACTORY6.create("only-available-in-window");
  }
  if (!messaging.swRegistration) {
    await registerDefaultSw(messaging);
  }
  return deleteTokenInternal(messaging);
}
function onMessage$1(messaging, nextOrObserver) {
  if (!navigator) {
    throw ERROR_FACTORY6.create("only-available-in-window");
  }
  messaging.onMessageHandler = nextOrObserver;
  return () => {
    messaging.onMessageHandler = null;
  };
}
async function getToken3(messaging, options) {
  messaging = getModularInstance(messaging);
  return getToken$12(messaging, options);
}
function deleteToken(messaging) {
  messaging = getModularInstance(messaging);
  return deleteToken$1(messaging);
}
function onMessage(messaging, nextOrObserver) {
  messaging = getModularInstance(messaging);
  return onMessage$1(messaging, nextOrObserver);
}
registerMessagingInWindow();

// node_modules/@firebase/messaging/dist/index.sw.esm2017.js
var DEFAULT_VAPID_KEY2 = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT2 = "https://fcmregistrations.googleapis.com/v1";
var FCM_MSG = "FCM_MSG";
var CONSOLE_CAMPAIGN_ID2 = "google.c.a.c_id";
var SDK_PLATFORM_WEB = 3;
var EVENT_MESSAGE_DELIVERED = 1;
var MessageType$12;
(function(MessageType3) {
  MessageType3[MessageType3["DATA_MESSAGE"] = 1] = "DATA_MESSAGE";
  MessageType3[MessageType3["DISPLAY_NOTIFICATION"] = 3] = "DISPLAY_NOTIFICATION";
})(MessageType$12 || (MessageType$12 = {}));
var MessageType2;
(function(MessageType3) {
  MessageType3["PUSH_RECEIVED"] = "push-received";
  MessageType3["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType2 || (MessageType2 = {}));
function arrayToBase642(array) {
  const uint8Array = new Uint8Array(array);
  const base64String = btoa(String.fromCharCode(...uint8Array));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray2(base64String) {
  const padding = "=".repeat((4 - base64String.length % 4) % 4);
  const base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  const rawData = atob(base642);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME2 = "fcm_token_details_db";
var OLD_DB_VERSION2 = 5;
var OLD_OBJECT_STORE_NAME2 = "fcm_token_object_Store";
async function migrateOldDatabase2(senderId) {
  if ("databases" in indexedDB) {
    const databases = await indexedDB.databases();
    const dbNames = databases.map((db2) => db2.name);
    if (!dbNames.includes(OLD_DB_NAME2)) {
      return null;
    }
  }
  let tokenDetails = null;
  const db = await openDb(OLD_DB_NAME2, OLD_DB_VERSION2, async (db2) => {
    var _a2;
    if (db2.oldVersion < 2) {
      return;
    }
    if (!db2.objectStoreNames.contains(OLD_OBJECT_STORE_NAME2)) {
      return;
    }
    const objectStore = db2.transaction.objectStore(OLD_OBJECT_STORE_NAME2);
    const value = await objectStore.index("fcmSenderId").get(senderId);
    await objectStore.clear();
    if (!value) {
      return;
    }
    if (db2.oldVersion === 2) {
      const oldDetails = value;
      if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
        return;
      }
      tokenDetails = {
        token: oldDetails.fcmToken,
        createTime: (_a2 = oldDetails.createTime) !== null && _a2 !== void 0 ? _a2 : Date.now(),
        subscriptionOptions: {
          auth: oldDetails.auth,
          p256dh: oldDetails.p256dh,
          endpoint: oldDetails.endpoint,
          swScope: oldDetails.swScope,
          vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase642(oldDetails.vapidKey)
        }
      };
    } else if (db2.oldVersion === 3) {
      const oldDetails = value;
      tokenDetails = {
        token: oldDetails.fcmToken,
        createTime: oldDetails.createTime,
        subscriptionOptions: {
          auth: arrayToBase642(oldDetails.auth),
          p256dh: arrayToBase642(oldDetails.p256dh),
          endpoint: oldDetails.endpoint,
          swScope: oldDetails.swScope,
          vapidKey: arrayToBase642(oldDetails.vapidKey)
        }
      };
    } else if (db2.oldVersion === 4) {
      const oldDetails = value;
      tokenDetails = {
        token: oldDetails.fcmToken,
        createTime: oldDetails.createTime,
        subscriptionOptions: {
          auth: arrayToBase642(oldDetails.auth),
          p256dh: arrayToBase642(oldDetails.p256dh),
          endpoint: oldDetails.endpoint,
          swScope: oldDetails.swScope,
          vapidKey: arrayToBase642(oldDetails.vapidKey)
        }
      };
    }
  });
  db.close();
  await deleteDb(OLD_DB_NAME2);
  await deleteDb("fcm_vapid_details_db");
  await deleteDb("undefined");
  return checkTokenDetails2(tokenDetails) ? tokenDetails : null;
}
function checkTokenDetails2(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  const { subscriptionOptions } = tokenDetails;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME3 = "firebase-messaging-database";
var DATABASE_VERSION3 = 1;
var OBJECT_STORE_NAME3 = "firebase-messaging-store";
var dbPromise4 = null;
function getDbPromise3() {
  if (!dbPromise4) {
    dbPromise4 = openDb(DATABASE_NAME3, DATABASE_VERSION3, (upgradeDb) => {
      switch (upgradeDb.oldVersion) {
        case 0:
          upgradeDb.createObjectStore(OBJECT_STORE_NAME3);
      }
    });
  }
  return dbPromise4;
}
async function dbGet2(firebaseDependencies) {
  const key = getKey3(firebaseDependencies);
  const db = await getDbPromise3();
  const tokenDetails = await db.transaction(OBJECT_STORE_NAME3).objectStore(OBJECT_STORE_NAME3).get(key);
  if (tokenDetails) {
    return tokenDetails;
  } else {
    const oldTokenDetails = await migrateOldDatabase2(firebaseDependencies.appConfig.senderId);
    if (oldTokenDetails) {
      await dbSet2(firebaseDependencies, oldTokenDetails);
      return oldTokenDetails;
    }
  }
}
async function dbSet2(firebaseDependencies, tokenDetails) {
  const key = getKey3(firebaseDependencies);
  const db = await getDbPromise3();
  const tx = db.transaction(OBJECT_STORE_NAME3, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME3).put(tokenDetails, key);
  await tx.complete;
  return tokenDetails;
}
async function dbRemove2(firebaseDependencies) {
  const key = getKey3(firebaseDependencies);
  const db = await getDbPromise3();
  const tx = db.transaction(OBJECT_STORE_NAME3, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME3).delete(key);
  await tx.complete;
}
function getKey3({ appConfig }) {
  return appConfig.appId;
}
var ERROR_MAP2 = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["only-available-in-window"]: "This method is available in a Window context.",
  ["only-available-in-sw"]: "This method is available in a service worker context.",
  ["permission-default"]: "The notification permission was not granted and dismissed instead.",
  ["permission-blocked"]: "The notification permission was not granted and blocked instead.",
  ["unsupported-browser"]: "This browser doesn't support the API's required to use the Firebase SDK.",
  ["indexed-db-unsupported"]: "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  ["failed-service-worker-registration"]: "We are unable to register the default service worker. {$browserErrorMessage}",
  ["token-subscribe-failed"]: "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  ["token-subscribe-no-token"]: "FCM returned no token when subscribing the user to push.",
  ["token-unsubscribe-failed"]: "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  ["token-update-failed"]: "A problem occurred while updating the user from FCM: {$errorInfo}",
  ["token-update-no-token"]: "FCM returned no token when updating the user to push.",
  ["use-sw-after-get-token"]: "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  ["invalid-sw-registration"]: "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  ["invalid-bg-handler"]: "The input to setBackgroundMessageHandler() must be a function.",
  ["invalid-vapid-key"]: "The public VAPID key must be a string.",
  ["use-vapid-key-after-get-token"]: "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
};
var ERROR_FACTORY7 = new ErrorFactory("messaging", "Messaging", ERROR_MAP2);
async function requestGetToken2(firebaseDependencies, subscriptionOptions) {
  const headers = await getHeaders4(firebaseDependencies);
  const body = getBody2(subscriptionOptions);
  const subscribeOptions = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(getEndpoint2(firebaseDependencies.appConfig), subscribeOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY7.create("token-subscribe-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY7.create("token-subscribe-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY7.create("token-subscribe-no-token");
  }
  return responseData.token;
}
async function requestUpdateToken2(firebaseDependencies, tokenDetails) {
  const headers = await getHeaders4(firebaseDependencies);
  const body = getBody2(tokenDetails.subscriptionOptions);
  const updateOptions = {
    method: "PATCH",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(`${getEndpoint2(firebaseDependencies.appConfig)}/${tokenDetails.token}`, updateOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY7.create("token-update-failed", {
      errorInfo: err
    });
  }
  if (responseData.error) {
    const message = responseData.error.message;
    throw ERROR_FACTORY7.create("token-update-failed", {
      errorInfo: message
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY7.create("token-update-no-token");
  }
  return responseData.token;
}
async function requestDeleteToken2(firebaseDependencies, token) {
  const headers = await getHeaders4(firebaseDependencies);
  const unsubscribeOptions = {
    method: "DELETE",
    headers
  };
  try {
    const response = await fetch(`${getEndpoint2(firebaseDependencies.appConfig)}/${token}`, unsubscribeOptions);
    const responseData = await response.json();
    if (responseData.error) {
      const message = responseData.error.message;
      throw ERROR_FACTORY7.create("token-unsubscribe-failed", {
        errorInfo: message
      });
    }
  } catch (err) {
    throw ERROR_FACTORY7.create("token-unsubscribe-failed", {
      errorInfo: err
    });
  }
}
function getEndpoint2({ projectId }) {
  return `${ENDPOINT2}/projects/${projectId}/registrations`;
}
async function getHeaders4({ appConfig, installations }) {
  const authToken = await installations.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": appConfig.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${authToken}`
  });
}
function getBody2({ p256dh, auth, endpoint, vapidKey }) {
  const body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY2) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS2 = 7 * 24 * 60 * 60 * 1e3;
async function getTokenInternal2(messaging) {
  const pushSubscription = await getPushSubscription2(messaging.swRegistration, messaging.vapidKey);
  const subscriptionOptions = {
    vapidKey: messaging.vapidKey,
    swScope: messaging.swRegistration.scope,
    endpoint: pushSubscription.endpoint,
    auth: arrayToBase642(pushSubscription.getKey("auth")),
    p256dh: arrayToBase642(pushSubscription.getKey("p256dh"))
  };
  const tokenDetails = await dbGet2(messaging.firebaseDependencies);
  if (!tokenDetails) {
    return getNewToken2(messaging.firebaseDependencies, subscriptionOptions);
  } else if (!isTokenValid2(tokenDetails.subscriptionOptions, subscriptionOptions)) {
    try {
      await requestDeleteToken2(messaging.firebaseDependencies, tokenDetails.token);
    } catch (e) {
      console.warn(e);
    }
    return getNewToken2(messaging.firebaseDependencies, subscriptionOptions);
  } else if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS2) {
    return updateToken2(messaging, {
      token: tokenDetails.token,
      createTime: Date.now(),
      subscriptionOptions
    });
  } else {
    return tokenDetails.token;
  }
}
async function deleteTokenInternal2(messaging) {
  const tokenDetails = await dbGet2(messaging.firebaseDependencies);
  if (tokenDetails) {
    await requestDeleteToken2(messaging.firebaseDependencies, tokenDetails.token);
    await dbRemove2(messaging.firebaseDependencies);
  }
  const pushSubscription = await messaging.swRegistration.pushManager.getSubscription();
  if (pushSubscription) {
    return pushSubscription.unsubscribe();
  }
  return true;
}
async function updateToken2(messaging, tokenDetails) {
  try {
    const updatedToken = await requestUpdateToken2(messaging.firebaseDependencies, tokenDetails);
    const updatedTokenDetails = Object.assign(Object.assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
    await dbSet2(messaging.firebaseDependencies, updatedTokenDetails);
    return updatedToken;
  } catch (e) {
    await deleteTokenInternal2(messaging);
    throw e;
  }
}
async function getNewToken2(firebaseDependencies, subscriptionOptions) {
  const token = await requestGetToken2(firebaseDependencies, subscriptionOptions);
  const tokenDetails = {
    token,
    createTime: Date.now(),
    subscriptionOptions
  };
  await dbSet2(firebaseDependencies, tokenDetails);
  return tokenDetails.token;
}
async function getPushSubscription2(swRegistration, vapidKey) {
  const subscription = await swRegistration.pushManager.getSubscription();
  if (subscription) {
    return subscription;
  }
  return swRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: base64ToArray2(vapidKey)
  });
}
function isTokenValid2(dbOptions, currentOptions) {
  const isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  const isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  const isAuthEqual = currentOptions.auth === dbOptions.auth;
  const isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload2(internalPayload) {
  const payload = {
    from: internalPayload.from,
    collapseKey: internalPayload.collapse_key,
    messageId: internalPayload.fcmMessageId
  };
  propagateNotificationPayload2(payload, internalPayload);
  propagateDataPayload2(payload, internalPayload);
  propagateFcmOptions2(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload2(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  const title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  const body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  const image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload2(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions2(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.fcmOptions) {
    return;
  }
  payload.fcmOptions = {};
  const link = messagePayloadInternal.fcmOptions.link;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  const analyticsLabel = messagePayloadInternal.fcmOptions.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage2(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID2 in data;
}
function sleep3(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
_mergeStrings2("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
_mergeStrings2("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
async function stageLog(messaging, internalPayload) {
  const fcmEvent = createFcmEvent(internalPayload, await messaging.firebaseDependencies.installations.getId());
  createAndEnqueueLogEvent(messaging, fcmEvent);
}
function createFcmEvent(internalPayload, fid) {
  var _a2, _b;
  const fcmEvent = {};
  if (!!internalPayload.from) {
    fcmEvent.project_number = internalPayload.from;
  }
  if (!!internalPayload.fcmMessageId) {
    fcmEvent.message_id = internalPayload.fcmMessageId;
  }
  fcmEvent.instance_id = fid;
  if (!!internalPayload.notification) {
    fcmEvent.message_type = MessageType$12.DISPLAY_NOTIFICATION.toString();
  } else {
    fcmEvent.message_type = MessageType$12.DATA_MESSAGE.toString();
  }
  fcmEvent.sdk_platform = SDK_PLATFORM_WEB.toString();
  fcmEvent.package_name = self.origin.replace(/(^\w+:|^)\/\//, "");
  if (!!internalPayload.collapse_key) {
    fcmEvent.collapse_key = internalPayload.collapse_key;
  }
  fcmEvent.event = EVENT_MESSAGE_DELIVERED.toString();
  if (!!((_a2 = internalPayload.fcmOptions) === null || _a2 === void 0 ? void 0 : _a2.analytics_label)) {
    fcmEvent.analytics_label = (_b = internalPayload.fcmOptions) === null || _b === void 0 ? void 0 : _b.analytics_label;
  }
  return fcmEvent;
}
function createAndEnqueueLogEvent(messaging, fcmEvent) {
  const logEvent2 = {};
  logEvent2.event_time_ms = Math.floor(Date.now()).toString();
  logEvent2.source_extension_json_proto3 = JSON.stringify(fcmEvent);
  messaging.logEvents.push(logEvent2);
}
function _mergeStrings2(s1, s2) {
  const resultArray = [];
  for (let i = 0; i < s1.length; i++) {
    resultArray.push(s1.charAt(i));
    if (i < s2.length) {
      resultArray.push(s2.charAt(i));
    }
  }
  return resultArray.join("");
}
async function onSubChange(event, messaging) {
  var _a2, _b;
  const { newSubscription } = event;
  if (!newSubscription) {
    await deleteTokenInternal2(messaging);
    return;
  }
  const tokenDetails = await dbGet2(messaging.firebaseDependencies);
  await deleteTokenInternal2(messaging);
  messaging.vapidKey = (_b = (_a2 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a2 === void 0 ? void 0 : _a2.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY2;
  await getTokenInternal2(messaging);
}
async function onPush(event, messaging) {
  const internalPayload = getMessagePayloadInternal(event);
  if (!internalPayload) {
    return;
  }
  if (messaging.deliveryMetricsExportedToBigQueryEnabled) {
    await stageLog(messaging, internalPayload);
  }
  const clientList = await getClientList();
  if (hasVisibleClients(clientList)) {
    return sendMessagePayloadInternalToWindows(clientList, internalPayload);
  }
  if (!!internalPayload.notification) {
    await showNotification(wrapInternalPayload(internalPayload));
  }
  if (!messaging) {
    return;
  }
  if (!!messaging.onBackgroundMessageHandler) {
    const payload = externalizePayload2(internalPayload);
    if (typeof messaging.onBackgroundMessageHandler === "function") {
      await messaging.onBackgroundMessageHandler(payload);
    } else {
      messaging.onBackgroundMessageHandler.next(payload);
    }
  }
}
async function onNotificationClick(event) {
  var _a2, _b;
  const internalPayload = (_b = (_a2 = event.notification) === null || _a2 === void 0 ? void 0 : _a2.data) === null || _b === void 0 ? void 0 : _b[FCM_MSG];
  if (!internalPayload) {
    return;
  } else if (event.action) {
    return;
  }
  event.stopImmediatePropagation();
  event.notification.close();
  const link = getLink(internalPayload);
  if (!link) {
    return;
  }
  const url = new URL(link, self.location.href);
  const originUrl = new URL(self.location.origin);
  if (url.host !== originUrl.host) {
    return;
  }
  let client = await getWindowClient(url);
  if (!client) {
    client = await self.clients.openWindow(link);
    await sleep3(3e3);
  } else {
    client = await client.focus();
  }
  if (!client) {
    return;
  }
  internalPayload.messageType = MessageType2.NOTIFICATION_CLICKED;
  internalPayload.isFirebaseMessaging = true;
  return client.postMessage(internalPayload);
}
function wrapInternalPayload(internalPayload) {
  const wrappedInternalPayload = Object.assign({}, internalPayload.notification);
  wrappedInternalPayload.data = {
    [FCM_MSG]: internalPayload
  };
  return wrappedInternalPayload;
}
function getMessagePayloadInternal({ data }) {
  if (!data) {
    return null;
  }
  try {
    return data.json();
  } catch (err) {
    return null;
  }
}
async function getWindowClient(url) {
  const clientList = await getClientList();
  for (const client of clientList) {
    const clientUrl = new URL(client.url, self.location.href);
    if (url.host === clientUrl.host) {
      return client;
    }
  }
  return null;
}
function hasVisibleClients(clientList) {
  return clientList.some((client) => client.visibilityState === "visible" && !client.url.startsWith("chrome-extension://"));
}
function sendMessagePayloadInternalToWindows(clientList, internalPayload) {
  internalPayload.isFirebaseMessaging = true;
  internalPayload.messageType = MessageType2.PUSH_RECEIVED;
  for (const client of clientList) {
    client.postMessage(internalPayload);
  }
}
function getClientList() {
  return self.clients.matchAll({
    type: "window",
    includeUncontrolled: true
  });
}
function showNotification(notificationPayloadInternal) {
  var _a2;
  const { actions } = notificationPayloadInternal;
  const { maxActions } = Notification;
  if (actions && maxActions && actions.length > maxActions) {
    console.warn(`This browser only supports ${maxActions} actions. The remaining actions will not be displayed.`);
  }
  return self.registration.showNotification((_a2 = notificationPayloadInternal.title) !== null && _a2 !== void 0 ? _a2 : "", notificationPayloadInternal);
}
function getLink(payload) {
  var _a2, _b, _c;
  const link = (_b = (_a2 = payload.fcmOptions) === null || _a2 === void 0 ? void 0 : _a2.link) !== null && _b !== void 0 ? _b : (_c = payload.notification) === null || _c === void 0 ? void 0 : _c.click_action;
  if (link) {
    return link;
  }
  if (isConsoleMessage2(payload.data)) {
    return self.location.origin;
  } else {
    return null;
  }
}
function extractAppConfig3(app) {
  if (!app || !app.options) {
    throw getMissingValueError3("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError3("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  const { options } = app;
  for (const keyName of configKeys) {
    if (!options[keyName]) {
      throw getMissingValueError3(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError3(valueName) {
  return ERROR_FACTORY7.create("missing-app-config-values", {
    valueName
  });
}
var MessagingService2 = class {
  constructor(app, installations, analyticsProvider) {
    this.deliveryMetricsExportedToBigQueryEnabled = false;
    this.onBackgroundMessageHandler = null;
    this.onMessageHandler = null;
    this.logEvents = [];
    this.isLogServiceStarted = false;
    const appConfig = extractAppConfig3(app);
    this.firebaseDependencies = {
      app,
      appConfig,
      installations,
      analyticsProvider
    };
  }
  _delete() {
    return Promise.resolve();
  }
};
var SwMessagingFactory = (container) => {
  const messaging = new MessagingService2(container.getProvider("app").getImmediate(), container.getProvider("installations-internal").getImmediate(), container.getProvider("analytics-internal"));
  self.addEventListener("push", (e) => {
    e.waitUntil(onPush(e, messaging));
  });
  self.addEventListener("pushsubscriptionchange", (e) => {
    e.waitUntil(onSubChange(e, messaging));
  });
  self.addEventListener("notificationclick", (e) => {
    e.waitUntil(onNotificationClick(e));
  });
  return messaging;
};
function registerMessagingInSw() {
  _registerComponent(new Component("messaging-sw", SwMessagingFactory, "PUBLIC"));
}
function onBackgroundMessage$1(messaging, nextOrObserver) {
  if (self.document !== void 0) {
    throw ERROR_FACTORY7.create("only-available-in-sw");
  }
  messaging.onBackgroundMessageHandler = nextOrObserver;
  return () => {
    messaging.onBackgroundMessageHandler = null;
  };
}
function onBackgroundMessage(messaging, nextOrObserver) {
  messaging = getModularInstance(messaging);
  return onBackgroundMessage$1(messaging, nextOrObserver);
}
registerMessagingInSw();

// node_modules/@firebase/messaging-compat/dist/esm/index.esm2017.js
var name13 = "@firebase/messaging-compat";
var version13 = "0.1.9";
function isSupported2() {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return isSwSupported();
  } else {
    return isWindowSupported();
  }
}
function isWindowSupported() {
  return typeof window !== "undefined" && isIndexedDBAvailable() && areCookiesEnabled() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
function isSwSupported() {
  return isIndexedDBAvailable() && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
var MessagingCompatImpl = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
    this.app = app;
    this._delegate = _delegate;
  }
  async getToken(options) {
    return getToken3(this._delegate, options);
  }
  async deleteToken() {
    return deleteToken(this._delegate);
  }
  onMessage(nextOrObserver) {
    return onMessage(this._delegate, nextOrObserver);
  }
  onBackgroundMessage(nextOrObserver) {
    return onBackgroundMessage(this._delegate, nextOrObserver);
  }
};
var messagingCompatFactory = (container) => {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return new MessagingCompatImpl(container.getProvider("app-compat").getImmediate(), container.getProvider("messaging-sw").getImmediate());
  } else {
    return new MessagingCompatImpl(container.getProvider("app-compat").getImmediate(), container.getProvider("messaging").getImmediate());
  }
};
var NAMESPACE_EXPORTS = {
  isSupported: isSupported2
};
function registerMessagingCompat() {
  firebase.INTERNAL.registerComponent(new Component("messaging-compat", messagingCompatFactory, "PUBLIC").setServiceProps(NAMESPACE_EXPORTS));
}
registerMessagingCompat();
firebase.registerVersion(name13, version13);

// node_modules/@firebase/storage/dist/index.esm2017.js
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var StorageError = class extends FirebaseError {
  constructor(code, message) {
    super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);
    this.customData = { serverResponse: null };
    this._baseMessage = this.message;
    Object.setPrototypeOf(this, StorageError.prototype);
  }
  _codeEquals(code) {
    return prependCode(code) === this.code;
  }
  get serverResponse() {
    return this.customData.serverResponse;
  }
  set serverResponse(serverResponse) {
    this.customData.serverResponse = serverResponse;
    if (this.customData.serverResponse) {
      this.message = `${this._baseMessage}
${this.customData.serverResponse}`;
    } else {
      this.message = this._baseMessage;
    }
  }
};
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  const message = "An unknown error occurred, please check the error payload for server response.";
  return new StorageError("unknown", message);
}
function objectNotFound(path) {
  return new StorageError("object-not-found", "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new StorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  const message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new StorageError("unauthenticated", message);
}
function unauthorizedApp() {
  return new StorageError("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.");
}
function unauthorized(path) {
  return new StorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new StorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new StorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new StorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new StorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new StorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
  return new StorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
  return new StorageError("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
  return new StorageError("no-download-url", "The given file does not have any download URLs.");
}
function invalidArgument(message) {
  return new StorageError("invalid-argument", message);
}
function appDeleted() {
  return new StorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name21) {
  return new StorageError("invalid-root-operation", "The operation '" + name21 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new StorageError("invalid-format", "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new StorageError("internal-error", "Internal error: " + message);
}
var Location = class {
  constructor(bucket, path) {
    this.bucket = bucket;
    this.path_ = path;
  }
  get path() {
    return this.path_;
  }
  get isRoot() {
    return this.path.length === 0;
  }
  fullServerUrl() {
    const encode3 = encodeURIComponent;
    return "/b/" + encode3(this.bucket) + "/o/" + encode3(this.path);
  }
  bucketOnlyServerUrl() {
    const encode3 = encodeURIComponent;
    return "/b/" + encode3(this.bucket) + "/o";
  }
  static makeFromBucketSpec(bucketString, host) {
    let bucketLocation;
    try {
      bucketLocation = Location.makeFromUrl(bucketString, host);
    } catch (e) {
      return new Location(bucketString, "");
    }
    if (bucketLocation.path === "") {
      return bucketLocation;
    } else {
      throw invalidDefaultBucket(bucketString);
    }
  }
  static makeFromUrl(url, host) {
    let location = null;
    const bucketDomain = "([A-Za-z0-9.\\-_]+)";
    function gsModify(loc) {
      if (loc.path.charAt(loc.path.length - 1) === "/") {
        loc.path_ = loc.path_.slice(0, -1);
      }
    }
    const gsPath = "(/(.*))?$";
    const gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
    const gsIndices = { bucket: 1, path: 3 };
    function httpModify(loc) {
      loc.path_ = decodeURIComponent(loc.path);
    }
    const version21 = "v[A-Za-z0-9_]+";
    const firebaseStorageHost = host.replace(/[.]/g, "\\.");
    const firebaseStoragePath = "(/([^?#]*).*)?$";
    const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version21}/b/${bucketDomain}/o${firebaseStoragePath}`, "i");
    const firebaseStorageIndices = { bucket: 1, path: 3 };
    const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
    const cloudStoragePath = "([^?#]*)";
    const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, "i");
    const cloudStorageIndices = { bucket: 1, path: 2 };
    const groups = [
      { regex: gsRegex, indices: gsIndices, postModify: gsModify },
      {
        regex: firebaseStorageRegExp,
        indices: firebaseStorageIndices,
        postModify: httpModify
      },
      {
        regex: cloudStorageRegExp,
        indices: cloudStorageIndices,
        postModify: httpModify
      }
    ];
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      const captures = group.regex.exec(url);
      if (captures) {
        const bucketValue = captures[group.indices.bucket];
        let pathValue = captures[group.indices.path];
        if (!pathValue) {
          pathValue = "";
        }
        location = new Location(bucketValue, pathValue);
        group.postModify(location);
        break;
      }
    }
    if (location == null) {
      throw invalidUrl(url);
    }
    return location;
  }
};
var FailRequest = class {
  constructor(error) {
    this.promise_ = Promise.reject(error);
  }
  getPromise() {
    return this.promise_;
  }
  cancel(_appDelete = false) {
  }
};
function start(f, callback, timeout) {
  let waitSeconds = 1;
  let retryTimeoutId = null;
  let globalTimeoutId = null;
  let hitTimeout = false;
  let cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  let triggeredCallback = false;
  function triggerCallback(...args) {
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    retryTimeoutId = setTimeout(() => {
      retryTimeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function clearGlobalTimeout() {
    if (globalTimeoutId) {
      clearTimeout(globalTimeoutId);
    }
  }
  function handler(success, ...args) {
    if (triggeredCallback) {
      clearGlobalTimeout();
      return;
    }
    if (success) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    const mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    let waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  let stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    clearGlobalTimeout();
    if (triggeredCallback) {
      return;
    }
    if (retryTimeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(retryTimeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  globalTimeoutId = setTimeout(() => {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id) {
  id(false);
}
function isJustDef(p) {
  return p !== void 0;
}
function isFunction(p) {
  return typeof p === "function";
}
function isNonArrayObject(p) {
  return typeof p === "object" && !Array.isArray(p);
}
function isString(p) {
  return typeof p === "string" || p instanceof String;
}
function isNativeBlob(p) {
  return isNativeBlobDefined() && p instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
  }
  if (value > maxValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
  }
}
function makeUrl(urlPart, host, protocol) {
  let origin = host;
  if (protocol == null) {
    origin = `https://${host}`;
  }
  return `${protocol}://${origin}/v0${urlPart}`;
}
function makeQueryString(params) {
  const encode3 = encodeURIComponent;
  let queryPart = "?";
  for (const key in params) {
    if (params.hasOwnProperty(key)) {
      const nextPart = encode3(key) + "=" + encode3(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode2[ErrorCode2["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode2[ErrorCode2["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));
var NetworkRequest = class {
  constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_) {
    this.url_ = url_;
    this.method_ = method_;
    this.headers_ = headers_;
    this.body_ = body_;
    this.successCodes_ = successCodes_;
    this.additionalRetryCodes_ = additionalRetryCodes_;
    this.callback_ = callback_;
    this.errorCallback_ = errorCallback_;
    this.timeout_ = timeout_;
    this.progressCallback_ = progressCallback_;
    this.connectionFactory_ = connectionFactory_;
    this.pendingConnection_ = null;
    this.backoffId_ = null;
    this.canceled_ = false;
    this.appDelete_ = false;
    this.promise_ = new Promise((resolve, reject) => {
      this.resolve_ = resolve;
      this.reject_ = reject;
      this.start_();
    });
  }
  start_() {
    const doTheRequest = (backoffCallback, canceled2) => {
      if (canceled2) {
        backoffCallback(false, new RequestEndStatus(false, null, true));
        return;
      }
      const connection = this.connectionFactory_();
      this.pendingConnection_ = connection;
      const progressListener = (progressEvent) => {
        const loaded = progressEvent.loaded;
        const total = progressEvent.lengthComputable ? progressEvent.total : -1;
        if (this.progressCallback_ !== null) {
          this.progressCallback_(loaded, total);
        }
      };
      if (this.progressCallback_ !== null) {
        connection.addUploadProgressListener(progressListener);
      }
      connection.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
        if (this.progressCallback_ !== null) {
          connection.removeUploadProgressListener(progressListener);
        }
        this.pendingConnection_ = null;
        const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
        const status = connection.getStatus();
        if (!hitServer || this.isRetryStatusCode_(status)) {
          const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;
          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
          return;
        }
        const successCode = this.successCodes_.indexOf(status) !== -1;
        backoffCallback(true, new RequestEndStatus(successCode, connection));
      });
    };
    const backoffDone = (requestWentThrough, status) => {
      const resolve = this.resolve_;
      const reject = this.reject_;
      const connection = status.connection;
      if (status.wasSuccessCode) {
        try {
          const result = this.callback_(connection, connection.getResponse());
          if (isJustDef(result)) {
            resolve(result);
          } else {
            resolve();
          }
        } catch (e) {
          reject(e);
        }
      } else {
        if (connection !== null) {
          const err = unknown();
          err.serverResponse = connection.getErrorText();
          if (this.errorCallback_) {
            reject(this.errorCallback_(connection, err));
          } else {
            reject(err);
          }
        } else {
          if (status.canceled) {
            const err = this.appDelete_ ? appDeleted() : canceled();
            reject(err);
          } else {
            const err = retryLimitExceeded();
            reject(err);
          }
        }
      }
    };
    if (this.canceled_) {
      backoffDone(false, new RequestEndStatus(false, null, true));
    } else {
      this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
    }
  }
  getPromise() {
    return this.promise_;
  }
  cancel(appDelete) {
    this.canceled_ = true;
    this.appDelete_ = appDelete || false;
    if (this.backoffId_ !== null) {
      stop(this.backoffId_);
    }
    if (this.pendingConnection_ !== null) {
      this.pendingConnection_.abort();
    }
  }
  isRetryStatusCode_(status) {
    const isFiveHundredCode = status >= 500 && status < 600;
    const extraRetryCodes = [
      408,
      429
    ];
    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
    const isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
  }
};
var RequestEndStatus = class {
  constructor(wasSuccessCode, connection, canceled2) {
    this.wasSuccessCode = wasSuccessCode;
    this.connection = connection;
    this.canceled = !!canceled2;
  }
};
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function addAppCheckHeader_(headers, appCheckToken) {
  if (appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = appCheckToken;
  }
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion) {
  const queryPart = makeQueryString(requestInfo.urlParams);
  const url = requestInfo.url + queryPart;
  const headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  addAppCheckHeader_(headers, appCheckToken);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory);
}
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob$1(...args) {
  const BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    const bb = new BlobBuilder2();
    for (let i = 0; i < args.length; i++) {
      bb.append(args[i]);
    }
    return bb.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw new StorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
function decodeBase64(encoded) {
  return atob(encoded);
}
var StringFormat = {
  RAW: "raw",
  BASE64: "base64",
  BASE64URL: "base64url",
  DATA_URL: "data_url"
};
var StringData = class {
  constructor(data, contentType) {
    this.data = data;
    this.contentType = contentType || null;
  }
};
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  const b = [];
  for (let i = 0; i < value.length; i++) {
    let c = value.charCodeAt(i);
    if (c <= 127) {
      b.push(c);
    } else {
      if (c <= 2047) {
        b.push(192 | c >> 6, 128 | c & 63);
      } else {
        if ((c & 64512) === 55296) {
          const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
          if (!valid) {
            b.push(239, 191, 189);
          } else {
            const hi = c;
            const lo = value.charCodeAt(++i);
            c = 65536 | (hi & 1023) << 10 | lo & 1023;
            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
          }
        } else {
          if ((c & 64512) === 56320) {
            b.push(239, 191, 189);
          } else {
            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b);
}
function percentEncodedBytes_(value) {
  let decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      const hasMinus = value.indexOf("-") !== -1;
      const hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        const invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      const hasPlus = value.indexOf("+") !== -1;
      const hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        const invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  let bytes;
  try {
    bytes = decodeBase64(value);
  } catch (e) {
    throw invalidFormat(format, "Invalid character found");
  }
  const array = new Uint8Array(bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    array[i] = bytes.charCodeAt(i);
  }
  return array;
}
var DataURLParts = class {
  constructor(dataURL) {
    this.base64 = false;
    this.contentType = null;
    const matches = dataURL.match(/^data:([^,]+)?,/);
    if (matches === null) {
      throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
    }
    const middle = matches[1] || null;
    if (middle != null) {
      this.base64 = endsWith(middle, ";base64");
      this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
    }
    this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
  }
};
function dataURLBytes_(dataUrl) {
  const parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  const parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s, end) {
  const longEnough = s.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s.substring(s.length - end.length) === end;
}
var FbsBlob = class {
  constructor(data, elideCopy) {
    let size = 0;
    let blobType = "";
    if (isNativeBlob(data)) {
      this.data_ = data;
      size = data.size;
      blobType = data.type;
    } else if (data instanceof ArrayBuffer) {
      if (elideCopy) {
        this.data_ = new Uint8Array(data);
      } else {
        this.data_ = new Uint8Array(data.byteLength);
        this.data_.set(new Uint8Array(data));
      }
      size = this.data_.length;
    } else if (data instanceof Uint8Array) {
      if (elideCopy) {
        this.data_ = data;
      } else {
        this.data_ = new Uint8Array(data.length);
        this.data_.set(data);
      }
      size = data.length;
    }
    this.size_ = size;
    this.type_ = blobType;
  }
  size() {
    return this.size_;
  }
  type() {
    return this.type_;
  }
  slice(startByte, endByte) {
    if (isNativeBlob(this.data_)) {
      const realBlob = this.data_;
      const sliced = sliceBlob(realBlob, startByte, endByte);
      if (sliced === null) {
        return null;
      }
      return new FbsBlob(sliced);
    } else {
      const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
      return new FbsBlob(slice, true);
    }
  }
  static getBlob(...args) {
    if (isNativeBlobDefined()) {
      const blobby = args.map((val) => {
        if (val instanceof FbsBlob) {
          return val.data_;
        } else {
          return val;
        }
      });
      return new FbsBlob(getBlob$1.apply(null, blobby));
    } else {
      const uint8Arrays = args.map((val) => {
        if (isString(val)) {
          return dataFromString(StringFormat.RAW, val).data;
        } else {
          return val.data_;
        }
      });
      let finalLength = 0;
      uint8Arrays.forEach((array) => {
        finalLength += array.byteLength;
      });
      const merged = new Uint8Array(finalLength);
      let index = 0;
      uint8Arrays.forEach((array) => {
        for (let i = 0; i < array.length; i++) {
          merged[index++] = array[i];
        }
      });
      return new FbsBlob(merged, true);
    }
  }
  uploadData() {
    return this.data_;
  }
};
function jsonObjectOrNull(s) {
  let obj;
  try {
    obj = JSON.parse(s);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  const index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  const newPath = path.slice(0, index);
  return newPath;
}
function child2(path, childPath) {
  const canonicalChildPath = childPath.split("/").filter((component) => component.length > 0).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  const index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = class {
  constructor(server, local, writable, xform) {
    this.server = server;
    this.local = local || server;
    this.writable = !!writable;
    this.xform = xform || noXform_;
  }
};
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  const mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  const nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (size !== void 0) {
      return Number(size);
    } else {
      return size;
    }
  }
  const sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  const metadata = {};
  metadata["type"] = "file";
  const len = mappings.length;
  for (let i = 0; i < len; i++) {
    const mapping = mappings[i];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  const resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString, host, protocol) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  const tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  const encode3 = encodeURIComponent;
  const tokensList = tokens.split(",");
  const urls = tokensList.map((token) => {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const urlPart = "/b/" + encode3(bucket) + "/o/" + encode3(path);
    const base = makeUrl(urlPart, host, protocol);
    const queryString = makeQueryString({
      alt: "media",
      token
    });
    return base + queryString;
  });
  return urls[0];
}
function toResourceString(metadata, mappings) {
  const resource = {};
  const len = mappings.length;
  for (let i = 0; i < len; i++) {
    const mapping = mappings[i];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
  const listResult = {
    prefixes: [],
    items: [],
    nextPageToken: resource["nextPageToken"]
  };
  if (resource[PREFIXES_KEY]) {
    for (const path of resource[PREFIXES_KEY]) {
      const pathWithoutTrailingSlash = path.replace(/\/$/, "");
      const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
      listResult.prefixes.push(reference);
    }
  }
  if (resource[ITEMS_KEY]) {
    for (const item of resource[ITEMS_KEY]) {
      const reference = service._makeStorageReference(new Location(bucket, item["name"]));
      listResult.items.push(reference);
    }
  }
  return listResult;
}
function fromResponseString(service, bucket, resourceString) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  const resource = obj;
  return fromBackendResponse(service, bucket, resource);
}
var RequestInfo = class {
  constructor(url, method, handler, timeout) {
    this.url = url;
    this.method = method;
    this.handler = handler;
    this.timeout = timeout;
    this.urlParams = {};
    this.headers = {};
    this.body = null;
    this.errorHandler = null;
    this.progressCallback = null;
    this.successCodes = [200];
    this.additionalRetryCodes = [];
  }
};
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    const metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function listHandler(service, bucket) {
  function handler(xhr, text) {
    const listResult = fromResponseString(service, bucket, text);
    handlerCheck(listResult !== null);
    return listResult;
  }
  return handler;
}
function downloadUrlHandler(service, mappings) {
  function handler(xhr, text) {
    const metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);
  }
  return handler;
}
function sharedErrorHandler(location) {
  function errorHandler(xhr, err) {
    let newErr;
    if (xhr.getStatus() === 401) {
      if (xhr.getErrorText().includes("Firebase App Check token is invalid")) {
        newErr = unauthorizedApp();
      } else {
        newErr = unauthenticated();
      }
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location) {
  const shared = sharedErrorHandler(location);
  function errorHandler(xhr, err) {
    let newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location.path);
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function getMetadata$2(service, location, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function list$2(service, location, delimiter, pageToken, maxResults) {
  const urlParams = {};
  if (location.isRoot) {
    urlParams["prefix"] = "";
  } else {
    urlParams["prefix"] = location.path + "/";
  }
  if (delimiter && delimiter.length > 0) {
    urlParams["delimiter"] = delimiter;
  }
  if (pageToken) {
    urlParams["pageToken"] = pageToken;
  }
  if (maxResults) {
    urlParams["maxResults"] = maxResults;
  }
  const urlPart = location.bucketOnlyServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getDownloadUrl(service, location, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function updateMetadata$2(service, location, metadata, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "PATCH";
  const body = toResourceString(metadata, mappings);
  const headers = { "Content-Type": "application/json; charset=utf-8" };
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function deleteObject$2(service, location) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "DELETE";
  const timeout = service.maxOperationRetryTime;
  function handler(_xhr, _text) {
  }
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.successCodes = [200, 204];
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location, blob, metadata) {
  const metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location, mappings, blob, metadata) {
  const urlPart = location.bucketOnlyServerUrl();
  const headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    let str = "";
    for (let i = 0; i < 2; i++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  const boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  const metadata_ = metadataForUpload_(location, blob, metadata);
  const metadataString = toResourceString(metadata_, mappings);
  const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  const postBlobPart = "\r\n--" + boundary + "--";
  const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  const urlParams = { name: metadata_["fullPath"] };
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var ResumableUploadStatus = class {
  constructor(current, total, finalized, metadata) {
    this.current = current;
    this.total = total;
    this.finalized = !!finalized;
    this.metadata = metadata || null;
  }
};
function checkResumeHeader_(xhr, allowed) {
  let status = null;
  try {
    status = xhr.getResponseHeader("X-Goog-Upload-Status");
  } catch (e) {
    handlerCheck(false);
  }
  const allowedStatus = allowed || ["active"];
  handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
  return status;
}
function createResumableUpload(service, location, mappings, blob, metadata) {
  const urlPart = location.bucketOnlyServerUrl();
  const metadataForUpload = metadataForUpload_(location, blob, metadata);
  const urlParams = { name: metadataForUpload["fullPath"] };
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "POST";
  const headers = {
    "X-Goog-Upload-Protocol": "resumable",
    "X-Goog-Upload-Command": "start",
    "X-Goog-Upload-Header-Content-Length": `${blob.size()}`,
    "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
    "Content-Type": "application/json; charset=utf-8"
  };
  const body = toResourceString(metadataForUpload, mappings);
  const timeout = service.maxUploadRetryTime;
  function handler(xhr) {
    checkResumeHeader_(xhr);
    let url2;
    try {
      url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
    } catch (e) {
      handlerCheck(false);
    }
    handlerCheck(isString(url2));
    return url2;
  }
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
function getResumableUploadStatus(service, location, url, blob) {
  const headers = { "X-Goog-Upload-Command": "query" };
  function handler(xhr) {
    const status = checkResumeHeader_(xhr, ["active", "final"]);
    let sizeString = null;
    try {
      sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
    } catch (e) {
      handlerCheck(false);
    }
    if (!sizeString) {
      handlerCheck(false);
    }
    const size = Number(sizeString);
    handlerCheck(!isNaN(size));
    return new ResumableUploadStatus(size, blob.size(), status === "final");
  }
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {
  const status_ = new ResumableUploadStatus(0, 0);
  if (status) {
    status_.current = status.current;
    status_.total = status.total;
  } else {
    status_.current = 0;
    status_.total = blob.size();
  }
  if (blob.size() !== status_.total) {
    throw serverFileWrongSize();
  }
  const bytesLeft = status_.total - status_.current;
  let bytesToUpload = bytesLeft;
  if (chunkSize > 0) {
    bytesToUpload = Math.min(bytesToUpload, chunkSize);
  }
  const startByte = status_.current;
  const endByte = startByte + bytesToUpload;
  const uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
  const headers = {
    "X-Goog-Upload-Command": uploadCommand,
    "X-Goog-Upload-Offset": `${status_.current}`
  };
  const body = blob.slice(startByte, endByte);
  if (body === null) {
    throw cannotSliceBlob();
  }
  function handler(xhr, text) {
    const uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
    const newCurrent = status_.current + bytesToUpload;
    const size = blob.size();
    let metadata;
    if (uploadStatus === "final") {
      metadata = metadataHandler(service, mappings)(xhr, text);
    } else {
      metadata = null;
    }
    return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
  }
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.progressCallback = progressCallback || null;
  requestInfo.errorHandler = sharedErrorHandler(location);
  return requestInfo;
}
var TaskEvent = {
  STATE_CHANGED: "state_changed"
};
var TaskState = {
  RUNNING: "running",
  PAUSED: "paused",
  SUCCESS: "success",
  CANCELED: "canceled",
  ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
  switch (state) {
    case "running":
    case "pausing":
    case "canceling":
      return TaskState.RUNNING;
    case "paused":
      return TaskState.PAUSED;
    case "success":
      return TaskState.SUCCESS;
    case "canceled":
      return TaskState.CANCELED;
    case "error":
      return TaskState.ERROR;
    default:
      return TaskState.ERROR;
  }
}
var Observer = class {
  constructor(nextOrObserver, error, complete) {
    const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;
    if (asFunctions) {
      this.next = nextOrObserver;
      this.error = error !== null && error !== void 0 ? error : void 0;
      this.complete = complete !== null && complete !== void 0 ? complete : void 0;
    } else {
      const observer = nextOrObserver;
      this.next = observer.next;
      this.error = observer.error;
      this.complete = observer.complete;
    }
  }
};
function async(f) {
  return (...argsToForward) => {
    Promise.resolve().then(() => f(...argsToForward));
  };
}
var textFactoryOverride = null;
var XhrConnection = class {
  constructor() {
    this.sent_ = false;
    this.xhr_ = new XMLHttpRequest();
    this.initXhr();
    this.errorCode_ = ErrorCode.NO_ERROR;
    this.sendPromise_ = new Promise((resolve) => {
      this.xhr_.addEventListener("abort", () => {
        this.errorCode_ = ErrorCode.ABORT;
        resolve();
      });
      this.xhr_.addEventListener("error", () => {
        this.errorCode_ = ErrorCode.NETWORK_ERROR;
        resolve();
      });
      this.xhr_.addEventListener("load", () => {
        resolve();
      });
    });
  }
  send(url, method, body, headers) {
    if (this.sent_) {
      throw internalError("cannot .send() more than once");
    }
    this.sent_ = true;
    this.xhr_.open(method, url, true);
    if (headers !== void 0) {
      for (const key in headers) {
        if (headers.hasOwnProperty(key)) {
          this.xhr_.setRequestHeader(key, headers[key].toString());
        }
      }
    }
    if (body !== void 0) {
      this.xhr_.send(body);
    } else {
      this.xhr_.send();
    }
    return this.sendPromise_;
  }
  getErrorCode() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorCode() before sending");
    }
    return this.errorCode_;
  }
  getStatus() {
    if (!this.sent_) {
      throw internalError("cannot .getStatus() before sending");
    }
    try {
      return this.xhr_.status;
    } catch (e) {
      return -1;
    }
  }
  getResponse() {
    if (!this.sent_) {
      throw internalError("cannot .getResponse() before sending");
    }
    return this.xhr_.response;
  }
  getErrorText() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorText() before sending");
    }
    return this.xhr_.statusText;
  }
  abort() {
    this.xhr_.abort();
  }
  getResponseHeader(header) {
    return this.xhr_.getResponseHeader(header);
  }
  addUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.addEventListener("progress", listener);
    }
  }
  removeUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.removeEventListener("progress", listener);
    }
  }
};
var XhrTextConnection = class extends XhrConnection {
  initXhr() {
    this.xhr_.responseType = "text";
  }
};
function newTextConnection() {
  return textFactoryOverride ? textFactoryOverride() : new XhrTextConnection();
}
var UploadTask = class {
  constructor(ref3, blob, metadata = null) {
    this._transferred = 0;
    this._needToFetchStatus = false;
    this._needToFetchMetadata = false;
    this._observers = [];
    this._error = void 0;
    this._uploadUrl = void 0;
    this._request = void 0;
    this._chunkMultiplier = 1;
    this._resolve = void 0;
    this._reject = void 0;
    this._ref = ref3;
    this._blob = blob;
    this._metadata = metadata;
    this._mappings = getMappings();
    this._resumable = this._shouldDoResumable(this._blob);
    this._state = "running";
    this._errorHandler = (error) => {
      this._request = void 0;
      this._chunkMultiplier = 1;
      if (error._codeEquals("canceled")) {
        this._needToFetchStatus = true;
        this.completeTransitions_();
      } else {
        this._error = error;
        this._transition("error");
      }
    };
    this._metadataErrorHandler = (error) => {
      this._request = void 0;
      if (error._codeEquals("canceled")) {
        this.completeTransitions_();
      } else {
        this._error = error;
        this._transition("error");
      }
    };
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
      this._start();
    });
    this._promise.then(null, () => {
    });
  }
  _makeProgressCallback() {
    const sizeBefore = this._transferred;
    return (loaded) => this._updateProgress(sizeBefore + loaded);
  }
  _shouldDoResumable(blob) {
    return blob.size() > 256 * 1024;
  }
  _start() {
    if (this._state !== "running") {
      return;
    }
    if (this._request !== void 0) {
      return;
    }
    if (this._resumable) {
      if (this._uploadUrl === void 0) {
        this._createResumable();
      } else {
        if (this._needToFetchStatus) {
          this._fetchStatus();
        } else {
          if (this._needToFetchMetadata) {
            this._fetchMetadata();
          } else {
            this._continueUpload();
          }
        }
      }
    } else {
      this._oneShotUpload();
    }
  }
  _resolveToken(callback) {
    Promise.all([
      this._ref.storage._getAuthToken(),
      this._ref.storage._getAppCheckToken()
    ]).then(([authToken, appCheckToken]) => {
      switch (this._state) {
        case "running":
          callback(authToken, appCheckToken);
          break;
        case "canceling":
          this._transition("canceled");
          break;
        case "pausing":
          this._transition("paused");
          break;
      }
    });
  }
  _createResumable() {
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
      const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = createRequest;
      createRequest.getPromise().then((url) => {
        this._request = void 0;
        this._uploadUrl = url;
        this._needToFetchStatus = false;
        this.completeTransitions_();
      }, this._errorHandler);
    });
  }
  _fetchStatus() {
    const url = this._uploadUrl;
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);
      const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = statusRequest;
      statusRequest.getPromise().then((status) => {
        status = status;
        this._request = void 0;
        this._updateProgress(status.current);
        this._needToFetchStatus = false;
        if (status.finalized) {
          this._needToFetchMetadata = true;
        }
        this.completeTransitions_();
      }, this._errorHandler);
    });
  }
  _continueUpload() {
    const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
    const status = new ResumableUploadStatus(this._transferred, this._blob.size());
    const url = this._uploadUrl;
    this._resolveToken((authToken, appCheckToken) => {
      let requestInfo;
      try {
        requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());
      } catch (e) {
        this._error = e;
        this._transition("error");
        return;
      }
      const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = uploadRequest;
      uploadRequest.getPromise().then((newStatus) => {
        this._increaseMultiplier();
        this._request = void 0;
        this._updateProgress(newStatus.current);
        if (newStatus.finalized) {
          this._metadata = newStatus.metadata;
          this._transition("success");
        } else {
          this.completeTransitions_();
        }
      }, this._errorHandler);
    });
  }
  _increaseMultiplier() {
    const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
    if (currentSize < 32 * 1024 * 1024) {
      this._chunkMultiplier *= 2;
    }
  }
  _fetchMetadata() {
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);
      const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = metadataRequest;
      metadataRequest.getPromise().then((metadata) => {
        this._request = void 0;
        this._metadata = metadata;
        this._transition("success");
      }, this._metadataErrorHandler);
    });
  }
  _oneShotUpload() {
    this._resolveToken((authToken, appCheckToken) => {
      const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
      const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
      this._request = multipartRequest;
      multipartRequest.getPromise().then((metadata) => {
        this._request = void 0;
        this._metadata = metadata;
        this._updateProgress(this._blob.size());
        this._transition("success");
      }, this._errorHandler);
    });
  }
  _updateProgress(transferred) {
    const old = this._transferred;
    this._transferred = transferred;
    if (this._transferred !== old) {
      this._notifyObservers();
    }
  }
  _transition(state) {
    if (this._state === state) {
      return;
    }
    switch (state) {
      case "canceling":
        this._state = state;
        if (this._request !== void 0) {
          this._request.cancel();
        }
        break;
      case "pausing":
        this._state = state;
        if (this._request !== void 0) {
          this._request.cancel();
        }
        break;
      case "running":
        const wasPaused = this._state === "paused";
        this._state = state;
        if (wasPaused) {
          this._notifyObservers();
          this._start();
        }
        break;
      case "paused":
        this._state = state;
        this._notifyObservers();
        break;
      case "canceled":
        this._error = canceled();
        this._state = state;
        this._notifyObservers();
        break;
      case "error":
        this._state = state;
        this._notifyObservers();
        break;
      case "success":
        this._state = state;
        this._notifyObservers();
        break;
    }
  }
  completeTransitions_() {
    switch (this._state) {
      case "pausing":
        this._transition("paused");
        break;
      case "canceling":
        this._transition("canceled");
        break;
      case "running":
        this._start();
        break;
    }
  }
  get snapshot() {
    const externalState = taskStateFromInternalTaskState(this._state);
    return {
      bytesTransferred: this._transferred,
      totalBytes: this._blob.size(),
      state: externalState,
      metadata: this._metadata,
      task: this,
      ref: this._ref
    };
  }
  on(type, nextOrObserver, error, completed) {
    const observer = new Observer(nextOrObserver || void 0, error || void 0, completed || void 0);
    this._addObserver(observer);
    return () => {
      this._removeObserver(observer);
    };
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this.then(null, onRejected);
  }
  _addObserver(observer) {
    this._observers.push(observer);
    this._notifyObserver(observer);
  }
  _removeObserver(observer) {
    const i = this._observers.indexOf(observer);
    if (i !== -1) {
      this._observers.splice(i, 1);
    }
  }
  _notifyObservers() {
    this._finishPromise();
    const observers = this._observers.slice();
    observers.forEach((observer) => {
      this._notifyObserver(observer);
    });
  }
  _finishPromise() {
    if (this._resolve !== void 0) {
      let triggered = true;
      switch (taskStateFromInternalTaskState(this._state)) {
        case TaskState.SUCCESS:
          async(this._resolve.bind(null, this.snapshot))();
          break;
        case TaskState.CANCELED:
        case TaskState.ERROR:
          const toCall = this._reject;
          async(toCall.bind(null, this._error))();
          break;
        default:
          triggered = false;
          break;
      }
      if (triggered) {
        this._resolve = void 0;
        this._reject = void 0;
      }
    }
  }
  _notifyObserver(observer) {
    const externalState = taskStateFromInternalTaskState(this._state);
    switch (externalState) {
      case TaskState.RUNNING:
      case TaskState.PAUSED:
        if (observer.next) {
          async(observer.next.bind(observer, this.snapshot))();
        }
        break;
      case TaskState.SUCCESS:
        if (observer.complete) {
          async(observer.complete.bind(observer))();
        }
        break;
      case TaskState.CANCELED:
      case TaskState.ERROR:
        if (observer.error) {
          async(observer.error.bind(observer, this._error))();
        }
        break;
      default:
        if (observer.error) {
          async(observer.error.bind(observer, this._error))();
        }
    }
  }
  resume() {
    const valid = this._state === "paused" || this._state === "pausing";
    if (valid) {
      this._transition("running");
    }
    return valid;
  }
  pause() {
    const valid = this._state === "running";
    if (valid) {
      this._transition("pausing");
    }
    return valid;
  }
  cancel() {
    const valid = this._state === "running" || this._state === "pausing";
    if (valid) {
      this._transition("canceling");
    }
    return valid;
  }
};
var Reference2 = class {
  constructor(_service, location) {
    this._service = _service;
    if (location instanceof Location) {
      this._location = location;
    } else {
      this._location = Location.makeFromUrl(location, _service.host);
    }
  }
  toString() {
    return "gs://" + this._location.bucket + "/" + this._location.path;
  }
  _newRef(service, location) {
    return new Reference2(service, location);
  }
  get root() {
    const location = new Location(this._location.bucket, "");
    return this._newRef(this._service, location);
  }
  get bucket() {
    return this._location.bucket;
  }
  get fullPath() {
    return this._location.path;
  }
  get name() {
    return lastComponent(this._location.path);
  }
  get storage() {
    return this._service;
  }
  get parent() {
    const newPath = parent(this._location.path);
    if (newPath === null) {
      return null;
    }
    const location = new Location(this._location.bucket, newPath);
    return new Reference2(this._service, location);
  }
  _throwIfRoot(name21) {
    if (this._location.path === "") {
      throw invalidRootOperation(name21);
    }
  }
};
function uploadBytesResumable$1(ref3, data, metadata) {
  ref3._throwIfRoot("uploadBytesResumable");
  return new UploadTask(ref3, new FbsBlob(data), metadata);
}
function listAll$1(ref3) {
  const accumulator = {
    prefixes: [],
    items: []
  };
  return listAllHelper(ref3, accumulator).then(() => accumulator);
}
async function listAllHelper(ref3, accumulator, pageToken) {
  const opt = {
    pageToken
  };
  const nextPage = await list$1(ref3, opt);
  accumulator.prefixes.push(...nextPage.prefixes);
  accumulator.items.push(...nextPage.items);
  if (nextPage.nextPageToken != null) {
    await listAllHelper(ref3, accumulator, nextPage.nextPageToken);
  }
}
function list$1(ref3, options) {
  if (options != null) {
    if (typeof options.maxResults === "number") {
      validateNumber("options.maxResults", 1, 1e3, options.maxResults);
    }
  }
  const op = options || {};
  const requestInfo = list$2(ref3.storage, ref3._location, "/", op.pageToken, op.maxResults);
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function getMetadata$1(ref3) {
  ref3._throwIfRoot("getMetadata");
  const requestInfo = getMetadata$2(ref3.storage, ref3._location, getMappings());
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function updateMetadata$1(ref3, metadata) {
  ref3._throwIfRoot("updateMetadata");
  const requestInfo = updateMetadata$2(ref3.storage, ref3._location, metadata, getMappings());
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function getDownloadURL$1(ref3) {
  ref3._throwIfRoot("getDownloadURL");
  const requestInfo = getDownloadUrl(ref3.storage, ref3._location, getMappings());
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((url) => {
    if (url === null) {
      throw noDownloadURL();
    }
    return url;
  });
}
function deleteObject$1(ref3) {
  ref3._throwIfRoot("deleteObject");
  const requestInfo = deleteObject$2(ref3.storage, ref3._location);
  return ref3.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
function _getChild$1(ref3, childPath) {
  const newPath = child2(ref3._location.path, childPath);
  const location = new Location(ref3._location.bucket, newPath);
  return new Reference2(ref3.storage, location);
}
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL2(service, url) {
  return new Reference2(service, url);
}
function refFromPath(ref3, path) {
  if (ref3 instanceof FirebaseStorageImpl) {
    const service = ref3;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    const reference = new Reference2(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      return _getChild$1(ref3, path);
    } else {
      return ref3;
    }
  }
}
function ref$1(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof FirebaseStorageImpl) {
      return refFromURL2(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(host, config) {
  const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString, host);
}
function connectStorageEmulator$1(storage2, host, port, options = {}) {
  storage2.host = `${host}:${port}`;
  storage2._protocol = "http";
  const { mockUserToken } = options;
  if (mockUserToken) {
    storage2._overrideAuthToken = typeof mockUserToken === "string" ? mockUserToken : createMockUserToken(mockUserToken, storage2.app.options.projectId);
  }
}
var FirebaseStorageImpl = class {
  constructor(app, _authProvider, _appCheckProvider, _url, _firebaseVersion) {
    this.app = app;
    this._authProvider = _authProvider;
    this._appCheckProvider = _appCheckProvider;
    this._url = _url;
    this._firebaseVersion = _firebaseVersion;
    this._bucket = null;
    this._host = DEFAULT_HOST;
    this._protocol = "https";
    this._appId = null;
    this._deleted = false;
    this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
    this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
    this._requests = /* @__PURE__ */ new Set();
    if (_url != null) {
      this._bucket = Location.makeFromBucketSpec(_url, this._host);
    } else {
      this._bucket = extractBucket(this._host, this.app.options);
    }
  }
  get host() {
    return this._host;
  }
  set host(host) {
    this._host = host;
    if (this._url != null) {
      this._bucket = Location.makeFromBucketSpec(this._url, host);
    } else {
      this._bucket = extractBucket(host, this.app.options);
    }
  }
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime;
  }
  set maxUploadRetryTime(time) {
    validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
    this._maxUploadRetryTime = time;
  }
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime;
  }
  set maxOperationRetryTime(time) {
    validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
    this._maxOperationRetryTime = time;
  }
  async _getAuthToken() {
    if (this._overrideAuthToken) {
      return this._overrideAuthToken;
    }
    const auth = this._authProvider.getImmediate({ optional: true });
    if (auth) {
      const tokenData = await auth.getToken();
      if (tokenData !== null) {
        return tokenData.accessToken;
      }
    }
    return null;
  }
  async _getAppCheckToken() {
    const appCheck = this._appCheckProvider.getImmediate({ optional: true });
    if (appCheck) {
      const result = await appCheck.getToken();
      return result.token;
    }
    return null;
  }
  _delete() {
    if (!this._deleted) {
      this._deleted = true;
      this._requests.forEach((request) => request.cancel());
      this._requests.clear();
    }
    return Promise.resolve();
  }
  _makeStorageReference(loc) {
    return new Reference2(this, loc);
  }
  _makeRequest(requestInfo, requestFactory, authToken, appCheckToken) {
    if (!this._deleted) {
      const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion);
      this._requests.add(request);
      request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
      return request;
    } else {
      return new FailRequest(appDeleted());
    }
  }
  async makeRequestWithTokens(requestInfo, requestFactory) {
    const [authToken, appCheckToken] = await Promise.all([
      this._getAuthToken(),
      this._getAppCheckToken()
    ]);
    return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();
  }
};
var name14 = "@firebase/storage";
var version14 = "0.9.2";
var STORAGE_TYPE = "storage";
function uploadBytesResumable(ref3, data, metadata) {
  ref3 = getModularInstance(ref3);
  return uploadBytesResumable$1(ref3, data, metadata);
}
function getMetadata(ref3) {
  ref3 = getModularInstance(ref3);
  return getMetadata$1(ref3);
}
function updateMetadata(ref3, metadata) {
  ref3 = getModularInstance(ref3);
  return updateMetadata$1(ref3, metadata);
}
function list(ref3, options) {
  ref3 = getModularInstance(ref3);
  return list$1(ref3, options);
}
function listAll(ref3) {
  ref3 = getModularInstance(ref3);
  return listAll$1(ref3);
}
function getDownloadURL(ref3) {
  ref3 = getModularInstance(ref3);
  return getDownloadURL$1(ref3);
}
function deleteObject(ref3) {
  ref3 = getModularInstance(ref3);
  return deleteObject$1(ref3);
}
function ref2(serviceOrRef, pathOrUrl) {
  serviceOrRef = getModularInstance(serviceOrRef);
  return ref$1(serviceOrRef, pathOrUrl);
}
function _getChild(ref3, childPath) {
  return _getChild$1(ref3, childPath);
}
function connectStorageEmulator(storage2, host, port, options = {}) {
  connectStorageEmulator$1(storage2, host, port, options);
}
function factory6(container, { instanceIdentifier: url }) {
  const app = container.getProvider("app").getImmediate();
  const authProvider = container.getProvider("auth-internal");
  const appCheckProvider = container.getProvider("app-check-internal");
  return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, SDK_VERSION);
}
function registerStorage() {
  _registerComponent(new Component(STORAGE_TYPE, factory6, "PUBLIC").setMultipleInstances(true));
  registerVersion(name14, version14, "");
  registerVersion(name14, version14, "esm2017");
}
registerStorage();

// node_modules/@firebase/storage-compat/dist/esm/index.esm2017.js
var UploadTaskSnapshotCompat = class {
  constructor(_delegate, task, ref3) {
    this._delegate = _delegate;
    this.task = task;
    this.ref = ref3;
  }
  get bytesTransferred() {
    return this._delegate.bytesTransferred;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get state() {
    return this._delegate.state;
  }
  get totalBytes() {
    return this._delegate.totalBytes;
  }
};
var UploadTaskCompat = class {
  constructor(_delegate, _ref) {
    this._delegate = _delegate;
    this._ref = _ref;
    this.cancel = this._delegate.cancel.bind(this._delegate);
    this.catch = this._delegate.catch.bind(this._delegate);
    this.pause = this._delegate.pause.bind(this._delegate);
    this.resume = this._delegate.resume.bind(this._delegate);
  }
  get snapshot() {
    return new UploadTaskSnapshotCompat(this._delegate.snapshot, this, this._ref);
  }
  then(onFulfilled, onRejected) {
    return this._delegate.then((snapshot) => {
      if (onFulfilled) {
        return onFulfilled(new UploadTaskSnapshotCompat(snapshot, this, this._ref));
      }
    }, onRejected);
  }
  on(type, nextOrObserver, error, completed) {
    let wrappedNextOrObserver = void 0;
    if (!!nextOrObserver) {
      if (typeof nextOrObserver === "function") {
        wrappedNextOrObserver = (taskSnapshot) => nextOrObserver(new UploadTaskSnapshotCompat(taskSnapshot, this, this._ref));
      } else {
        wrappedNextOrObserver = {
          next: !!nextOrObserver.next ? (taskSnapshot) => nextOrObserver.next(new UploadTaskSnapshotCompat(taskSnapshot, this, this._ref)) : void 0,
          complete: nextOrObserver.complete || void 0,
          error: nextOrObserver.error || void 0
        };
      }
    }
    return this._delegate.on(type, wrappedNextOrObserver, error || void 0, completed || void 0);
  }
};
var ListResultCompat = class {
  constructor(_delegate, _service) {
    this._delegate = _delegate;
    this._service = _service;
  }
  get prefixes() {
    return this._delegate.prefixes.map((ref3) => new ReferenceCompat(ref3, this._service));
  }
  get items() {
    return this._delegate.items.map((ref3) => new ReferenceCompat(ref3, this._service));
  }
  get nextPageToken() {
    return this._delegate.nextPageToken || null;
  }
};
var ReferenceCompat = class {
  constructor(_delegate, storage2) {
    this._delegate = _delegate;
    this.storage = storage2;
  }
  get name() {
    return this._delegate.name;
  }
  get bucket() {
    return this._delegate.bucket;
  }
  get fullPath() {
    return this._delegate.fullPath;
  }
  toString() {
    return this._delegate.toString();
  }
  child(childPath) {
    const reference = _getChild(this._delegate, childPath);
    return new ReferenceCompat(reference, this.storage);
  }
  get root() {
    return new ReferenceCompat(this._delegate.root, this.storage);
  }
  get parent() {
    const reference = this._delegate.parent;
    if (reference == null) {
      return null;
    }
    return new ReferenceCompat(reference, this.storage);
  }
  put(data, metadata) {
    this._throwIfRoot("put");
    return new UploadTaskCompat(uploadBytesResumable(this._delegate, data, metadata), this);
  }
  putString(value, format = StringFormat.RAW, metadata) {
    this._throwIfRoot("putString");
    const data = dataFromString(format, value);
    const metadataClone = Object.assign({}, metadata);
    if (metadataClone["contentType"] == null && data.contentType != null) {
      metadataClone["contentType"] = data.contentType;
    }
    return new UploadTaskCompat(new UploadTask(this._delegate, new FbsBlob(data.data, true), metadataClone), this);
  }
  listAll() {
    return listAll(this._delegate).then((r) => new ListResultCompat(r, this.storage));
  }
  list(options) {
    return list(this._delegate, options || void 0).then((r) => new ListResultCompat(r, this.storage));
  }
  getMetadata() {
    return getMetadata(this._delegate);
  }
  updateMetadata(metadata) {
    return updateMetadata(this._delegate, metadata);
  }
  getDownloadURL() {
    return getDownloadURL(this._delegate);
  }
  delete() {
    this._throwIfRoot("delete");
    return deleteObject(this._delegate);
  }
  _throwIfRoot(name21) {
    if (this._delegate._location.path === "") {
      throw invalidRootOperation(name21);
    }
  }
};
var StorageServiceCompat = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  get maxOperationRetryTime() {
    return this._delegate.maxOperationRetryTime;
  }
  get maxUploadRetryTime() {
    return this._delegate.maxUploadRetryTime;
  }
  ref(path) {
    if (isUrl2(path)) {
      throw invalidArgument("ref() expected a child path but got a URL, use refFromURL instead.");
    }
    return new ReferenceCompat(ref2(this._delegate, path), this);
  }
  refFromURL(url) {
    if (!isUrl2(url)) {
      throw invalidArgument("refFromURL() expected a full URL but got a child path, use ref() instead.");
    }
    try {
      Location.makeFromUrl(url, this._delegate.host);
    } catch (e) {
      throw invalidArgument("refFromUrl() expected a valid full URL but got an invalid one.");
    }
    return new ReferenceCompat(ref2(this._delegate, url), this);
  }
  setMaxUploadRetryTime(time) {
    this._delegate.maxUploadRetryTime = time;
  }
  setMaxOperationRetryTime(time) {
    this._delegate.maxOperationRetryTime = time;
  }
  useEmulator(host, port, options = {}) {
    connectStorageEmulator(this._delegate, host, port, options);
  }
};
function isUrl2(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
var name15 = "@firebase/storage-compat";
var version15 = "0.1.10";
var STORAGE_TYPE2 = "storage-compat";
function factory7(container, { instanceIdentifier: url }) {
  const app = container.getProvider("app-compat").getImmediate();
  const storageExp = container.getProvider("storage").getImmediate({ identifier: url });
  const storageServiceCompat = new StorageServiceCompat(app, storageExp);
  return storageServiceCompat;
}
function registerStorage2(instance) {
  const namespaceExports = {
    TaskState,
    TaskEvent,
    StringFormat,
    Storage: StorageServiceCompat,
    Reference: ReferenceCompat
  };
  instance.INTERNAL.registerComponent(new Component(STORAGE_TYPE2, factory7, "PUBLIC").setServiceProps(namespaceExports).setMultipleInstances(true));
  instance.registerVersion(name15, version15);
}
registerStorage2(firebase);

// node_modules/@firebase/performance/dist/esm/index.esm2017.js
var name16 = "@firebase/performance";
var version16 = "0.5.5";
var SDK_VERSION2 = version16;
var TRACE_START_MARK_PREFIX = "FB-PERF-TRACE-START";
var TRACE_STOP_MARK_PREFIX = "FB-PERF-TRACE-STOP";
var TRACE_MEASURE_PREFIX = "FB-PERF-TRACE-MEASURE";
var OOB_TRACE_PAGE_LOAD_PREFIX = "_wt_";
var FIRST_PAINT_COUNTER_NAME = "_fp";
var FIRST_CONTENTFUL_PAINT_COUNTER_NAME = "_fcp";
var FIRST_INPUT_DELAY_COUNTER_NAME = "_fid";
var CONFIG_LOCAL_STORAGE_KEY = "@firebase/performance/config";
var CONFIG_EXPIRY_LOCAL_STORAGE_KEY = "@firebase/performance/configexpire";
var SERVICE2 = "performance";
var SERVICE_NAME2 = "Performance";
var ERROR_DESCRIPTION_MAP2 = {
  ["trace started"]: "Trace {$traceName} was started before.",
  ["trace stopped"]: "Trace {$traceName} is not running.",
  ["nonpositive trace startTime"]: "Trace {$traceName} startTime should be positive.",
  ["nonpositive trace duration"]: "Trace {$traceName} duration should be positive.",
  ["no window"]: "Window is not available.",
  ["no app id"]: "App id is not available.",
  ["no project id"]: "Project id is not available.",
  ["no api key"]: "Api key is not available.",
  ["invalid cc log"]: "Attempted to queue invalid cc event",
  ["FB not default"]: "Performance can only start when Firebase app instance is the default one.",
  ["RC response not ok"]: "RC response is not ok",
  ["invalid attribute name"]: "Attribute name {$attributeName} is invalid.",
  ["invalid attribute value"]: "Attribute value {$attributeValue} is invalid.",
  ["invalid custom metric name"]: "Custom metric name {$customMetricName} is invalid",
  ["invalid String merger input"]: "Input for String merger is invalid, contact support team to resolve.",
  ["already initialized"]: "initializePerformance() has already been called with different options. To avoid this error, call initializePerformance() with the same options as when it was originally called, or call getPerformance() to return the already initialized instance."
};
var ERROR_FACTORY8 = new ErrorFactory(SERVICE2, SERVICE_NAME2, ERROR_DESCRIPTION_MAP2);
var consoleLogger = new Logger(SERVICE_NAME2);
consoleLogger.logLevel = LogLevel.INFO;
var apiInstance;
var windowInstance;
var Api = class {
  constructor(window2) {
    this.window = window2;
    if (!window2) {
      throw ERROR_FACTORY8.create("no window");
    }
    this.performance = window2.performance;
    this.PerformanceObserver = window2.PerformanceObserver;
    this.windowLocation = window2.location;
    this.navigator = window2.navigator;
    this.document = window2.document;
    if (this.navigator && this.navigator.cookieEnabled) {
      this.localStorage = window2.localStorage;
    }
    if (window2.perfMetrics && window2.perfMetrics.onFirstInputDelay) {
      this.onFirstInputDelay = window2.perfMetrics.onFirstInputDelay;
    }
  }
  getUrl() {
    return this.windowLocation.href.split("?")[0];
  }
  mark(name21) {
    if (!this.performance || !this.performance.mark) {
      return;
    }
    this.performance.mark(name21);
  }
  measure(measureName, mark1, mark2) {
    if (!this.performance || !this.performance.measure) {
      return;
    }
    this.performance.measure(measureName, mark1, mark2);
  }
  getEntriesByType(type) {
    if (!this.performance || !this.performance.getEntriesByType) {
      return [];
    }
    return this.performance.getEntriesByType(type);
  }
  getEntriesByName(name21) {
    if (!this.performance || !this.performance.getEntriesByName) {
      return [];
    }
    return this.performance.getEntriesByName(name21);
  }
  getTimeOrigin() {
    return this.performance && (this.performance.timeOrigin || this.performance.timing.navigationStart);
  }
  requiredApisAvailable() {
    if (!fetch || !Promise || !areCookiesEnabled()) {
      consoleLogger.info("Firebase Performance cannot start if browser does not support fetch and Promise or cookie is disabled.");
      return false;
    }
    if (!isIndexedDBAvailable()) {
      consoleLogger.info("IndexedDB is not supported by current browswer");
      return false;
    }
    return true;
  }
  setupObserver(entryType, callback) {
    if (!this.PerformanceObserver) {
      return;
    }
    const observer = new this.PerformanceObserver((list2) => {
      for (const entry of list2.getEntries()) {
        callback(entry);
      }
    });
    observer.observe({ entryTypes: [entryType] });
  }
  static getInstance() {
    if (apiInstance === void 0) {
      apiInstance = new Api(windowInstance);
    }
    return apiInstance;
  }
};
function setupApi(window2) {
  windowInstance = window2;
}
var iid;
function getIidPromise(installationsService) {
  const iidPromise = installationsService.getId();
  iidPromise.then((iidVal) => {
    iid = iidVal;
  });
  return iidPromise;
}
function getIid() {
  return iid;
}
function getAuthTokenPromise(installationsService) {
  const authTokenPromise = installationsService.getToken();
  authTokenPromise.then((authTokenVal) => {
  });
  return authTokenPromise;
}
function mergeStrings(part1, part2) {
  const sizeDiff = part1.length - part2.length;
  if (sizeDiff < 0 || sizeDiff > 1) {
    throw ERROR_FACTORY8.create("invalid String merger input");
  }
  const resultArray = [];
  for (let i = 0; i < part1.length; i++) {
    resultArray.push(part1.charAt(i));
    if (part2.length > i) {
      resultArray.push(part2.charAt(i));
    }
  }
  return resultArray.join("");
}
var settingsServiceInstance;
var SettingsService = class {
  constructor() {
    this.instrumentationEnabled = true;
    this.dataCollectionEnabled = true;
    this.loggingEnabled = false;
    this.tracesSamplingRate = 1;
    this.networkRequestsSamplingRate = 1;
    this.logEndPointUrl = "https://firebaselogging.googleapis.com/v0cc/log?format=json_proto";
    this.flTransportEndpointUrl = mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
    this.transportKey = mergeStrings("AzSC8r6ReiGqFMyfvgow", "Iayx0u-XT3vksVM-pIV");
    this.logSource = 462;
    this.logTraceAfterSampling = false;
    this.logNetworkAfterSampling = false;
    this.configTimeToLive = 12;
  }
  getFlTransportFullUrl() {
    return this.flTransportEndpointUrl.concat("?key=", this.transportKey);
  }
  static getInstance() {
    if (settingsServiceInstance === void 0) {
      settingsServiceInstance = new SettingsService();
    }
    return settingsServiceInstance;
  }
};
var VisibilityState;
(function(VisibilityState2) {
  VisibilityState2[VisibilityState2["UNKNOWN"] = 0] = "UNKNOWN";
  VisibilityState2[VisibilityState2["VISIBLE"] = 1] = "VISIBLE";
  VisibilityState2[VisibilityState2["HIDDEN"] = 2] = "HIDDEN";
})(VisibilityState || (VisibilityState = {}));
var RESERVED_ATTRIBUTE_PREFIXES = ["firebase_", "google_", "ga_"];
var ATTRIBUTE_FORMAT_REGEX = new RegExp("^[a-zA-Z]\\w*$");
var MAX_ATTRIBUTE_NAME_LENGTH = 40;
var MAX_ATTRIBUTE_VALUE_LENGTH = 100;
function getServiceWorkerStatus() {
  const navigator2 = Api.getInstance().navigator;
  if ("serviceWorker" in navigator2) {
    if (navigator2.serviceWorker.controller) {
      return 2;
    } else {
      return 3;
    }
  } else {
    return 1;
  }
}
function getVisibilityState() {
  const document2 = Api.getInstance().document;
  const visibilityState = document2.visibilityState;
  switch (visibilityState) {
    case "visible":
      return VisibilityState.VISIBLE;
    case "hidden":
      return VisibilityState.HIDDEN;
    default:
      return VisibilityState.UNKNOWN;
  }
}
function getEffectiveConnectionType() {
  const navigator2 = Api.getInstance().navigator;
  const navigatorConnection = navigator2.connection;
  const effectiveType = navigatorConnection && navigatorConnection.effectiveType;
  switch (effectiveType) {
    case "slow-2g":
      return 1;
    case "2g":
      return 2;
    case "3g":
      return 3;
    case "4g":
      return 4;
    default:
      return 0;
  }
}
function isValidCustomAttributeName(name21) {
  if (name21.length === 0 || name21.length > MAX_ATTRIBUTE_NAME_LENGTH) {
    return false;
  }
  const matchesReservedPrefix = RESERVED_ATTRIBUTE_PREFIXES.some((prefix) => name21.startsWith(prefix));
  return !matchesReservedPrefix && !!name21.match(ATTRIBUTE_FORMAT_REGEX);
}
function isValidCustomAttributeValue(value) {
  return value.length !== 0 && value.length <= MAX_ATTRIBUTE_VALUE_LENGTH;
}
function getAppId(firebaseApp) {
  var _a2;
  const appId = (_a2 = firebaseApp.options) === null || _a2 === void 0 ? void 0 : _a2.appId;
  if (!appId) {
    throw ERROR_FACTORY8.create("no app id");
  }
  return appId;
}
function getProjectId(firebaseApp) {
  var _a2;
  const projectId = (_a2 = firebaseApp.options) === null || _a2 === void 0 ? void 0 : _a2.projectId;
  if (!projectId) {
    throw ERROR_FACTORY8.create("no project id");
  }
  return projectId;
}
function getApiKey(firebaseApp) {
  var _a2;
  const apiKey = (_a2 = firebaseApp.options) === null || _a2 === void 0 ? void 0 : _a2.apiKey;
  if (!apiKey) {
    throw ERROR_FACTORY8.create("no api key");
  }
  return apiKey;
}
var REMOTE_CONFIG_SDK_VERSION = "0.0.1";
var DEFAULT_CONFIGS = {
  loggingEnabled: true
};
var FIS_AUTH_PREFIX = "FIREBASE_INSTALLATIONS_AUTH";
function getConfig(performanceController, iid2) {
  const config = getStoredConfig();
  if (config) {
    processConfig(config);
    return Promise.resolve();
  }
  return getRemoteConfig(performanceController, iid2).then(processConfig).then((config2) => storeConfig(config2), () => {
  });
}
function getStoredConfig() {
  const localStorage = Api.getInstance().localStorage;
  if (!localStorage) {
    return;
  }
  const expiryString = localStorage.getItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY);
  if (!expiryString || !configValid(expiryString)) {
    return;
  }
  const configStringified = localStorage.getItem(CONFIG_LOCAL_STORAGE_KEY);
  if (!configStringified) {
    return;
  }
  try {
    const configResponse = JSON.parse(configStringified);
    return configResponse;
  } catch (_a2) {
    return;
  }
}
function storeConfig(config) {
  const localStorage = Api.getInstance().localStorage;
  if (!config || !localStorage) {
    return;
  }
  localStorage.setItem(CONFIG_LOCAL_STORAGE_KEY, JSON.stringify(config));
  localStorage.setItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY, String(Date.now() + SettingsService.getInstance().configTimeToLive * 60 * 60 * 1e3));
}
var COULD_NOT_GET_CONFIG_MSG = "Could not fetch config, will use default configs";
function getRemoteConfig(performanceController, iid2) {
  return getAuthTokenPromise(performanceController.installations).then((authToken) => {
    const projectId = getProjectId(performanceController.app);
    const apiKey = getApiKey(performanceController.app);
    const configEndPoint = `https://firebaseremoteconfig.googleapis.com/v1/projects/${projectId}/namespaces/fireperf:fetch?key=${apiKey}`;
    const request = new Request(configEndPoint, {
      method: "POST",
      headers: { Authorization: `${FIS_AUTH_PREFIX} ${authToken}` },
      body: JSON.stringify({
        app_instance_id: iid2,
        app_instance_id_token: authToken,
        app_id: getAppId(performanceController.app),
        app_version: SDK_VERSION2,
        sdk_version: REMOTE_CONFIG_SDK_VERSION
      })
    });
    return fetch(request).then((response) => {
      if (response.ok) {
        return response.json();
      }
      throw ERROR_FACTORY8.create("RC response not ok");
    });
  }).catch(() => {
    consoleLogger.info(COULD_NOT_GET_CONFIG_MSG);
    return void 0;
  });
}
function processConfig(config) {
  if (!config) {
    return config;
  }
  const settingsServiceInstance2 = SettingsService.getInstance();
  const entries = config.entries || {};
  if (entries.fpr_enabled !== void 0) {
    settingsServiceInstance2.loggingEnabled = String(entries.fpr_enabled) === "true";
  } else {
    settingsServiceInstance2.loggingEnabled = DEFAULT_CONFIGS.loggingEnabled;
  }
  if (entries.fpr_log_source) {
    settingsServiceInstance2.logSource = Number(entries.fpr_log_source);
  }
  if (entries.fpr_log_endpoint_url) {
    settingsServiceInstance2.logEndPointUrl = entries.fpr_log_endpoint_url;
  }
  if (entries.fpr_log_transport_key) {
    settingsServiceInstance2.transportKey = entries.fpr_log_transport_key;
  }
  if (entries.fpr_vc_network_request_sampling_rate !== void 0) {
    settingsServiceInstance2.networkRequestsSamplingRate = Number(entries.fpr_vc_network_request_sampling_rate);
  }
  if (entries.fpr_vc_trace_sampling_rate !== void 0) {
    settingsServiceInstance2.tracesSamplingRate = Number(entries.fpr_vc_trace_sampling_rate);
  }
  settingsServiceInstance2.logTraceAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.tracesSamplingRate);
  settingsServiceInstance2.logNetworkAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.networkRequestsSamplingRate);
  return config;
}
function configValid(expiry) {
  return Number(expiry) > Date.now();
}
function shouldLogAfterSampling(samplingRate) {
  return Math.random() <= samplingRate;
}
var initializationStatus = 1;
var initializationPromise;
function getInitializationPromise(performanceController) {
  initializationStatus = 2;
  initializationPromise = initializationPromise || initializePerf(performanceController);
  return initializationPromise;
}
function isPerfInitialized() {
  return initializationStatus === 3;
}
function initializePerf(performanceController) {
  return getDocumentReadyComplete().then(() => getIidPromise(performanceController.installations)).then((iid2) => getConfig(performanceController, iid2)).then(() => changeInitializationStatus(), () => changeInitializationStatus());
}
function getDocumentReadyComplete() {
  const document2 = Api.getInstance().document;
  return new Promise((resolve) => {
    if (document2 && document2.readyState !== "complete") {
      const handler = () => {
        if (document2.readyState === "complete") {
          document2.removeEventListener("readystatechange", handler);
          resolve();
        }
      };
      document2.addEventListener("readystatechange", handler);
    } else {
      resolve();
    }
  });
}
function changeInitializationStatus() {
  initializationStatus = 3;
}
var DEFAULT_SEND_INTERVAL_MS = 10 * 1e3;
var INITIAL_SEND_TIME_DELAY_MS = 5.5 * 1e3;
var DEFAULT_REMAINING_TRIES = 3;
var MAX_EVENT_COUNT_PER_REQUEST = 1e3;
var remainingTries = DEFAULT_REMAINING_TRIES;
var queue = [];
var isTransportSetup = false;
function setupTransportService() {
  if (!isTransportSetup) {
    processQueue(INITIAL_SEND_TIME_DELAY_MS);
    isTransportSetup = true;
  }
}
function processQueue(timeOffset) {
  setTimeout(() => {
    if (remainingTries === 0) {
      return;
    }
    if (!queue.length) {
      return processQueue(DEFAULT_SEND_INTERVAL_MS);
    }
    dispatchQueueEvents();
  }, timeOffset);
}
function dispatchQueueEvents() {
  const staged = queue.splice(0, MAX_EVENT_COUNT_PER_REQUEST);
  const log_event = staged.map((evt) => ({
    source_extension_json_proto3: evt.message,
    event_time_ms: String(evt.eventTime)
  }));
  const data = {
    request_time_ms: String(Date.now()),
    client_info: {
      client_type: 1,
      js_client_info: {}
    },
    log_source: SettingsService.getInstance().logSource,
    log_event
  };
  sendEventsToFl(data, staged).catch(() => {
    queue = [...staged, ...queue];
    remainingTries--;
    consoleLogger.info(`Tries left: ${remainingTries}.`);
    processQueue(DEFAULT_SEND_INTERVAL_MS);
  });
}
function sendEventsToFl(data, staged) {
  return postToFlEndpoint(data).then((res) => {
    if (!res.ok) {
      consoleLogger.info("Call to Firebase backend failed.");
    }
    return res.json();
  }).then((res) => {
    const transportWait = Number(res.nextRequestWaitMillis);
    let requestOffset = DEFAULT_SEND_INTERVAL_MS;
    if (!isNaN(transportWait)) {
      requestOffset = Math.max(transportWait, requestOffset);
    }
    const logResponseDetails = res.logResponseDetails;
    if (Array.isArray(logResponseDetails) && logResponseDetails.length > 0 && logResponseDetails[0].responseAction === "RETRY_REQUEST_LATER") {
      queue = [...staged, ...queue];
      consoleLogger.info(`Retry transport request later.`);
    }
    remainingTries = DEFAULT_REMAINING_TRIES;
    processQueue(requestOffset);
  });
}
function postToFlEndpoint(data) {
  const flTransportFullUrl = SettingsService.getInstance().getFlTransportFullUrl();
  return fetch(flTransportFullUrl, {
    method: "POST",
    body: JSON.stringify(data)
  });
}
function addToQueue(evt) {
  if (!evt.eventTime || !evt.message) {
    throw ERROR_FACTORY8.create("invalid cc log");
  }
  queue = [...queue, evt];
}
function transportHandler(serializer2) {
  return (...args) => {
    const message = serializer2(...args);
    addToQueue({
      message,
      eventTime: Date.now()
    });
  };
}
var logger4;
function sendLog(resource, resourceType) {
  if (!logger4) {
    logger4 = transportHandler(serializer);
  }
  logger4(resource, resourceType);
}
function logTrace(trace2) {
  const settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled && trace2.isAuto) {
    return;
  }
  if (!settingsService.dataCollectionEnabled && !trace2.isAuto) {
    return;
  }
  if (!Api.getInstance().requiredApisAvailable()) {
    return;
  }
  if (trace2.isAuto && getVisibilityState() !== VisibilityState.VISIBLE) {
    return;
  }
  if (isPerfInitialized()) {
    sendTraceLog(trace2);
  } else {
    getInitializationPromise(trace2.performanceController).then(() => sendTraceLog(trace2), () => sendTraceLog(trace2));
  }
}
function sendTraceLog(trace2) {
  if (!getIid()) {
    return;
  }
  const settingsService = SettingsService.getInstance();
  if (!settingsService.loggingEnabled || !settingsService.logTraceAfterSampling) {
    return;
  }
  setTimeout(() => sendLog(trace2, 1), 0);
}
function logNetworkRequest(networkRequest) {
  const settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled) {
    return;
  }
  const networkRequestUrl = networkRequest.url;
  const logEndpointUrl = settingsService.logEndPointUrl.split("?")[0];
  const flEndpointUrl = settingsService.flTransportEndpointUrl.split("?")[0];
  if (networkRequestUrl === logEndpointUrl || networkRequestUrl === flEndpointUrl) {
    return;
  }
  if (!settingsService.loggingEnabled || !settingsService.logNetworkAfterSampling) {
    return;
  }
  setTimeout(() => sendLog(networkRequest, 0), 0);
}
function serializer(resource, resourceType) {
  if (resourceType === 0) {
    return serializeNetworkRequest(resource);
  }
  return serializeTrace(resource);
}
function serializeNetworkRequest(networkRequest) {
  const networkRequestMetric = {
    url: networkRequest.url,
    http_method: networkRequest.httpMethod || 0,
    http_response_code: 200,
    response_payload_bytes: networkRequest.responsePayloadBytes,
    client_start_time_us: networkRequest.startTimeUs,
    time_to_response_initiated_us: networkRequest.timeToResponseInitiatedUs,
    time_to_response_completed_us: networkRequest.timeToResponseCompletedUs
  };
  const perfMetric = {
    application_info: getApplicationInfo(networkRequest.performanceController.app),
    network_request_metric: networkRequestMetric
  };
  return JSON.stringify(perfMetric);
}
function serializeTrace(trace2) {
  const traceMetric = {
    name: trace2.name,
    is_auto: trace2.isAuto,
    client_start_time_us: trace2.startTimeUs,
    duration_us: trace2.durationUs
  };
  if (Object.keys(trace2.counters).length !== 0) {
    traceMetric.counters = trace2.counters;
  }
  const customAttributes = trace2.getAttributes();
  if (Object.keys(customAttributes).length !== 0) {
    traceMetric.custom_attributes = customAttributes;
  }
  const perfMetric = {
    application_info: getApplicationInfo(trace2.performanceController.app),
    trace_metric: traceMetric
  };
  return JSON.stringify(perfMetric);
}
function getApplicationInfo(firebaseApp) {
  return {
    google_app_id: getAppId(firebaseApp),
    app_instance_id: getIid(),
    web_app_info: {
      sdk_version: SDK_VERSION2,
      page_url: Api.getInstance().getUrl(),
      service_worker_status: getServiceWorkerStatus(),
      visibility_state: getVisibilityState(),
      effective_connection_type: getEffectiveConnectionType()
    },
    application_process_state: 0
  };
}
var MAX_METRIC_NAME_LENGTH = 100;
var RESERVED_AUTO_PREFIX = "_";
var oobMetrics = [
  FIRST_PAINT_COUNTER_NAME,
  FIRST_CONTENTFUL_PAINT_COUNTER_NAME,
  FIRST_INPUT_DELAY_COUNTER_NAME
];
function isValidMetricName(name21, traceName) {
  if (name21.length === 0 || name21.length > MAX_METRIC_NAME_LENGTH) {
    return false;
  }
  return traceName && traceName.startsWith(OOB_TRACE_PAGE_LOAD_PREFIX) && oobMetrics.indexOf(name21) > -1 || !name21.startsWith(RESERVED_AUTO_PREFIX);
}
function convertMetricValueToInteger(providedValue) {
  const valueAsInteger = Math.floor(providedValue);
  if (valueAsInteger < providedValue) {
    consoleLogger.info(`Metric value should be an Integer, setting the value as : ${valueAsInteger}.`);
  }
  return valueAsInteger;
}
var Trace = class {
  constructor(performanceController, name21, isAuto = false, traceMeasureName) {
    this.performanceController = performanceController;
    this.name = name21;
    this.isAuto = isAuto;
    this.state = 1;
    this.customAttributes = {};
    this.counters = {};
    this.api = Api.getInstance();
    this.randomId = Math.floor(Math.random() * 1e6);
    if (!this.isAuto) {
      this.traceStartMark = `${TRACE_START_MARK_PREFIX}-${this.randomId}-${this.name}`;
      this.traceStopMark = `${TRACE_STOP_MARK_PREFIX}-${this.randomId}-${this.name}`;
      this.traceMeasure = traceMeasureName || `${TRACE_MEASURE_PREFIX}-${this.randomId}-${this.name}`;
      if (traceMeasureName) {
        this.calculateTraceMetrics();
      }
    }
  }
  start() {
    if (this.state !== 1) {
      throw ERROR_FACTORY8.create("trace started", {
        traceName: this.name
      });
    }
    this.api.mark(this.traceStartMark);
    this.state = 2;
  }
  stop() {
    if (this.state !== 2) {
      throw ERROR_FACTORY8.create("trace stopped", {
        traceName: this.name
      });
    }
    this.state = 3;
    this.api.mark(this.traceStopMark);
    this.api.measure(this.traceMeasure, this.traceStartMark, this.traceStopMark);
    this.calculateTraceMetrics();
    logTrace(this);
  }
  record(startTime, duration, options) {
    if (startTime <= 0) {
      throw ERROR_FACTORY8.create("nonpositive trace startTime", {
        traceName: this.name
      });
    }
    if (duration <= 0) {
      throw ERROR_FACTORY8.create("nonpositive trace duration", {
        traceName: this.name
      });
    }
    this.durationUs = Math.floor(duration * 1e3);
    this.startTimeUs = Math.floor(startTime * 1e3);
    if (options && options.attributes) {
      this.customAttributes = Object.assign({}, options.attributes);
    }
    if (options && options.metrics) {
      for (const metric of Object.keys(options.metrics)) {
        if (!isNaN(Number(options.metrics[metric]))) {
          this.counters[metric] = Number(Math.floor(options.metrics[metric]));
        }
      }
    }
    logTrace(this);
  }
  incrementMetric(counter, numAsInteger = 1) {
    if (this.counters[counter] === void 0) {
      this.putMetric(counter, numAsInteger);
    } else {
      this.putMetric(counter, this.counters[counter] + numAsInteger);
    }
  }
  putMetric(counter, numAsInteger) {
    if (isValidMetricName(counter, this.name)) {
      this.counters[counter] = convertMetricValueToInteger(numAsInteger);
    } else {
      throw ERROR_FACTORY8.create("invalid custom metric name", {
        customMetricName: counter
      });
    }
  }
  getMetric(counter) {
    return this.counters[counter] || 0;
  }
  putAttribute(attr, value) {
    const isValidName = isValidCustomAttributeName(attr);
    const isValidValue = isValidCustomAttributeValue(value);
    if (isValidName && isValidValue) {
      this.customAttributes[attr] = value;
      return;
    }
    if (!isValidName) {
      throw ERROR_FACTORY8.create("invalid attribute name", {
        attributeName: attr
      });
    }
    if (!isValidValue) {
      throw ERROR_FACTORY8.create("invalid attribute value", {
        attributeValue: value
      });
    }
  }
  getAttribute(attr) {
    return this.customAttributes[attr];
  }
  removeAttribute(attr) {
    if (this.customAttributes[attr] === void 0) {
      return;
    }
    delete this.customAttributes[attr];
  }
  getAttributes() {
    return Object.assign({}, this.customAttributes);
  }
  setStartTime(startTime) {
    this.startTimeUs = startTime;
  }
  setDuration(duration) {
    this.durationUs = duration;
  }
  calculateTraceMetrics() {
    const perfMeasureEntries = this.api.getEntriesByName(this.traceMeasure);
    const perfMeasureEntry = perfMeasureEntries && perfMeasureEntries[0];
    if (perfMeasureEntry) {
      this.durationUs = Math.floor(perfMeasureEntry.duration * 1e3);
      this.startTimeUs = Math.floor((perfMeasureEntry.startTime + this.api.getTimeOrigin()) * 1e3);
    }
  }
  static createOobTrace(performanceController, navigationTimings, paintTimings, firstInputDelay) {
    const route = Api.getInstance().getUrl();
    if (!route) {
      return;
    }
    const trace2 = new Trace(performanceController, OOB_TRACE_PAGE_LOAD_PREFIX + route, true);
    const timeOriginUs = Math.floor(Api.getInstance().getTimeOrigin() * 1e3);
    trace2.setStartTime(timeOriginUs);
    if (navigationTimings && navigationTimings[0]) {
      trace2.setDuration(Math.floor(navigationTimings[0].duration * 1e3));
      trace2.putMetric("domInteractive", Math.floor(navigationTimings[0].domInteractive * 1e3));
      trace2.putMetric("domContentLoadedEventEnd", Math.floor(navigationTimings[0].domContentLoadedEventEnd * 1e3));
      trace2.putMetric("loadEventEnd", Math.floor(navigationTimings[0].loadEventEnd * 1e3));
    }
    const FIRST_PAINT = "first-paint";
    const FIRST_CONTENTFUL_PAINT = "first-contentful-paint";
    if (paintTimings) {
      const firstPaint = paintTimings.find((paintObject) => paintObject.name === FIRST_PAINT);
      if (firstPaint && firstPaint.startTime) {
        trace2.putMetric(FIRST_PAINT_COUNTER_NAME, Math.floor(firstPaint.startTime * 1e3));
      }
      const firstContentfulPaint = paintTimings.find((paintObject) => paintObject.name === FIRST_CONTENTFUL_PAINT);
      if (firstContentfulPaint && firstContentfulPaint.startTime) {
        trace2.putMetric(FIRST_CONTENTFUL_PAINT_COUNTER_NAME, Math.floor(firstContentfulPaint.startTime * 1e3));
      }
      if (firstInputDelay) {
        trace2.putMetric(FIRST_INPUT_DELAY_COUNTER_NAME, Math.floor(firstInputDelay * 1e3));
      }
    }
    logTrace(trace2);
  }
  static createUserTimingTrace(performanceController, measureName) {
    const trace2 = new Trace(performanceController, measureName, false, measureName);
    logTrace(trace2);
  }
};
function createNetworkRequestEntry(performanceController, entry) {
  const performanceEntry = entry;
  if (!performanceEntry || performanceEntry.responseStart === void 0) {
    return;
  }
  const timeOrigin = Api.getInstance().getTimeOrigin();
  const startTimeUs = Math.floor((performanceEntry.startTime + timeOrigin) * 1e3);
  const timeToResponseInitiatedUs = performanceEntry.responseStart ? Math.floor((performanceEntry.responseStart - performanceEntry.startTime) * 1e3) : void 0;
  const timeToResponseCompletedUs = Math.floor((performanceEntry.responseEnd - performanceEntry.startTime) * 1e3);
  const url = performanceEntry.name && performanceEntry.name.split("?")[0];
  const networkRequest = {
    performanceController,
    url,
    responsePayloadBytes: performanceEntry.transferSize,
    startTimeUs,
    timeToResponseInitiatedUs,
    timeToResponseCompletedUs
  };
  logNetworkRequest(networkRequest);
}
var FID_WAIT_TIME_MS = 5e3;
function setupOobResources(performanceController) {
  if (!getIid()) {
    return;
  }
  setTimeout(() => setupOobTraces(performanceController), 0);
  setTimeout(() => setupNetworkRequests(performanceController), 0);
  setTimeout(() => setupUserTimingTraces(performanceController), 0);
}
function setupNetworkRequests(performanceController) {
  const api = Api.getInstance();
  const resources = api.getEntriesByType("resource");
  for (const resource of resources) {
    createNetworkRequestEntry(performanceController, resource);
  }
  api.setupObserver("resource", (entry) => createNetworkRequestEntry(performanceController, entry));
}
function setupOobTraces(performanceController) {
  const api = Api.getInstance();
  const navigationTimings = api.getEntriesByType("navigation");
  const paintTimings = api.getEntriesByType("paint");
  if (api.onFirstInputDelay) {
    let timeoutId = setTimeout(() => {
      Trace.createOobTrace(performanceController, navigationTimings, paintTimings);
      timeoutId = void 0;
    }, FID_WAIT_TIME_MS);
    api.onFirstInputDelay((fid) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
        Trace.createOobTrace(performanceController, navigationTimings, paintTimings, fid);
      }
    });
  } else {
    Trace.createOobTrace(performanceController, navigationTimings, paintTimings);
  }
}
function setupUserTimingTraces(performanceController) {
  const api = Api.getInstance();
  const measures = api.getEntriesByType("measure");
  for (const measure of measures) {
    createUserTimingTrace(performanceController, measure);
  }
  api.setupObserver("measure", (entry) => createUserTimingTrace(performanceController, entry));
}
function createUserTimingTrace(performanceController, measure) {
  const measureName = measure.name;
  if (measureName.substring(0, TRACE_MEASURE_PREFIX.length) === TRACE_MEASURE_PREFIX) {
    return;
  }
  Trace.createUserTimingTrace(performanceController, measureName);
}
var PerformanceController = class {
  constructor(app, installations) {
    this.app = app;
    this.installations = installations;
    this.initialized = false;
  }
  _init(settings2) {
    if (this.initialized) {
      return;
    }
    if ((settings2 === null || settings2 === void 0 ? void 0 : settings2.dataCollectionEnabled) !== void 0) {
      this.dataCollectionEnabled = settings2.dataCollectionEnabled;
    }
    if ((settings2 === null || settings2 === void 0 ? void 0 : settings2.instrumentationEnabled) !== void 0) {
      this.instrumentationEnabled = settings2.instrumentationEnabled;
    }
    if (Api.getInstance().requiredApisAvailable()) {
      validateIndexedDBOpenable().then((isAvailable) => {
        if (isAvailable) {
          setupTransportService();
          getInitializationPromise(this).then(() => setupOobResources(this), () => setupOobResources(this));
          this.initialized = true;
        }
      }).catch((error) => {
        consoleLogger.info(`Environment doesn't support IndexedDB: ${error}`);
      });
    } else {
      consoleLogger.info('Firebase Performance cannot start if the browser does not support "Fetch" and "Promise", or cookies are disabled.');
    }
  }
  set instrumentationEnabled(val) {
    SettingsService.getInstance().instrumentationEnabled = val;
  }
  get instrumentationEnabled() {
    return SettingsService.getInstance().instrumentationEnabled;
  }
  set dataCollectionEnabled(val) {
    SettingsService.getInstance().dataCollectionEnabled = val;
  }
  get dataCollectionEnabled() {
    return SettingsService.getInstance().dataCollectionEnabled;
  }
};
var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
function trace(performance, name21) {
  performance = getModularInstance(performance);
  return new Trace(performance, name21);
}
var factory8 = (container, { options: settings2 }) => {
  const app = container.getProvider("app").getImmediate();
  const installations = container.getProvider("installations-internal").getImmediate();
  if (app.name !== DEFAULT_ENTRY_NAME2) {
    throw ERROR_FACTORY8.create("FB not default");
  }
  if (typeof window === "undefined") {
    throw ERROR_FACTORY8.create("no window");
  }
  setupApi(window);
  const perfInstance = new PerformanceController(app, installations);
  perfInstance._init(settings2);
  return perfInstance;
};
function registerPerformance() {
  _registerComponent(new Component("performance", factory8, "PUBLIC"));
  registerVersion(name16, version16);
  registerVersion(name16, version16, "esm2017");
}
registerPerformance();

// node_modules/@firebase/performance-compat/dist/esm/index.esm2017.js
var PerformanceCompatImpl = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  get instrumentationEnabled() {
    return this._delegate.instrumentationEnabled;
  }
  set instrumentationEnabled(val) {
    this._delegate.instrumentationEnabled = val;
  }
  get dataCollectionEnabled() {
    return this._delegate.dataCollectionEnabled;
  }
  set dataCollectionEnabled(val) {
    this._delegate.dataCollectionEnabled = val;
  }
  trace(traceName) {
    return trace(this._delegate, traceName);
  }
};
var name17 = "@firebase/performance-compat";
var version17 = "0.1.5";
function registerPerformanceCompat(firebaseInstance) {
  firebaseInstance.INTERNAL.registerComponent(new Component("performance-compat", performanceFactory, "PUBLIC"));
  firebaseInstance.registerVersion(name17, version17);
}
function performanceFactory(container) {
  const app = container.getProvider("app-compat").getImmediate();
  const performance = container.getProvider("performance").getImmediate();
  return new PerformanceCompatImpl(app, performance);
}
registerPerformanceCompat(firebase);

// node_modules/@firebase/remote-config/dist/esm/index.esm2017.js
var name18 = "@firebase/remote-config";
var version18 = "0.3.4";
var RemoteConfigAbortSignal = class {
  constructor() {
    this.listeners = [];
  }
  addEventListener(listener) {
    this.listeners.push(listener);
  }
  abort() {
    this.listeners.forEach((listener) => listener());
  }
};
var RC_COMPONENT_NAME = "remote-config";
var ERROR_DESCRIPTION_MAP3 = {
  ["registration-window"]: "Undefined window object. This SDK only supports usage in a browser environment.",
  ["registration-project-id"]: "Undefined project identifier. Check Firebase app initialization.",
  ["registration-api-key"]: "Undefined API key. Check Firebase app initialization.",
  ["registration-app-id"]: "Undefined app identifier. Check Firebase app initialization.",
  ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
  ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
  ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
  ["storage-delete"]: "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.",
  ["fetch-client-network"]: "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.",
  ["fetch-timeout"]: 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.',
  ["fetch-throttle"]: 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',
  ["fetch-client-parse"]: "Fetch client could not parse response. Original error: {$originalErrorMessage}.",
  ["fetch-status"]: "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.",
  ["indexed-db-unavailable"]: "Indexed DB is not supported by current browser"
};
var ERROR_FACTORY9 = new ErrorFactory("remoteconfig", "Remote Config", ERROR_DESCRIPTION_MAP3);
function hasErrorCode(e, errorCode) {
  return e instanceof FirebaseError && e.code.indexOf(errorCode) !== -1;
}
var DEFAULT_VALUE_FOR_BOOLEAN = false;
var DEFAULT_VALUE_FOR_STRING = "";
var DEFAULT_VALUE_FOR_NUMBER = 0;
var BOOLEAN_TRUTHY_VALUES = ["1", "true", "t", "yes", "y", "on"];
var Value = class {
  constructor(_source, _value = DEFAULT_VALUE_FOR_STRING) {
    this._source = _source;
    this._value = _value;
  }
  asString() {
    return this._value;
  }
  asBoolean() {
    if (this._source === "static") {
      return DEFAULT_VALUE_FOR_BOOLEAN;
    }
    return BOOLEAN_TRUTHY_VALUES.indexOf(this._value.toLowerCase()) >= 0;
  }
  asNumber() {
    if (this._source === "static") {
      return DEFAULT_VALUE_FOR_NUMBER;
    }
    let num = Number(this._value);
    if (isNaN(num)) {
      num = DEFAULT_VALUE_FOR_NUMBER;
    }
    return num;
  }
  getSource() {
    return this._source;
  }
};
async function activate(remoteConfig) {
  const rc = getModularInstance(remoteConfig);
  const [lastSuccessfulFetchResponse, activeConfigEtag] = await Promise.all([
    rc._storage.getLastSuccessfulFetchResponse(),
    rc._storage.getActiveConfigEtag()
  ]);
  if (!lastSuccessfulFetchResponse || !lastSuccessfulFetchResponse.config || !lastSuccessfulFetchResponse.eTag || lastSuccessfulFetchResponse.eTag === activeConfigEtag) {
    return false;
  }
  await Promise.all([
    rc._storageCache.setActiveConfig(lastSuccessfulFetchResponse.config),
    rc._storage.setActiveConfigEtag(lastSuccessfulFetchResponse.eTag)
  ]);
  return true;
}
function ensureInitialized(remoteConfig) {
  const rc = getModularInstance(remoteConfig);
  if (!rc._initializePromise) {
    rc._initializePromise = rc._storageCache.loadFromStorage().then(() => {
      rc._isInitializationComplete = true;
    });
  }
  return rc._initializePromise;
}
async function fetchConfig(remoteConfig) {
  const rc = getModularInstance(remoteConfig);
  const abortSignal = new RemoteConfigAbortSignal();
  setTimeout(async () => {
    abortSignal.abort();
  }, rc.settings.fetchTimeoutMillis);
  try {
    await rc._client.fetch({
      cacheMaxAgeMillis: rc.settings.minimumFetchIntervalMillis,
      signal: abortSignal
    });
    await rc._storageCache.setLastFetchStatus("success");
  } catch (e) {
    const lastFetchStatus = hasErrorCode(e, "fetch-throttle") ? "throttle" : "failure";
    await rc._storageCache.setLastFetchStatus(lastFetchStatus);
    throw e;
  }
}
function getAll(remoteConfig) {
  const rc = getModularInstance(remoteConfig);
  return getAllKeys(rc._storageCache.getActiveConfig(), rc.defaultConfig).reduce((allConfigs, key) => {
    allConfigs[key] = getValue(remoteConfig, key);
    return allConfigs;
  }, {});
}
function getBoolean(remoteConfig, key) {
  return getValue(getModularInstance(remoteConfig), key).asBoolean();
}
function getNumber(remoteConfig, key) {
  return getValue(getModularInstance(remoteConfig), key).asNumber();
}
function getString(remoteConfig, key) {
  return getValue(getModularInstance(remoteConfig), key).asString();
}
function getValue(remoteConfig, key) {
  const rc = getModularInstance(remoteConfig);
  if (!rc._isInitializationComplete) {
    rc._logger.debug(`A value was requested for key "${key}" before SDK initialization completed. Await on ensureInitialized if the intent was to get a previously activated value.`);
  }
  const activeConfig = rc._storageCache.getActiveConfig();
  if (activeConfig && activeConfig[key] !== void 0) {
    return new Value("remote", activeConfig[key]);
  } else if (rc.defaultConfig && rc.defaultConfig[key] !== void 0) {
    return new Value("default", String(rc.defaultConfig[key]));
  }
  rc._logger.debug(`Returning static value for key "${key}". Define a default or remote value if this is unintentional.`);
  return new Value("static");
}
function setLogLevel3(remoteConfig, logLevel) {
  const rc = getModularInstance(remoteConfig);
  switch (logLevel) {
    case "debug":
      rc._logger.logLevel = LogLevel.DEBUG;
      break;
    case "silent":
      rc._logger.logLevel = LogLevel.SILENT;
      break;
    default:
      rc._logger.logLevel = LogLevel.ERROR;
  }
}
function getAllKeys(obj1 = {}, obj2 = {}) {
  return Object.keys(Object.assign(Object.assign({}, obj1), obj2));
}
var CachingClient = class {
  constructor(client, storage2, storageCache, logger5) {
    this.client = client;
    this.storage = storage2;
    this.storageCache = storageCache;
    this.logger = logger5;
  }
  isCachedDataFresh(cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis) {
    if (!lastSuccessfulFetchTimestampMillis) {
      this.logger.debug("Config fetch cache check. Cache unpopulated.");
      return false;
    }
    const cacheAgeMillis = Date.now() - lastSuccessfulFetchTimestampMillis;
    const isCachedDataFresh = cacheAgeMillis <= cacheMaxAgeMillis;
    this.logger.debug(`Config fetch cache check. Cache age millis: ${cacheAgeMillis}. Cache max age millis (minimumFetchIntervalMillis setting): ${cacheMaxAgeMillis}. Is cache hit: ${isCachedDataFresh}.`);
    return isCachedDataFresh;
  }
  async fetch(request) {
    const [lastSuccessfulFetchTimestampMillis, lastSuccessfulFetchResponse] = await Promise.all([
      this.storage.getLastSuccessfulFetchTimestampMillis(),
      this.storage.getLastSuccessfulFetchResponse()
    ]);
    if (lastSuccessfulFetchResponse && this.isCachedDataFresh(request.cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis)) {
      return lastSuccessfulFetchResponse;
    }
    request.eTag = lastSuccessfulFetchResponse && lastSuccessfulFetchResponse.eTag;
    const response = await this.client.fetch(request);
    const storageOperations = [
      this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())
    ];
    if (response.status === 200) {
      storageOperations.push(this.storage.setLastSuccessfulFetchResponse(response));
    }
    await Promise.all(storageOperations);
    return response;
  }
};
function getUserLanguage(navigatorLanguage = navigator) {
  return navigatorLanguage.languages && navigatorLanguage.languages[0] || navigatorLanguage.language;
}
var RestClient = class {
  constructor(firebaseInstallations, sdkVersion, namespace, projectId, apiKey, appId) {
    this.firebaseInstallations = firebaseInstallations;
    this.sdkVersion = sdkVersion;
    this.namespace = namespace;
    this.projectId = projectId;
    this.apiKey = apiKey;
    this.appId = appId;
  }
  async fetch(request) {
    const [installationId, installationToken] = await Promise.all([
      this.firebaseInstallations.getId(),
      this.firebaseInstallations.getToken()
    ]);
    const urlBase = window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com";
    const url = `${urlBase}/v1/projects/${this.projectId}/namespaces/${this.namespace}:fetch?key=${this.apiKey}`;
    const headers = {
      "Content-Type": "application/json",
      "Content-Encoding": "gzip",
      "If-None-Match": request.eTag || "*"
    };
    const requestBody = {
      sdk_version: this.sdkVersion,
      app_instance_id: installationId,
      app_instance_id_token: installationToken,
      app_id: this.appId,
      language_code: getUserLanguage()
    };
    const options = {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody)
    };
    const fetchPromise = fetch(url, options);
    const timeoutPromise = new Promise((_resolve, reject) => {
      request.signal.addEventListener(() => {
        const error = new Error("The operation was aborted.");
        error.name = "AbortError";
        reject(error);
      });
    });
    let response;
    try {
      await Promise.race([fetchPromise, timeoutPromise]);
      response = await fetchPromise;
    } catch (originalError) {
      let errorCode = "fetch-client-network";
      if (originalError.name === "AbortError") {
        errorCode = "fetch-timeout";
      }
      throw ERROR_FACTORY9.create(errorCode, {
        originalErrorMessage: originalError.message
      });
    }
    let status = response.status;
    const responseEtag = response.headers.get("ETag") || void 0;
    let config;
    let state;
    if (response.status === 200) {
      let responseBody;
      try {
        responseBody = await response.json();
      } catch (originalError) {
        throw ERROR_FACTORY9.create("fetch-client-parse", {
          originalErrorMessage: originalError.message
        });
      }
      config = responseBody["entries"];
      state = responseBody["state"];
    }
    if (state === "INSTANCE_STATE_UNSPECIFIED") {
      status = 500;
    } else if (state === "NO_CHANGE") {
      status = 304;
    } else if (state === "NO_TEMPLATE" || state === "EMPTY_CONFIG") {
      config = {};
    }
    if (status !== 304 && status !== 200) {
      throw ERROR_FACTORY9.create("fetch-status", {
        httpStatus: status
      });
    }
    return { status, eTag: responseEtag, config };
  }
};
function setAbortableTimeout2(signal, throttleEndTimeMillis) {
  return new Promise((resolve, reject) => {
    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    const timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(() => {
      clearTimeout(timeout);
      reject(ERROR_FACTORY9.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError2(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  const httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var RetryingClient = class {
  constructor(client, storage2) {
    this.client = client;
    this.storage = storage2;
  }
  async fetch(request) {
    const throttleMetadata = await this.storage.getThrottleMetadata() || {
      backoffCount: 0,
      throttleEndTimeMillis: Date.now()
    };
    return this.attemptFetch(request, throttleMetadata);
  }
  async attemptFetch(request, { throttleEndTimeMillis, backoffCount }) {
    await setAbortableTimeout2(request.signal, throttleEndTimeMillis);
    try {
      const response = await this.client.fetch(request);
      await this.storage.deleteThrottleMetadata();
      return response;
    } catch (e) {
      if (!isRetriableError2(e)) {
        throw e;
      }
      const throttleMetadata = {
        throttleEndTimeMillis: Date.now() + calculateBackoffMillis(backoffCount),
        backoffCount: backoffCount + 1
      };
      await this.storage.setThrottleMetadata(throttleMetadata);
      return this.attemptFetch(request, throttleMetadata);
    }
  }
};
var DEFAULT_FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DEFAULT_CACHE_MAX_AGE_MILLIS = 12 * 60 * 60 * 1e3;
var RemoteConfig = class {
  constructor(app, _client, _storageCache, _storage, _logger) {
    this.app = app;
    this._client = _client;
    this._storageCache = _storageCache;
    this._storage = _storage;
    this._logger = _logger;
    this._isInitializationComplete = false;
    this.settings = {
      fetchTimeoutMillis: DEFAULT_FETCH_TIMEOUT_MILLIS,
      minimumFetchIntervalMillis: DEFAULT_CACHE_MAX_AGE_MILLIS
    };
    this.defaultConfig = {};
  }
  get fetchTimeMillis() {
    return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1;
  }
  get lastFetchStatus() {
    return this._storageCache.getLastFetchStatus() || "no-fetch-yet";
  }
};
function toFirebaseError(event, errorCode) {
  const originalError = event.target.error || void 0;
  return ERROR_FACTORY9.create(errorCode, {
    originalErrorMessage: originalError && originalError.message
  });
}
var APP_NAMESPACE_STORE = "app_namespace_store";
var DB_NAME2 = "firebase_remote_config";
var DB_VERSION2 = 1;
function openDatabase() {
  return new Promise((resolve, reject) => {
    try {
      const request = indexedDB.open(DB_NAME2, DB_VERSION2);
      request.onerror = (event) => {
        reject(toFirebaseError(event, "storage-open"));
      };
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        switch (event.oldVersion) {
          case 0:
            db.createObjectStore(APP_NAMESPACE_STORE, {
              keyPath: "compositeKey"
            });
        }
      };
    } catch (error) {
      reject(ERROR_FACTORY9.create("storage-open", {
        originalErrorMessage: error
      }));
    }
  });
}
var Storage = class {
  constructor(appId, appName, namespace, openDbPromise = openDatabase()) {
    this.appId = appId;
    this.appName = appName;
    this.namespace = namespace;
    this.openDbPromise = openDbPromise;
  }
  getLastFetchStatus() {
    return this.get("last_fetch_status");
  }
  setLastFetchStatus(status) {
    return this.set("last_fetch_status", status);
  }
  getLastSuccessfulFetchTimestampMillis() {
    return this.get("last_successful_fetch_timestamp_millis");
  }
  setLastSuccessfulFetchTimestampMillis(timestamp) {
    return this.set("last_successful_fetch_timestamp_millis", timestamp);
  }
  getLastSuccessfulFetchResponse() {
    return this.get("last_successful_fetch_response");
  }
  setLastSuccessfulFetchResponse(response) {
    return this.set("last_successful_fetch_response", response);
  }
  getActiveConfig() {
    return this.get("active_config");
  }
  setActiveConfig(config) {
    return this.set("active_config", config);
  }
  getActiveConfigEtag() {
    return this.get("active_config_etag");
  }
  setActiveConfigEtag(etag) {
    return this.set("active_config_etag", etag);
  }
  getThrottleMetadata() {
    return this.get("throttle_metadata");
  }
  setThrottleMetadata(metadata) {
    return this.set("throttle_metadata", metadata);
  }
  deleteThrottleMetadata() {
    return this.delete("throttle_metadata");
  }
  async get(key) {
    const db = await this.openDbPromise;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([APP_NAMESPACE_STORE], "readonly");
      const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
      const compositeKey = this.createCompositeKey(key);
      try {
        const request = objectStore.get(compositeKey);
        request.onerror = (event) => {
          reject(toFirebaseError(event, "storage-get"));
        };
        request.onsuccess = (event) => {
          const result = event.target.result;
          if (result) {
            resolve(result.value);
          } else {
            resolve(void 0);
          }
        };
      } catch (e) {
        reject(ERROR_FACTORY9.create("storage-get", {
          originalErrorMessage: e && e.message
        }));
      }
    });
  }
  async set(key, value) {
    const db = await this.openDbPromise;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([APP_NAMESPACE_STORE], "readwrite");
      const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
      const compositeKey = this.createCompositeKey(key);
      try {
        const request = objectStore.put({
          compositeKey,
          value
        });
        request.onerror = (event) => {
          reject(toFirebaseError(event, "storage-set"));
        };
        request.onsuccess = () => {
          resolve();
        };
      } catch (e) {
        reject(ERROR_FACTORY9.create("storage-set", {
          originalErrorMessage: e && e.message
        }));
      }
    });
  }
  async delete(key) {
    const db = await this.openDbPromise;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([APP_NAMESPACE_STORE], "readwrite");
      const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
      const compositeKey = this.createCompositeKey(key);
      try {
        const request = objectStore.delete(compositeKey);
        request.onerror = (event) => {
          reject(toFirebaseError(event, "storage-delete"));
        };
        request.onsuccess = () => {
          resolve();
        };
      } catch (e) {
        reject(ERROR_FACTORY9.create("storage-delete", {
          originalErrorMessage: e && e.message
        }));
      }
    });
  }
  createCompositeKey(key) {
    return [this.appId, this.appName, this.namespace, key].join();
  }
};
var StorageCache = class {
  constructor(storage2) {
    this.storage = storage2;
  }
  getLastFetchStatus() {
    return this.lastFetchStatus;
  }
  getLastSuccessfulFetchTimestampMillis() {
    return this.lastSuccessfulFetchTimestampMillis;
  }
  getActiveConfig() {
    return this.activeConfig;
  }
  async loadFromStorage() {
    const lastFetchStatusPromise = this.storage.getLastFetchStatus();
    const lastSuccessfulFetchTimestampMillisPromise = this.storage.getLastSuccessfulFetchTimestampMillis();
    const activeConfigPromise = this.storage.getActiveConfig();
    const lastFetchStatus = await lastFetchStatusPromise;
    if (lastFetchStatus) {
      this.lastFetchStatus = lastFetchStatus;
    }
    const lastSuccessfulFetchTimestampMillis = await lastSuccessfulFetchTimestampMillisPromise;
    if (lastSuccessfulFetchTimestampMillis) {
      this.lastSuccessfulFetchTimestampMillis = lastSuccessfulFetchTimestampMillis;
    }
    const activeConfig = await activeConfigPromise;
    if (activeConfig) {
      this.activeConfig = activeConfig;
    }
  }
  setLastFetchStatus(status) {
    this.lastFetchStatus = status;
    return this.storage.setLastFetchStatus(status);
  }
  setLastSuccessfulFetchTimestampMillis(timestampMillis) {
    this.lastSuccessfulFetchTimestampMillis = timestampMillis;
    return this.storage.setLastSuccessfulFetchTimestampMillis(timestampMillis);
  }
  setActiveConfig(activeConfig) {
    this.activeConfig = activeConfig;
    return this.storage.setActiveConfig(activeConfig);
  }
};
function registerRemoteConfig() {
  _registerComponent(new Component(RC_COMPONENT_NAME, remoteConfigFactory2, "PUBLIC").setMultipleInstances(true));
  registerVersion(name18, version18);
  registerVersion(name18, version18, "esm2017");
  function remoteConfigFactory2(container, { instanceIdentifier: namespace }) {
    const app = container.getProvider("app").getImmediate();
    const installations = container.getProvider("installations-internal").getImmediate();
    if (typeof window === "undefined") {
      throw ERROR_FACTORY9.create("registration-window");
    }
    if (!isIndexedDBAvailable()) {
      throw ERROR_FACTORY9.create("indexed-db-unavailable");
    }
    const { projectId, apiKey, appId } = app.options;
    if (!projectId) {
      throw ERROR_FACTORY9.create("registration-project-id");
    }
    if (!apiKey) {
      throw ERROR_FACTORY9.create("registration-api-key");
    }
    if (!appId) {
      throw ERROR_FACTORY9.create("registration-app-id");
    }
    namespace = namespace || "firebase";
    const storage2 = new Storage(appId, app.name, namespace);
    const storageCache = new StorageCache(storage2);
    const logger5 = new Logger(name18);
    logger5.logLevel = LogLevel.ERROR;
    const restClient = new RestClient(installations, SDK_VERSION, namespace, projectId, apiKey, appId);
    const retryingClient = new RetryingClient(restClient, storage2);
    const cachingClient = new CachingClient(retryingClient, storage2, storageCache, logger5);
    const remoteConfigInstance = new RemoteConfig(app, cachingClient, storageCache, storage2, logger5);
    ensureInitialized(remoteConfigInstance);
    return remoteConfigInstance;
  }
}
async function fetchAndActivate(remoteConfig) {
  remoteConfig = getModularInstance(remoteConfig);
  await fetchConfig(remoteConfig);
  return activate(remoteConfig);
}
async function isSupported3() {
  if (!isIndexedDBAvailable()) {
    return false;
  }
  try {
    const isDBOpenable = await validateIndexedDBOpenable();
    return isDBOpenable;
  } catch (error) {
    return false;
  }
}
registerRemoteConfig();

// node_modules/@firebase/remote-config-compat/dist/esm/index.esm2017.js
var RemoteConfigCompatImpl = class {
  constructor(app, _delegate) {
    this.app = app;
    this._delegate = _delegate;
  }
  get defaultConfig() {
    return this._delegate.defaultConfig;
  }
  set defaultConfig(value) {
    this._delegate.defaultConfig = value;
  }
  get fetchTimeMillis() {
    return this._delegate.fetchTimeMillis;
  }
  get lastFetchStatus() {
    return this._delegate.lastFetchStatus;
  }
  get settings() {
    return this._delegate.settings;
  }
  set settings(value) {
    this._delegate.settings = value;
  }
  activate() {
    return activate(this._delegate);
  }
  ensureInitialized() {
    return ensureInitialized(this._delegate);
  }
  fetch() {
    return fetchConfig(this._delegate);
  }
  fetchAndActivate() {
    return fetchAndActivate(this._delegate);
  }
  getAll() {
    return getAll(this._delegate);
  }
  getBoolean(key) {
    return getBoolean(this._delegate, key);
  }
  getNumber(key) {
    return getNumber(this._delegate, key);
  }
  getString(key) {
    return getString(this._delegate, key);
  }
  getValue(key) {
    return getValue(this._delegate, key);
  }
  setLogLevel(logLevel) {
    setLogLevel3(this._delegate, logLevel);
  }
};
var name19 = "@firebase/remote-config-compat";
var version19 = "0.1.5";
function registerRemoteConfigCompat(firebaseInstance) {
  firebaseInstance.INTERNAL.registerComponent(new Component("remoteConfig-compat", remoteConfigFactory, "PUBLIC").setMultipleInstances(true).setServiceProps({ isSupported: isSupported3 }));
  firebaseInstance.registerVersion(name19, version19);
}
function remoteConfigFactory(container, { instanceIdentifier: namespace }) {
  const app = container.getProvider("app-compat").getImmediate();
  const remoteConfig = container.getProvider("remote-config").getImmediate({
    identifier: namespace
  });
  return new RemoteConfigCompatImpl(app, remoteConfig);
}
registerRemoteConfigCompat(firebase);

// node_modules/firebase/compat/dist/index.esm.js
var name$1 = "firebase";
var version$1 = "9.6.8";
firebase.registerVersion(name$1, version$1, "app-compat");
var name20 = "firebase";
var version20 = "9.6.8";
console.warn("\nIt looks like you're using the development build of the Firebase JS SDK.\nWhen deploying Firebase apps to production, it is advisable to only import\nthe individual SDK components you intend to use.\n\nFor the module builds, these are available in the following manner\n(replace <PACKAGE> with the name of a component - i.e. auth, database, etc):\n\nCommonJS Modules:\nconst firebase = require('firebase/app');\nrequire('firebase/<PACKAGE>');\n\nES Modules:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n\nTypescript:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n");
firebase.registerVersion(name20, version20, "compat");

// dep:firebase_compat
var firebase_compat_default = firebase;
export {
  firebase_compat_default as default
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//# sourceMappingURL=firebase_compat.js.map
